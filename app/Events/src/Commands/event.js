const axios = require('axios');
const canvas = require('canvas');
const ytdl = require('ytdl-core');
const bots = require('../../../../bots.json');
const { writeFile, writeFileSync } = require('fs');
const { makeid } = require('../Structure/numbersGenerator.js');
const { menuRole, menuUser, pageChange } = require('../Structure/buttonGenerator.js');
const { joinVoiceChannel, createAudioPlayer, createAudioResource, getVoiceConnection } = require('@discordjs/voice');
const { getCurrentDateTime, hourTranslator, hourTranslatorBold, clockTranslator } = require('../Structure/timeManage.js');
const { getAvatar, targetMessageEditComponents, getColorEmoji, getArrayRandElement, getBlackWhiteImage } = require('../Structure/getAttribute.js');
const { checkingForAvailability, сheckingForTimeout, checkingForNumber, checkingForValidImageURL, checkingForRoles } = require('../Structure/checkingFor.js');
const { AuditLogEvent, ActionRowBuilder, ModalBuilder, TextInputBuilder, TextInputStyle, ChannelType, PermissionsBitField, GuildScheduledEventEntityType, GuildScheduledEventPrivacyLevel } = require('discord.js');


module.exports = async (client, appearance, config, db, args, argsF, interaction) => {
    
    if (!interaction.guild) return;
    canvas.registerFont('./assets/fonts/MediumMonts.ttf', { family: 'MediumMonts' });

    const { member, channel, guild } = interaction;
    const { users, guilds, stats } = db;

    const commandTime = Date.now() / 1000;
    const memberAvatar = await getAvatar(member);

    checkingForAvailability (db, member);
    
    const actions = {}; 
    let parameters = {};
    let game = {};


    function getCurrentDateTimeTxt (hours) {
                        
        const currentDate = new Date();
        
        currentDate.setHours(currentDate.getHours() + hours);             
        const offsetInMinutes = currentDate.getTimezoneOffset();
        
        const offsetString =
            (offsetInMinutes < 0 ? "+" : "-") +
            String(Math.abs(offsetInMinutes / 60)).padStart(2, "0") +
            ":" +
            String(Math.abs(offsetInMinutes % 60)).padStart(2, "0");
        
        const formattedDateTime = currentDate.toISOString().replace("Z", offsetString);
        
        return formattedDateTime;

    }; 
    

    // for (const guild of client.guilds.cache) if (guild[1].ownerId == client.user.id) {

    //     const pickGuildFetch = await client.guilds.fetch(guild[0]);
    //     pickGuildFetch.delete().catch(() => {});

    // };

    if (users[member.id].ActiveEvent) {

        if (!guilds[users[member.id].ActiveEvent] || !guilds[users[member.id].ActiveEvent].channels) return;
        const fetchChannelEvent = await guild.channels.fetch(guilds[users[member.id].ActiveEvent].channels.voice).catch(() => {});
        if (!fetchChannelEvent || guilds[users[member.id].ActiveEvent].deleted) {

            guilds[guild.id].Events.Active = guilds[guild.id].Events.Active.filter((n) => { return n != users[member.id].ActiveEvent });
            users[member.id].ActiveEvent = false;

            if (guilds[users[member.id].ActiveEvent] && guilds[users[member.id].ActiveEvent].message && guilds[users[member.id].ActiveEvent].message.announcement) 
            guilds[users[member.id].ActiveEvent].message.announcement.edit({
                content: ' ',
                components: [
                    {
                        type: 1,
                        components: [
                            {
                                type: 2, 
                                style: 5, 
                                label: 'Мероприятие окончено', 
                                url: `https://discord.gg/BneyWRqe`,
                                disabled: true 
                            }
                        ]
                    }
                ]
            }).catch(() => {});

            if (guilds[users[member.id].ActiveEvent] && guilds[users[member.id].ActiveEvent].game && guilds[users[member.id].ActiveEvent].servers) {
                
                for (n=0; n < guilds[users[member.id].ActiveEvent].servers.length; n++) guilds[users[member.id].ActiveEvent].servers[n].guild.delete().catch(() => {});

            };
            
        };

    };

    if (argsF.subcommand == 'create') {

        async function createEvent (eventOfCategory, i, reply) {

            if (eventOfCategory.type == 'event') {
                
                const heightChannels = await guild.channels.fetch(appearance.channels.Closes.heightChannelCreate).catch(() => {});
                const Position = heightChannels.rawPosition ?? 0;

                const eventCategory = await guild.channels.create(
                    {
                        name: `${eventOfCategory.name}・${member.displayName}`,
                        type: ChannelType.GuildCategory,
                        position: Position
                    }
                ).catch(() => {});

                const eventManageChannel = await guild.channels.create(
                    {
                        name: `${appearance.custom.Events.channels.manage}`,
                        type: ChannelType.GuildText,
                        parent: eventCategory.id,
                        permissionOverwrites: [
                            {
                                id: guild.id,
                                deny: [PermissionsBitField.Flags.ViewChannel]
                            },
                            {
                                id: member.id,
                                allow: [PermissionsBitField.Flags.ViewChannel, PermissionsBitField.Flags.SendMessages]
                            }
                        ]
                    }
                ).catch(() => {});
                

                if (reply) {

                    setTimeout(() => {
                        
                        i.editReply({
                            embeds: [
                                {
                                    title: `${client.user.username} create`,
                                    color: appearance.embed.color,
                                    description: `${member}, Вы **успешно** создали мероприятие **${eventOfCategory.name}**, для управления зайдите в ${eventManageChannel}`,
                                    thumbnail: { url: memberAvatar } 
                                }
                            ], 
                            components: [
                                
                            ]
                        }).catch(() => {});

                    }, 1000);

                }
                
                else 
                i.update({
                    embeds: [
                        {
                            title: `${client.user.username} create`,
                            color: appearance.embed.color,
                            description: `${member}, Вы **успешно** создали мероприятие **${eventOfCategory.name}**, для управления зайдите в ${eventManageChannel}`,
                            thumbnail: { url: memberAvatar } 
                        }
                    ], 
                    components: [
                        
                    ]
                }).catch(() => {});


                const eventInfoChannel = await guild.channels.create(
                    {
                        name: `${appearance.custom.Events.channels.info}`,
                        type: ChannelType.GuildText,
                        parent: eventCategory.id,
                        permissionOverwrites: [
                            {
                                id: guild.id,
                                deny: [PermissionsBitField.Flags.ViewChannel, PermissionsBitField.Flags.SendMessages, PermissionsBitField.Flags.ManageChannels],
                                allow: [PermissionsBitField.Flags.ViewChannel]
                            }, 
                            {
                                id: member.id, 
                                allow: [PermissionsBitField.Flags.ViewChannel, PermissionsBitField.Flags.AttachFiles, PermissionsBitField.Flags.ManageMessages, PermissionsBitField.Flags.SendMessages]
                            }
                        ]
                    }
                ).catch(() => {});

                const eventVoiceChannel = await guild.channels.create(
                    {
                        name: `${eventOfCategory.channels.voice}`,
                        type: ChannelType.GuildVoice,
                        parent: eventCategory.id,
                        permissionOverwrites: [
                            {
                                id: guild.id,
                                deny: [PermissionsBitField.Flags.ViewChannel, PermissionsBitField.Flags.ViewChannel, PermissionsBitField.Flags.UseEmbeddedActivities, PermissionsBitField.Flags.ManageChannels],
                                allow: [PermissionsBitField.Flags.ViewChannel, PermissionsBitField.Flags.Connect]
                            }, 
                            {
                                id: member.id, 
                                allow: [PermissionsBitField.Flags.ViewChannel, PermissionsBitField.Flags.AttachFiles, PermissionsBitField.Flags.ManageEvents, PermissionsBitField.Flags.Connect, PermissionsBitField.Flags.MuteMembers, PermissionsBitField.Flags.MoveMembers, PermissionsBitField.Flags.Stream, PermissionsBitField.Flags.Stream, PermissionsBitField.Flags.UseEmbeddedActivities]
                            }
                        ]
                    }
                ).catch(() => {});

                eventInfoChannel.permissionOverwrites.edit(appearance.roles.Events.ban, { ViewChannel: false }).catch(() => {});
                eventVoiceChannel.permissionOverwrites.edit(appearance.roles.Events.ban, { ManageEvents: false, Speak: false, ViewChannel: true, Connect: false }).catch(() => {});

                const EventId = makeid(20);

                const logsEvents = await guild.channels.fetch(appearance.channels.Events.logs);

                const logMessage = await logsEvents.send({  
                    content: `<t:${Math.floor(Date.now()/1000)}:f>`,
                    embeds: [
                        {
                            author: { name: 'Мероприятие создано' },
                            title: `${client.user.username + ' logs'}`,
                            color: appearance.embed.color,
                            description: `Создано: <t:${Math.floor(Date.now()/1000)}:f>`,
                            fields: [
                                {
                                    name: `${appearance.embed.dot || appearance.emoji.Dot}Создал:`,
                                    value: `・${member}\n・${member.id}`,  
                                    inline: true
                                },
                                {
                                    name: `${appearance.embed.dot || appearance.emoji.Dot}Канал:`,
                                    value: `・${eventVoiceChannel}\n・${eventVoiceChannel.id}`,
                                    inline: true
                                },
                                {
                                    name: `${appearance.embed.dot || appearance.emoji.Dot}Мероприятие:`,
                                    value: `\`\`\`${eventOfCategory.name}\`\`\``,
                                    inline: false
                                }
                            ],
                            footer: { text: `・Ведущий: ${member.displayName}` },
                            thumbnail: { url: memberAvatar },
                        }
                    ],
                    components: [

                    ]
                }).catch(() => {});


                const scheduledEvent = await guild.scheduledEvents.create({
                    name: `${eventOfCategory.name}`,
                    scheduledStartTime: new Date(Date.now() + 5 * 1000), 
                    scheduledEndTime: new Date(Date.now() + 24 * 60 * 60 * 1000),
                    privacyLevel: GuildScheduledEventPrivacyLevel.GuildOnly, 
                    entityType: GuildScheduledEventEntityType.Voice, 
                    channel: eventVoiceChannel.id, 
                    description: `${eventOfCategory.embed.info.description ? eventOfCategory.embed.info.description : 'Отсутствует'}`,
                    image: eventOfCategory.embed.info.image || null
                }).catch(() => {});
                
                scheduledEvent.setStatus(2).catch(() => {});


                async function errorNoEventsOwnerMessage (One) {

                    const pickMemberAvater = await getAvatar(One);

                    return {
                        ephemeral: true,
                        embeds: [
                            {
                                title: `${client.user.username} error`,
                                color: appearance.embed.errorColor,
                                description: `${One}, для того, чтобы **использовать** данную кнопку, Вам **необходимо** быть ведущим** данного** мероприятия`,
                                thumbnail: { url: pickMemberAvater }
                            }
                        ], 
                        components: [
                            
                        ]
                    };

                };
                    

                let infoEmbeds = [];
                parameters.announcementMessage = false;

                infoEmbeds.push(
                    {
                        title: `Доступно: ${eventOfCategory.name}`,
                        color: appearance.embed.color,
                        description: `## ${appearance.emoji.Info} Информация\n${eventOfCategory.embed.info.description ? eventOfCategory.embed.info.description : 'Отсутствует'}\n## ${appearance.emoji.Rules} Правила\n-# Наказания выдаёт ведущий мероприятия\n${eventOfCategory.embed.info.rules ? eventOfCategory.embed.info.rules : appearance.custom.Events.default.rules ? appearance.customs.Events.default.rules : 'Отсутствуют'}`,
                        image: { url: `${appearance.custom.Events.default.nullImage}` },
                    }
                );

                infoEmbeds.push(
                    {
                        title: `Мероприятие: ${eventOfCategory.name}`,
                        color: appearance.embed.color,
                        description: `-# Привет, **добро пожаловать** на мероприятие **${eventOfCategory.name}**! Его ведущим является ${member}, по всем вопросам о мероприятие обращайся к нему.\n\n**Информация**:\n・Данное мероприятие **начато**: <t:${Math.floor(Date.now()/1000)}:f>\n・Текстовой чат: ${eventInfoChannel}\n-# Писать в нем можно только находясь в ${eventVoiceChannel}\n・Голосовой канал: ${eventVoiceChannel}`,
                        image: { url: `${eventOfCategory.embed.info.image || appearance.custom.Events.default.nullImage}` },
                        footer: { text: `・Ведущий: ${member.displayName}`, icon_url: memberAvatar }
                    }
                );

                const infoMessage = await eventInfoChannel.send({  
                    content: `https://discord.com/events/${guild.id}/${!scheduledEvent ? scheduledEvent.id : '0'}`,
                    embeds: infoEmbeds,
                    components: [
                        {
                            type: 1,
                            components: [
                                {
                                    type: 2, 
                                    style: 3, 
                                    customId: 'go',
                                    label: 'Присоединится' 
                                },
                                {
                                    type: 2, 
                                    style: 5, 
                                    emoji: appearance.emoji.Rules,
                                    url: `https://discord.com/channels/${guild.id}/${appearance.channels.Rules}`,
                                    label: 'Основные правила' 
                                }
                            ]
                        }
                    ]
                }).catch(() => {});


                let membersOfGo = [];

                const collectorConponentsOfRecordChannel = await infoMessage.createMessageComponentCollector();
                collectorConponentsOfRecordChannel.on('collect', async i => {

                    let eventOwner = await guild.members.fetch(guilds[EventId].Owner).catch(() => {});

                    switch (i.customId) { 

                        case 'go': {

                            if (eventVoiceChannel.permissionsFor(i.member.id).has(PermissionsBitField.Flags.Connect)) 
                            return i.reply({
                                ephemeral: true,  
                                embeds: [
                                    {
                                        title: `${client.user.username} error`,
                                        color: appearance.embed.errorColor,
                                        description: `${i.member}, Вы **можете** заходить в канал ${eventVoiceChannel}`,
                                        thumbnail: { url: await getAvatar(i.member) }
                                    }
                                ],
                                components: [

                                ]
                            });
                            

                            if (membersOfGo.includes(i.member.id)) 
                            return i.reply({
                                ephemeral: true,
                                embeds: [
                                    {
                                        title: `${client.user.username} error`,
                                        color: appearance.embed.errorColor,
                                        description: `${i.member}, Вы **уже отправили** заявку для доступа`,
                                        thumbnail: { url: await getAvatar(i.member) }
                                    }
                                ], 
                                components: [ 
                        
                                ]
                            }).catch(() => {});

                            i.update().catch(() => {});

                            const accessMessage = await eventInfoChannel.send({
                                content: `${eventOwner}`,
                                embeds: [
                                    {
                                        title: `${client.user.username} access`,
                                        color: appearance.embed.color,
                                        description: `${i.member} хочет присоединиться к [**${eventOfCategory.emoji}・${eventOfCategory.name}**](https://discord.com/channels/${eventVoiceChannel.guild.id}/${eventVoiceChannel.id})`,
                                        thumbnail: { url: await getAvatar(i.member) }
                                    }
                                ], 
                                components: [ 
                                    {
                                        type: 1,
                                        components: [
                                            {
                                                type: 2, 
                                                style: 3, 
                                                customId: 'yes',
                                                label: 'Принять' 
                                            },
                                            {
                                                type: 2, 
                                                style: 4, 
                                                customId: 'no',
                                                label: 'Отклонить' 
                                            }
                                        ]
                                    }
                                ]
                            }).catch(() => {});

                            membersOfGo.push(i.member.id);

                            const collectorConponentsOfRecordChannel = await accessMessage.createMessageComponentCollector();
                            collectorConponentsOfRecordChannel.on('collect', async newI => {
            
                                let eventOwner = await guild.members.fetch(guilds[EventId].Owner).catch(() => {});
                                if (eventOwner.id !== newI.member.id) return errorNoEventsOwnerMessage (One);
            
                                switch (newI.customId) { 
            
                                    case 'yes': {

                                        accessMessage.delete().catch(() => {});
                                        eventVoiceChannel.permissionOverwrites.edit(i.member.id, { ViewChannel: true,  Connect: true }).catch(() => {});

                                        i.member.send({
                                            embeds: [
                                                {
                                                    title: `${client.user.username} access`,
                                                    color: appearance.embed.color,
                                                    description: `Вам открыли доступ к [**${eventOfCategory.emoji}・${eventOfCategory.name}**](https://discord.com/channels/${eventVoiceChannel.guild.id}/${eventVoiceChannel.id})`,
                                                    thumbnail: { url: await getAvatar(newI.member) }
                                                }
                                            ], 
                                            components: [ 
                                                {
                                                    type: 1,
                                                    components: [
                                                        {
                                                            type: 2, 
                                                            style: 5, 
                                                            url: `https://discord.com/channels/${eventVoiceChannel.guild.id}/${eventVoiceChannel.id}`,
                                                            label: `Перейти в #${eventVoiceChannel.name}` 
                                                        }
                                                    ]
                                                }
                                            ]
                                        }).catch(() => {});
                                        
                                        break;

                                    }
            
                                    case 'no': {

                                        accessMessage.delete().catch(() => {});
                                        
                                        break;

                                    }

                                }

                            });

                            break;

                        }
                    
                    };

                });


                infoMessage.startThread({ name: appearance.custom.Events.default.notes }).catch(() => {});
                infoMessage.pin().catch(() => {});

                let additionInformationOrCommand = '';
                const commands = await client.application.commands.fetch().catch(() => {});

                commands.forEach(command => {
                    if (command.name == 'event') {
                        additionInformationOrCommand += `\n\n</event reward:${command.id}> — Выдать **награды**\n</event transfer:${command.id}> — Передать мероприятие\n-# </event delete:${command.id}> — (Резервное) удаление мероприятия`
                    };
                });

                let manageMessage = await eventManageChannel.send({  
                    embeds: [
                        {
                            title: `Управление: ${eventOfCategory.name}`,
                            color: appearance.embed.color,
                            fields: additionInformationOrCommand ?
                            [
                                {
                                    name: 'Кнопки:',
                                    value: `${appearance.emoji.Announcement} — Анонсировать в <#${appearance.channels.Announcement}>\n${appearance.emoji.EditLimit} — Установить **лимит** пользователей\n${appearance.emoji.Block} — Закрыть/открыть ${eventVoiceChannel} для всех\n${appearance.emoji.UserBlock} — Забрать/выдать право **заходить**\n${appearance.emoji.UserMute} — Забрать/выдать право **говорить**\n${appearance.emoji.Delete} — Досрочно **завершить** данное мероприятие`,
                                    inline: false
                                },
                                {
                                    name: 'Команды:',
                                    value: `${additionInformationOrCommand}`,
                                    inline: false
                                }
                            ]
                            :
                            [
                                {
                                    name: 'Кнопки:',
                                    value: `${appearance.emoji.Announcement} — Анонсировать в <#${appearance.channels.Announcement}>\n${appearance.emoji.EditLimit} — Установить **лимит** пользователей\n${appearance.emoji.Block} — Закрыть/открыть ${eventVoiceChannel} для всех\n${appearance.emoji.UserBlock} — Забрать/выдать право **заходить**\n${appearance.emoji.UserMute} — Забрать/выдать право **говорить**\n${appearance.emoji.Delete} — Досрочно **завершить** данное мероприятие`,
                                    inline: false
                                }
                            ]
                        }
                    ],
                    components: [
                        {
                            type: 1,
                            components: [
                                {
                                    type: 2, 
                                    style: appearance.buttons_menu.Default.style, 
                                    customId: 'announcement', 
                                    emoji: appearance.emoji.Announcement
                                },
                                {
                                    type: 2, 
                                    style: appearance.buttons_menu.Default.style, 
                                    customId: 'limit', 
                                    emoji: appearance.emoji.EditLimit
                                },
                                {
                                    type: 2, 
                                    style: appearance.buttons_menu.Default.style, 
                                    customId: 'block', 
                                    emoji: appearance.emoji.Block
                                }
                            ]
                        },
                        {
                            type: 1,
                            components: [
                                {
                                    type: 2, 
                                    style: appearance.buttons_menu.Default.style, 
                                    customId: 'ban', 
                                    emoji: appearance.emoji.UserBlock
                                },
                                {
                                    type: 2, 
                                    style: appearance.buttons_menu.Default.style, 
                                    customId: 'mute', 
                                    emoji: appearance.emoji.UserMute
                                },
                                {
                                    type: 2, 
                                    style: appearance.buttons_menu.Default.style, 
                                    customId: 'delete', 
                                    emoji: appearance.emoji.Delete
                                }
                            ]
                        }
                    ]
                }).catch(() => {});

                
                users[member.id].ActiveEvent = EventId;
                guilds[guild.id].Events.Active.push(EventId);

                guilds[EventId] = {

                    type: 'event',

                    channels: {

                        category: eventCategory.id,
                        manage: eventManageChannel.id,
                        info: eventInfoChannel.id,
                        voice: eventVoiceChannel.id

                    },

                    EventId: EventId,
                    ManageLink: `https://discord.com/channels/${guild.id}/${eventManageChannel.id}`,
                    Owner: member.id,
                    Created: Date.now () / 1000,
                    Event: eventOfCategory,
                    Online: [],

                    rewardLast: false,
                    reward: false,

                    message: {

                        info: infoMessage,
                        manage: manageMessage,
                        log: logMessage,
                        announcement: false

                    }

                };

                guilds[eventVoiceChannel.id] = {

                    id: EventId,
                    online: {}

                };


                async function announcementMessageSend (One, Two, Three) {

                    const eventOwnerAvatar = await getAvatar(Two);

                    let fields = [];

                    for (const pickReward in eventOfCategory.rewards) {

                        fields.push(
                            {
                                name: `${pickReward}`,
                                value: `${eventOfCategory.rewards[pickReward].reward} ${appearance.emoji.Coin}`,
                                inline: true
                            }
                        );

                    };

                    if (!fields[0]) {

                        fields.push(
                            {
                                name: `Награды за мероприятие`,
                                value: 'Отсутствуют',
                                inline: true
                            }
                        );

                    };

                    let contentPingRoles = '';
                    for (let role in appearance.roles.Events.notification) {

                        const roleFetch = await guild.roles.fetch(appearance.roles.Events.notification[role]).catch(() => {});
                        if (roleFetch && contentPingRoles == '') contentPingRoles += `${roleFetch}`;
                        else if (roleFetch && contentPingRoles !== '') contentPingRoles += `, ${roleFetch}`;

                    };
                    
                    return {

                        content: contentPingRoles == '' ? ' ' : contentPingRoles,
                        embeds: [
                            {
                                title: `Мероприятие: ${One}`,
                                color: appearance.embed.color,
                                description: `\`\`\`${eventOfCategory.miniDescription ? eventOfCategory.miniDescription : 'Отсутствует'}\`\`\``,
                                fields: fields,
                                image: { url: eventOfCategory.embed.info.image || appearance.custom.Events.default.nullImage },
                                footer: { text: `・Ведущий: ${Two.displayName}`, icon_url: eventOwnerAvatar }
                            }
                        ], 
                        components: Three

                    };

                };

                
                setInterval(async () => {

                    if (guilds[EventId].deleted) return;

                    const eventOwner = await guild.members.fetch(guilds[EventId].Owner).catch(() => {});
                    const eventManageChannelFetch = await guild.channels.fetch(eventManageChannel.id).catch(() => {});
                    
                    if (!eventOwner) {

                        guilds[EventId].deleted = true;
                        manageMessage.delete().catch(() => {});

                        let pick = 0;
                        let channelsEvent = [eventVoiceChannel, eventInfoChannel, eventManageChannel, eventCategory];
                        setInterval(async () => {

                            if (pick == channelsEvent.length) return;
                            channelsEvent[pick].delete().catch(() => {});
                            pick++;

                        }, 1000);


                        logMessage.edit({  
                            content: `<t:${Math.floor(Date.now()/1000)}:f>`,
                            embeds: [
                                {
                                    author: { name: 'Мероприятие завершено' },
                                    title: `${client.user.username + ' logs'}`,
                                    color: appearance.embed.color,
                                    description: `Создано: <t:${Math.floor(guilds[EventId].Created)}:f>\nЗавершено: <t:${Math.floor(Date.now()/1000)}:f>`,
                                    fields: [
                                        {
                                            name: `${appearance.embed.dot || appearance.emoji.Dot}Создавал:`,
                                            value: `・${member}\n・${member.id}`,  
                                            inline: true
                                        },
                                        {
                                            name: `${appearance.embed.dot || appearance.emoji.Dot}Причина завершение:`,
                                            value: `\`\`\`Автоматически, отсутствует пользователя на сервере\`\`\``,  
                                            inline: true
                                        },
                                        {
                                            name: `${appearance.embed.dot || appearance.emoji.Dot}Мероприятие:`,
                                            value: `\`\`\`${eventOfCategory.name}\`\`\``,
                                            inline: false
                                        }
                                    ],
                                    footer: { text: `・Ведущий: ${member.displayName}` },
                                    thumbnail: { url: memberAvatar },
                                }
                            ],
                            components: [

                            ]
                        }).catch(() => {});

                        users[guilds[EventId].Owner].Events.unshift(
                            {
    
                                EventId: EventId,
                                Event: eventOfCategory,
                                Ended: Date.now () / 1000,
                                Created: guilds[EventId].Created,
    
                                message: {
    
                                    log: logMessage,
                                    announcement: guilds[EventId].message.announcement
    
                                }
                                
                            }
                        );


                        guilds[guild.id].Events.Active = guilds[guild.id].Events.Active.filter((n) => { return n != EventId });
                        users[member.id].ActiveEvent = false;

                        if (guilds[EventId].message.announcement) 
                        guilds[EventId].message.announcement.edit({
                            content: ' ',
                            components: [
                                {
                                    type: 1,
                                    components: [
                                        {
                                            type: 2, 
                                            style: 5, 
                                            label: 'Мероприятие окончено', 
                                            url: `https://discord.gg/BneyWRqe`,
                                            disabled: true 
                                        }
                                    ]
                                }
                            ]
                        }).catch(() => {});
                        return;

                    };
                    
                    if (!eventManageChannelFetch) {

                        guilds[EventId].deleted = true;
                        manageMessage.delete().catch(() => {});

                        let pick = 0;
                        let channelsEvent = [eventVoiceChannel, eventInfoChannel, eventManageChannel, eventCategory];
                        setInterval(async () => {

                            if (pick == channelsEvent.length) return;
                            channelsEvent[pick].delete().catch(() => {});
                            pick++;

                        }, 1000);


                        logMessage.edit({  
                            content: `<t:${Math.floor(Date.now()/1000)}:f>`,
                            embeds: [
                                {
                                    author: { name: 'Мероприятие завершено' },
                                    title: `${client.user.username + ' logs'}`,
                                    color: appearance.embed.color,
                                    description: `Создано: <t:${Math.floor(guilds[EventId].Created)}:f>\nЗавершено: <t:${Math.floor(Date.now()/1000)}:f>`,
                                    fields: [
                                        {
                                            name: `${appearance.embed.dot || appearance.emoji.Dot}Создавал:`,
                                            value: `・${member}\n・${member.id}`,  
                                            inline: true
                                        },
                                        {
                                            name: `${appearance.embed.dot || appearance.emoji.Dot}Причина завершение:`,
                                            value: `\`\`\`Автоматически, отсутствует канала управления\`\`\``,  
                                            inline: true
                                        },
                                        {
                                            name: `${appearance.embed.dot || appearance.emoji.Dot}Мероприятие:`,
                                            value: `\`\`\`${eventOfCategory.name}\`\`\``,
                                            inline: false
                                        }
                                    ],
                                    footer: { text: `・Ведущий: ${member.displayName}` },
                                    thumbnail: { url: memberAvatar },
                                }
                            ],
                            components: [

                            ]
                        }).catch(() => {});

                        users[guilds[EventId].Owner].Events.unshift(
                            {
    
                                EventId: EventId,
                                Event: eventOfCategory,
                                Ended: Date.now () / 1000,
                                Created: guilds[EventId].Created,
    
                                message: {
    
                                    log: logMessage,
                                    announcement: guilds[EventId].message.announcement
    
                                }
                                
                            }
                        );


                        guilds[guild.id].Events.Active = guilds[guild.id].Events.Active.filter((n) => { return n != EventId });
                        users[member.id].ActiveEvent = false;

                        if (guilds[EventId].message.announcement) 
                        guilds[EventId].message.announcement.edit({
                            content: ' ',
                            components: [
                                {
                                    type: 1,
                                    components: [
                                        {
                                            type: 2, 
                                            style: 5, 
                                            label: 'Мероприятие окончено', 
                                            url: `https://discord.gg/BneyWRqe`,
                                            disabled: true 
                                        }
                                    ]
                                }
                            ]
                        }).catch(() => {});
                        return;

                    };

                }, 2000);
                

                client.on('interactionCreate', async i => {
            
                    if (!i.isModalSubmit()) return;
            
                    if (!i.member || i.member.id !== member.id) return;
                    if (i.message.id !== manageMessage.id) return;
            
                    lastInt = Date.now() / 1000;
            
                    switch (i.customId) {  
                        
                        default: {
            
                            if (actions[i.customId] && actions[i.customId].all == false) return await actions[i.customId].actions[0](i);
            
                        }
            
                    };
            
                });

                const collectorConponentsOfEventManageChannel = await eventManageChannel.createMessageComponentCollector();
                collectorConponentsOfEventManageChannel.on('collect', async i => {
                    
                    const iMemberAvatar = await getAvatar(i.member);
                    const eventOwner = await guild.members.fetch(guilds[EventId].Owner).catch(() => {});

                    switch (i.customId) { 
            
                        case 'announcement': { 

                            if (guilds[EventId].Owner !== i.member.id) return i.reply(await errorNoEventsOwnerMessage (i.member));

                            manageMessage.components.forEach(component => {

                                let Comp = component.components;
                
                                for (c = 0; c < Comp.length; c++) {
                
                                    if (Comp[c].data.custom_id == 'announcement') Comp[c].data.disabled = true;
                
                                };
                                
                            });

                            await manageMessage.edit({ components: manageMessage.components });

                            const announcementChannels = await client.channels.fetch(appearance.channels.Announcement).catch(() => {});

                            i.reply({  
                                ephemeral: true,
                                embeds: [
                                    {
                                        title: `Управление: ${eventOfCategory.name}`,
                                        color: appearance.embed.color,
                                        description: `${i.member}, Вы **успешно** анонсировали **данное **мероприятие, сообщение **было отправлено** в ${announcementChannels}`,
                                        thumbnail: { url: iMemberAvatar }
                                    }
                                ],
                                components: [

                                ]
                            }).catch(() => {});


                            if (announcementChannels) {

                                const goToVoice = [
                                    {
                                        type: 1,
                                        components: [
                                            {
                                                type: 2, 
                                                label: 'Присоединиться к мероприятию', 
                                                url: `https://discord.com/channels/${eventVoiceChannel.guild.id}/${eventVoiceChannel.id}`,
                                                style: 5
                                            }
                                        ]
                                    }
                                ];

                                const announcementMessage = await announcementChannels.send(await announcementMessageSend (eventOfCategory.name, i.member, goToVoice));
                                parameters.announcementMessage = announcementMessage;
                                
                                guilds[EventId].message.announcement = announcementMessage;

                            };

                            break;

                        }

                        case 'limit': { 

                            if (guilds[EventId].Owner !== i.member.id) return i.reply(await errorNoEventsOwnerMessage (i.member));

                            const modal = new ModalBuilder().setCustomId('limitModal').setTitle('Изменить лимит пользователей');
                            const favoriteColorInput = new TextInputBuilder().setCustomId('limitModal').setLabel('Новый лимит пользователей').setStyle(TextInputStyle.Short).setMinLength(1).setMaxLength(2);
                            const firstActionRow = new ActionRowBuilder().addComponents(favoriteColorInput);
                            modal.addComponents(firstActionRow);
                            await i.showModal(modal);   

                            
                            const limitModal = (async (newI) => {
                
                                if (guilds[EventId].Owner !== newI.member.id) return newI.reply(await errorNoEventsOwnerMessage (newI.member));
                                const Limit = newI.fields.components[0].components[0].value;

                    
                                function checkingForNumber(value) {

                                    return  isFinite(value) && value === parseInt(value, 10);

                                };

                                const numberLimit = Number(Limit); 

                                if(checkingForNumber(numberLimit) !== true) 
                                return newI.reply({  
                                    ephemeral: true,
                                    embeds: [
                                        {
                                            title: `Управление: ${eventOfCategory.name}`,
                                            color: appearance.embed.color,
                                            description: `${newI.member}, Лимит должен быть **числом** от **0** до **99**`,
                                            thumbnail: { url: iMemberAvatar }
                                        }
                                    ],
                                    components: [

                                    ]
                                }).catch(() => {});
                    

                                eventVoiceChannel.setUserLimit(numberLimit).catch(() => {});

                                newI.reply({  
                                    ephemeral: true,
                                    embeds: [
                                        {
                                            title: `Управление: ${eventOfCategory.name}`,
                                            color: appearance.embed.color,
                                            description: `${newI.member}, Вы **успешно** изменили количество **слотов** в голосовом канале ${eventVoiceChannel} на **${numberLimit}**`,
                                            thumbnail: { url: iMemberAvatar }
                                        }
                                    ],
                                    components: [

                                    ]
                                }).catch(() => {});


                            });

                            actions['limitModal'] = {
                                actions: [limitModal],
                                all: false
                            };

                            break;

                        }
            
                        case 'block': { 

                            if (guilds[EventId].Owner !== i.member.id) return i.reply(await errorNoEventsOwnerMessage (i.member));

                            if (!eventVoiceChannel.permissionsFor(guild.id).has(PermissionsBitField.Flags.Connect)) {

                                eventVoiceChannel.permissionOverwrites.edit(guild.id, { Connect: true }).catch(() => {});
                                return i.reply({
                                    ephemeral: true,  
                                    embeds: [
                                        {
                                            title: `Управление: ${eventOfCategory.name}`,
                                            color: appearance.embed.color,
                                            description: `${i.member}, Вы **успешно** открыли ${eventVoiceChannel}, для того, чтобы его **закрыть**, нажмите на кнопку ${appearance.emoji.Block} **повторно**`,
                                            thumbnail: { url: iMemberAvatar }
                                        }
                                    ],
                                    components: [

                                    ]
                                });

                            } 
                
                            else {

                                eventVoiceChannel.permissionOverwrites.edit(guild.id, { Connect: false }).catch(() => {});
                                i.reply({
                                    ephemeral: true,  
                                    embeds: [
                                        {
                                            title: `Управление: ${eventOfCategory.name}`,
                                            color: appearance.embed.color,
                                            description: `${i.member}, Вы **успешно** закрыли ${eventVoiceChannel}, для того, чтобы его **закрыть**, нажмите на кнопку ${appearance.emoji.Block} **повторно**`,
                                            thumbnail: { url: iMemberAvatar }
                                        }
                                    ],
                                    components: [

                                    ]
                                });

                            };

                            break;

                        }

                        case 'ban': { 

                            if (guilds[EventId].Owner !== i.member.id) return i.reply(await errorNoEventsOwnerMessage (i.member));

                            i.reply({  
                                ephemeral: true,  
                                embeds: [
                                    {
                                        title: `Управление: ${eventOfCategory.name}`,
                                        color: appearance.embed.color,
                                        description: `${member}, выберите **пользователя**, у которого Вы **хотите** забрать/выдать **доступ** в команту ${eventVoiceChannel}`,
                                        thumbnail: { url: iMemberAvatar }
                                    }
                                ],
                                components: [

                                    menuUser ('pickMemberBan', '', '', true)

                                ]
                            }).catch(() => {});

                            
                            const pickMemberBan = (async (newI) => {

                                if (guilds[EventId].Owner !== newI.member.id) return newI.update(await errorNoEventsOwnerMessage (newI.member));
                
                                const pickMember = await guild.members.fetch(newI.values[0]).catch(() => {});

                                if (!eventVoiceChannel.permissionsFor(pickMember.id).has(PermissionsBitField.Flags.Connect)) {

                                    eventVoiceChannel.permissionOverwrites.edit(pickMember.id, { ViewChannel: true,  Connect: true }).catch(() => {});
                                    return newI.update({
                                        ephemeral: true,  
                                        embeds: [
                                            {
                                                title: `Управление: ${eventOfCategory.name}`,
                                                color: appearance.embed.color,
                                                description: `${newI.member}, Вы **успешно** выдали доступ **пользователю** ${pickMember} в голосовой канал ${eventVoiceChannel} `,
                                                thumbnail: { url: iMemberAvatar }
                                            }
                                        ],
                                        components: [

                                        ]
                                    });

                                } 
                    
                                else {

                                    eventVoiceChannel.permissionOverwrites.edit(pickMember.id, { ViewChannel: true,  Connect: false }).catch(() => {});
                                    newI.update({
                                        ephemeral: true,  
                                        embeds: [
                                            {
                                                title: `Управление: ${eventOfCategory.name}`,
                                                color: appearance.embed.color,
                                                description: `${newI.member}, Вы **успешно** забрали доступ у **пользователя** ${pickMember} в голосовой канал ${eventVoiceChannel} `,
                                                thumbnail: { url: iMemberAvatar }
                                            }
                                        ],
                                        components: [

                                        ]
                                    });

                                };

                                if(pickMember.voice.channelId == eventVoiceChannel.id) pickMember.voice.setChannel(null).catch(() => {}); 

                            });

                            actions['pickMemberBan'] = {
                                actions: [pickMemberBan],
                                all: false
                            };

                            break;

                        }

                        case 'mute': { 

                            if (guilds[EventId].Owner !== i.member.id) return i.reply(await errorNoEventsOwnerMessage (i.member));

                            i.reply({  
                                ephemeral: true,  
                                embeds: [
                                    {
                                        title: `Управление: ${eventOfCategory.name}`,
                                        color: appearance.embed.color,
                                        description: `${member}, выберите **пользователя**, у которого Вы **хотите** забрать/выдать **право говорить** в канале ${eventVoiceChannel}`,
                                        thumbnail: { url: iMemberAvatar }
                                    }
                                ],
                                components: [

                                    menuUser ('pickMemberMute', '', '', true)

                                ]
                            }).catch(() => {});

                            
                            const pickMemberMute = (async (newI) => {

                                if (guilds[EventId].Owner !== newI.member.id) return newI.update(await errorNoEventsOwnerMessage (newI.member));
                
                                const pickMember = await guild.members.fetch(newI.values[0]).catch(() => {});

                                if (!eventVoiceChannel.permissionsFor(pickMember.id).has(PermissionsBitField.Flags.Speak)) {

                                    eventVoiceChannel.permissionOverwrites.edit(pickMember.id, { Speak: true }).catch(() => {});
                                    return newI.update({
                                        ephemeral: true,  
                                        embeds: [
                                            {
                                                title: `Управление: ${eventOfCategory.name}`,
                                                color: appearance.embed.color,
                                                description: `${newI.member}, Вы **успешно** выдали право говорить **пользователю** ${pickMember} в голосовом канале ${eventVoiceChannel} `,
                                                thumbnail: { url: iMemberAvatar }
                                            }
                                        ],
                                        components: [

                                        ]
                                    });

                                } 
                    
                                else {

                                    eventVoiceChannel.permissionOverwrites.edit(pickMember.id, { Speak: false }).catch(() => {}); 
                                    newI.update({
                                        ephemeral: true,  
                                        embeds: [
                                            {
                                                title: `Управление: ${eventOfCategory.name}`,
                                                color: appearance.embed.color,
                                                description: `${newI.member}, Вы **успешно** забрали право говорить у **пользователя** ${pickMember} в голосовом канале ${eventVoiceChannel} `,
                                                thumbnail: { url: iMemberAvatar }
                                            }
                                        ],
                                        components: [

                                        ]
                                    });

                                };

                                if(pickMember.voice.channelId == eventVoiceChannel.id) pickMember.voice.setChannel(eventVoiceChannel.id).catch(() => {}); 

                            });

                            actions['pickMemberMute'] = {
                                actions: [pickMemberMute],
                                all: false
                            };

                            break;

                        }

                        case 'delete': { 

                            if (guilds[EventId].Owner !== i.member.id) return i.reply(await errorNoEventsOwnerMessage (i.member));

                            i.reply({  
                                ephemeral: true,  
                                embeds: [
                                    {
                                        title: `Управление: ${eventOfCategory.name}`,
                                        color: appearance.embed.color,
                                        description: `${i.member}, Вы **уверены** что хотите **завершить** мероприятие? Если **да**, тогда **нажмите** на кнопку под этим сообщением`,
                                        thumbnail: { url: iMemberAvatar }
                                    }
                                ],
                                components: [
                                    {
                                        type: 1,
                                        components: [
                                            {
                                                type: 2, 
                                                style: appearance.buttons_menu.Default.style,
                                                customId: 'yesDelete', 
                                                label: 'Завершить мероприятие'
                                            }
                                        ]
                                    }
                                ]
                            }).catch(() => {});

                            
                            const yesDelete = (async (newI) => {

                                if (guilds[EventId].deleted) return newI.update({components: []}).catch(() => {}); 

                                if (guilds[EventId].Owner !== newI.member.id) return newI.update(await errorNoEventsOwnerMessage (newI.member));
                
                                guilds[EventId].deleted = true;
                                newI.update({  
                                    ephemeral: true,  
                                    embeds: [],
                                    components: [
                                        {
                                            type: 1,
                                            components: [
                                                {
                                                    type: 2, 
                                                    style: appearance.buttons_menu.Default.style,
                                                    customId: 'yesDelete', 
                                                    label: 'Завершить мероприятие',
                                                    disabled: true
                                                }
                                            ]
                                        }
                                    ]
                                }).catch(() => {});

                                manageMessage.delete().catch(() => {});

                                
                                let pick = 0;
                                let channelsEvent = [eventVoiceChannel, eventInfoChannel, eventManageChannel, eventCategory];
                                    
                                eventVoiceChannel.members.forEach(member => {

                                    member.voice.setChannel(appearance.channels.Events.Discussion).catch(() => {});

                                });

                                let ti1 = setInterval(async () => {

                                    if (eventVoiceChannel && !eventVoiceChannel.members || eventVoiceChannel && !eventVoiceChannel.members.size) {

                                        if (pick == channelsEvent.length) return clearInterval(ti1);
                                        channelsEvent[pick].delete().catch(() => {});
                                        pick++;

                                    };

                                }, 1000);


                                logMessage.edit({  
                                    content: `<t:${Math.floor(Date.now()/1000)}:f>`,
                                    embeds: [
                                        {
                                            author: { name: 'Мероприятие завершено' },
                                            title: `${client.user.username + ' logs'}`,
                                            color: appearance.embed.color,
                                            description: `Создано: <t:${Math.floor(guilds[EventId].Created)}:f>\nЗавершено: <t:${Math.floor(Date.now()/1000)}:f>`,
                                            fields: [
                                                {
                                                    name: `${appearance.embed.dot || appearance.emoji.Dot}Завершил:`,
                                                    value: `・${member}\n・${member.id}`,  
                                                    inline: true
                                                },
                                                {
                                                    name: `${appearance.embed.dot || appearance.emoji.Dot}Мероприятие:`,
                                                    value: `\`\`\`${eventOfCategory.name}\`\`\``,
                                                    inline: true
                                                }
                                            ],
                                            footer: { text: `・Ведущий: ${member.displayName}` },
                                            thumbnail: { url: memberAvatar },
                                        }
                                    ],
                                    components: [

                                    ]
                                }).catch(() => {});


                                users[guilds[EventId].Owner].Events.unshift(
                                    {
            
                                        EventId: EventId,
                                        Ended: Date.now () / 1000,
                                        Created: guilds[EventId].Created,
            
                                        message: {
    
                                            log: logMessage,
                                            announcement: guilds[EventId].message.announcement
            
                                        }
                                        
                                    }
                                );

                                guilds[guild.id].Events.Active = guilds[guild.id].Events.Active.filter((n) => { return n != EventId });
                                users[member.id].ActiveEvent = false;

                                if (guilds[EventId].message.announcement) 
                                guilds[EventId].message.announcement.edit({
                                    content: ' ',
                                    components: [
                                        {
                                            type: 1,
                                            components: [
                                                {
                                                    type: 2, 
                                                    style: 5, 
                                                    label: 'Мероприятие окончено', 
                                                    url: `https://discord.gg/BneyWRqe`,
                                                    disabled: true 
                                                }
                                            ]
                                        }
                                    ]
                                }).catch(() => {});

                            });

                            actions['yesDelete'] = {
                                actions: [yesDelete],
                                all: false
                            };

                            break;

                        }

                        default: {
            
                            if (actions[i.customId] && actions[i.customId].all == false) await actions[i.customId].actions[0](i);
            
                            break;
            
                        }
                    
                    };

                });

            }

            else if (eventOfCategory.type == 'close') {
                
                const heightChannels = await guild.channels.fetch(appearance.channels.Closes.heightChannelCreate).catch(() => {});
                const Position = heightChannels.rawPosition ?? 0;

                const eventCategory = await guild.channels.create(
                    {
                        name: `${eventOfCategory.name}・${member.displayName}`,
                        type: ChannelType.GuildCategory,
                        position: Position
                    }
                ).catch(() => {});

                const eventManageChannel = await guild.channels.create(
                    {
                        name: `${appearance.custom.Events.channels.manage}`,
                        type: ChannelType.GuildText,
                        parent: eventCategory.id,
                        permissionOverwrites: [
                            {
                                id: guild.id,
                                deny: [PermissionsBitField.Flags.ViewChannel]
                            },
                            {
                                id: member.id,
                                allow: [PermissionsBitField.Flags.ViewChannel]
                            }
                        ]
                    }
                ).catch(() => {});


                if (reply) {

                    setTimeout(() => {
                        
                        i.editReply({
                            embeds: [
                                {
                                    title: `${client.user.username} create`,
                                    color: appearance.embed.color,
                                    description: `${member}, Вы **успешно** создали мероприятие **${eventOfCategory.name}**, для управления зайдите в ${eventManageChannel}`,
                                    thumbnail: { url: memberAvatar } 
                                }
                            ], 
                            components: [
                                
                            ]
                        }).catch(() => {});

                    }, 1000);

                }
                
                else 
                i.update({
                    embeds: [
                        {
                            title: `${client.user.username} create`,
                            color: appearance.embed.color,
                            description: `${member}, Вы **успешно** создали мероприятие **${eventOfCategory.name}**, для управления зайдите в ${eventManageChannel}`,
                            thumbnail: { url: memberAvatar } 
                        }
                    ], 
                    components: [
                        
                    ]
                }).catch(() => {});


                const eventRecordChannel = await guild.channels.create(
                    {
                        name: `${appearance.custom.Closes.channels.record}`,
                        type: ChannelType.GuildText,
                        parent: eventCategory.id,
                        permissionOverwrites: [
                            {
                                id: guild.id,
                                deny: [PermissionsBitField.Flags.ViewChannel, PermissionsBitField.Flags.SendMessages, PermissionsBitField.Flags.ManageChannels],
                                allow: [PermissionsBitField.Flags.ViewChannel]
                            }, 
                            {
                                id: member.id, 
                                allow: [PermissionsBitField.Flags.ViewChannel, PermissionsBitField.Flags.AttachFiles, PermissionsBitField.Flags.ManageMessages, PermissionsBitField.Flags.SendMessages]
                            }
                        ]
                    }
                ).catch(() => {});

                const eventVoiceChannel = await guild.channels.create(
                    {
                        name: `${eventOfCategory.channels.voice}`,
                        type: ChannelType.GuildVoice,
                        parent: eventCategory.id,
                        permissionOverwrites: [
                            {
                                id: guild.id,
                                deny: [PermissionsBitField.Flags.ViewChannel, PermissionsBitField.Flags.SendMessages, PermissionsBitField.Flags.Stream, PermissionsBitField.Flags.UseEmbeddedActivities, PermissionsBitField.Flags.ManageChannels],
                                allow: [PermissionsBitField.Flags.ViewChannel, PermissionsBitField.Flags.Connect]
                            }, 
                            {
                                id: member.id, 
                                allow: [PermissionsBitField.Flags.ViewChannel, PermissionsBitField.Flags.AttachFiles, PermissionsBitField.Flags.ManageEvents, PermissionsBitField.Flags.Connect, PermissionsBitField.Flags.MuteMembers, PermissionsBitField.Flags.MoveMembers, PermissionsBitField.Flags.Stream, PermissionsBitField.Flags.Stream, PermissionsBitField.Flags.UseEmbeddedActivities]
                            }
                        ]
                    }
                ).catch(() => {});

                const EventId = makeid(20);
                users[member.id].ActiveEvent = EventId;
                guilds[guild.id].Events.Active.push(EventId);

                const logsCloses = await guild.channels.fetch(appearance.channels.Closes.logs);

                const logMessage = await logsCloses.send({  
                    content: `<t:${Math.floor(Date.now()/1000)}:f>`,
                    embeds: [
                        {
                            author: { name: 'Мероприятие создано' },
                            title: `${client.user.username + ' logs'}`,
                            color: appearance.embed.color,
                            description: `Создано: <t:${Math.floor(Date.now()/1000)}:f>`,
                            fields: [
                                {
                                    name: `${appearance.embed.dot || appearance.emoji.Dot}Создал:`,
                                    value: `・${member}\n・${member.id}`,  
                                    inline: true
                                },
                                {
                                    name: `${appearance.embed.dot || appearance.emoji.Dot}Канал:`,
                                    value: `・${eventVoiceChannel}\n・${eventVoiceChannel.id}`,
                                    inline: true
                                },
                                {
                                    name: `${appearance.embed.dot || appearance.emoji.Dot}Мероприятие:`,
                                    value: `\`\`\`${eventOfCategory.name}\`\`\``,
                                    inline: false
                                }
                            ],
                            footer: { text: `・Ведущий: ${member.displayName}` },
                            thumbnail: { url: memberAvatar },
                        }
                    ],
                    components: [

                    ]
                }).catch(() => {});


                parameters.started = false;
                parameters.announcementMessage = false;


                const scheduledEvent = await guild.scheduledEvents.create({
                    name: `${eventOfCategory.name}`,
                    scheduledStartTime: new Date(Date.now() + 5 * 1000), 
                    scheduledEndTime: new Date(Date.now() + 24 * 60 * 60 * 1000),
                    privacyLevel: GuildScheduledEventPrivacyLevel.GuildOnly, 
                    entityType: GuildScheduledEventEntityType.Voice, 
                    channel: eventVoiceChannel.id, 
                    description: `${eventOfCategory.embed.info.description ? eventOfCategory.embed.info.description : 'Отсутствует'}`,
                    image: eventOfCategory.embed.info.image || null
                }).catch(() => {});

                scheduledEvent.setStatus(2).catch(() => {});
                
                
                parameters.teams = {};
                parameters.position = {};
                parameters.memberInEvent = [];
                let infoEmbedsFields = [];
                    

                async function updateRecordMessage () {
                    
                    let infoComponents = {

                        type: 1,
                        components: [

                        ]

                    };

                    infoEmbedsFields = [];
                    
                    if (parameters.typeRecord == 'positions') {
                        
                        for (const pickPosition in eventOfCategory.record.position.list) if (!parameters.position[pickPosition]) parameters.position[pickPosition] = [];

                        for (const pickPosition in eventOfCategory.record.position.list) {

                            let posMembers = '';

                            for (const pickMember in parameters.position[pickPosition]) {
                                
                                const fetchPickMember = await guild.members.fetch(parameters.position[pickPosition][pickMember]).catch(() => {});
                                if (!fetchPickMember) parameters.position[pickPosition] = parameters.position[pickPosition].filter((n) => { return n != pickMember });
                                if (!fetchPickMember) parameters.memberInEvent = parameters.memberInEvent.filter((n) => { return n != pickMember });
                                posMembers += `・${fetchPickMember}\n`;

                            };
                            

                            if (parameters.position[pickPosition][0]) {

                                infoEmbedsFields.push(
                                    {
                                        name: `${eventOfCategory.record.position.list[pickPosition].emoji} ${pickPosition}`,
                                        value: `${posMembers}`,
                                        inline: false
                                    }
                                );

                            };

                            infoComponents.components.push(
                                {
                                    type: 2, 
                                    style: appearance.buttons_menu.Default.style, 
                                    customId: pickPosition, 
                                    emoji: eventOfCategory.record.position.list[pickPosition].emoji
                                }
                            );

                        };

                    }

                    else if (parameters.typeRecord == 'teams') {

                        for (const pickTeam in eventOfCategory.record.teams.list) if (!parameters.teams[pickTeam]) parameters.teams[pickTeam] = [];
                        
                        for (const pickTeam in eventOfCategory.record.teams.list) {

                            let posMembers = '';

                            for (const pickMember in parameters.teams[pickTeam]) {
                                
                                const fetchPickMember = await guild.members.fetch(parameters.teams[pickTeam][pickMember]).catch(() => {});
                                if (!fetchPickMember) parameters.teams[pickTeam] = parameters.teams[pickTeam].filter((n) => { return n != pickMember });
                                if (!fetchPickMember) parameters.memberInEvent = parameters.memberInEvent.filter((n) => { return n != pickMember });
                                posMembers += `・${fetchPickMember}\n`;

                            };
                            

                            if (parameters.teams[pickTeam][0]) {

                                infoEmbedsFields.push(
                                    {
                                        name: `${eventOfCategory.record.teams.list[pickTeam].emoji} ${pickTeam}`,
                                        value: `${posMembers}`,
                                        inline: false
                                    }
                                );

                            };

                            infoComponents.components.push(
                                {
                                    type: 2, 
                                    style: appearance.buttons_menu.Default.style, 
                                    customId: pickTeam, 
                                    emoji: eventOfCategory.record.teams.list[pickTeam].emoji
                                }
                            );

                        };

                    }

                    else if (parameters.typeRecord == 'random') {

                        let posMembers = '';

                        for (const pickMember in parameters.memberInEvent) {
                            
                            const fetchPickMember = await guild.members.fetch(parameters.memberInEvent[pickMember]).catch(() => {});
                            if (!fetchPickMember) parameters.memberInEvent = parameters.memberInEvent.filter((n) => { return n != pickMember });
                            posMembers += `・${fetchPickMember}\n`;

                        };
                        

                        if (parameters.memberInEvent[0]) {

                            infoEmbedsFields.push(
                                {
                                    name: `${appearance.emoji.Participants} Записавшиеся:`,
                                    value: `${posMembers}`,
                                    inline: false
                                }
                            );

                        };

                        infoComponents.components.push(
                            {
                                type: 2, 
                                style: 1, 
                                customId: 'record', 
                                label: 'Записаться на игру'
                            }
                        );
                        
                    };

                    return {  
                        embeds: [
                            {
                                title: `Мероприятие: ${eventOfCategory.name}`,
                                color: appearance.embed.color,
                                description: `Игроков: **${parameters.memberInEvent.length}** из **${eventOfCategory.record.maxMembers}**\nНеобходимо еще игроков: **${eventOfCategory.record.minMembers - parameters.memberInEvent.length < 0 ? 0 : eventOfCategory.record.minMembers - parameters.memberInEvent.length }**`,
                                footer: { text: `・Ведущий: ${member.displayName}`, icon_url: memberAvatar },
                                fields: infoEmbedsFields
                            }
                        ],
                        components: [
                            infoComponents
                        ]
                    };

                };


                let optionsType = [];
                parameters.typeRecord = false;
                for (const pickType in eventOfCategory.record.type) {

                    if (eventOfCategory.record.type[pickType].pick) parameters.typeRecord = eventOfCategory.record.type[pickType].type;

                    optionsType.push(
                        {
                            label: `${eventOfCategory.record.type[pickType].name}`, 
                            value: `${eventOfCategory.record.type[pickType].type}`, 
                            emoji: eventOfCategory.record.type[pickType].emoji,
                            default: parameters.typeRecord == eventOfCategory.record.type[pickType].type
                        }
                    );

                };


                const teamButton = (async (newI) => {

                    const newIMemberAvatar = await getAvatar(newI.member);

                    if (parameters.teams[newI.customId].includes(newI.member.id)) {

                        parameters.memberInEvent = parameters.memberInEvent.filter((n) => { return n != newI.member.id });
                        parameters.teams[newI.customId] = parameters.teams[newI.customId].filter((n) => { return n != newI.member.id });

                        await recordMessage.edit(await updateRecordMessage ());

                        newI.reply({
                            ephemeral: true,  
                            embeds: [
                                {
                                    title: `Мероприятие: ${eventOfCategory.name}`,
                                    color: appearance.embed.color,
                                    description: `${newI.member}, Вы **успешно** выписались из данного мероприятия`,
                                    thumbnail: { url: newIMemberAvatar }
                                }
                            ],
                            components: [

                            ]
                        });


                        const goToVoice = [
                            {
                                type: 1,
                                components: [
                                    {
                                        type: 2, 
                                        label: 'Записаться на мероприятие', 
                                        url: `https://discord.com/channels/${eventRecordChannel.guild.id}/${eventRecordChannel.id}`,
                                        style: 5
                                    }
                                ]
                            }
                        ];

                        const eventOwner = await guild.members.fetch(guilds[EventId].Owner).catch(() => {});
                        if (parameters.announcementMessage) parameters.announcementMessage.edit(await announcementMessageSend (eventOfCategory.name, eventOwner, goToVoice, `${parameters.memberInEvent.length} из ${eventOfCategory.record.maxMembers}`));

                        return;
                        
                    };                           
                    
                    if (parameters.memberInEvent.length == eventOfCategory.record.maxMembers) 
                    return newI.reply({
                        ephemeral: true,  
                        embeds: [
                            {
                                title: `${client.user.username} error`,
                                color: appearance.embed.errorColor,
                                description: `${newI.member}, Вы **не можете** записаться на мероприятие, **максимально** кол-во участников **уже** записано`,
                                thumbnail: { url: newIMemberAvatar }
                            }
                        ],
                        components: [

                        ]
                    });

                    if (parameters.teams[newI.customId].length == eventOfCategory.record.teams.list[newI.customId].maxMembers) 
                    return newI.reply({
                        ephemeral: true,  
                        embeds: [
                            {
                                title: `Мероприятие: ${eventOfCategory.name}`,
                                color: appearance.embed.errorColor,
                                description: `${newI.member}, Вы **не можете** записаться на данную позицию, **максимально** кол-во участников **уже** записано`,
                                thumbnail: { url: newIMemberAvatar }
                            }
                        ],
                        components: [

                        ]
                    });


                    if(newI.member._roles.includes(appearance.roles.Closes.ban))
                    return newI.reply({
                        ephemeral: true,  
                        embeds: [
                            {
                                title: `${client.user.username} error`,
                                color: appearance.embed.errorColor,
                                description: `${newI.member}, Вы **не можете** записаться на мероприятие, у Вас **есть** роль запрета <@&${appearance.roles.Closes.ban}>`,
                                thumbnail: { url: newIMemberAvatar }
                            }
                        ],
                        components: [

                        ]
                    });


                    parameters.memberInEvent = parameters.memberInEvent.filter((n) => { return n != newI.member.id });
                    for (const teams in parameters.teams) parameters.teams[teams] = parameters.teams[teams].filter((n) => { return n != newI.member.id });
                    parameters.teams[newI.customId].push(newI.member.id);
                    parameters.memberInEvent.push(newI.member.id);

                    newI.reply({
                        ephemeral: true,  
                        embeds: [
                            {
                                title: `Мероприятие: ${eventOfCategory.name}`,
                                color: appearance.embed.color,
                                description: `${newI.member}, Вы **успешно** записаны на мероприятие и выбрали команду **${eventOfCategory.record.teams.list[newI.customId].emoji} ${newI.customId}**`,
                                thumbnail: { url: newIMemberAvatar }
                            }
                        ],
                        components: [

                        ]
                    });


                    const goToVoice = [
                        {
                            type: 1,
                            components: [
                                {
                                    type: 2, 
                                    label: 'Записаться на мероприятие', 
                                    url: `https://discord.com/channels/${eventRecordChannel.guild.id}/${eventRecordChannel.id}`,
                                    style: 5
                                }
                            ]
                        }
                    ];

                    const eventOwner = await guild.members.fetch(guilds[EventId].Owner).catch(() => {});
                    if (parameters.announcementMessage) parameters.announcementMessage.edit(await announcementMessageSend (eventOfCategory.name, eventOwner, goToVoice, `${parameters.memberInEvent.length} из ${eventOfCategory.record.maxMembers}`));

                    return await recordMessage.edit(await updateRecordMessage ());

                });

                const positionButton = (async (newI) => {

                    const newIMemberAvatar = await getAvatar(newI.member);

                    if (parameters.position[newI.customId].includes(newI.member.id)) {

                        parameters.memberInEvent = parameters.memberInEvent.filter((n) => { return n != newI.member.id });
                        parameters.position[newI.customId] = parameters.position[newI.customId].filter((n) => { return n != newI.member.id });

                        await recordMessage.edit(await updateRecordMessage ());

                        newI.reply({
                            ephemeral: true,  
                            embeds: [
                                {
                                    title: `Мероприятие: ${eventOfCategory.name}`,
                                    color: appearance.embed.color,
                                    description: `${newI.member}, Вы **успешно** выписались из данного мероприятия`,
                                    thumbnail: { url: newIMemberAvatar }
                                }
                            ],
                            components: [

                            ]
                        });


                        const goToVoice = [
                            {
                                type: 1,
                                components: [
                                    {
                                        type: 2, 
                                        label: 'Записаться на мероприятие', 
                                        url: `https://discord.com/channels/${eventRecordChannel.guild.id}/${eventRecordChannel.id}`,
                                        style: 5
                                    }
                                ]
                            }
                        ];

                        const eventOwner = await guild.members.fetch(guilds[EventId].Owner).catch(() => {});
                        if (parameters.announcementMessage) parameters.announcementMessage.edit(await announcementMessageSend (eventOfCategory.name, eventOwner, goToVoice, `${parameters.memberInEvent.length} из ${eventOfCategory.record.maxMembers}`));

                        return;
                        
                    };                           
                    
                    if (parameters.memberInEvent.length == eventOfCategory.record.maxMembers) 
                    return newI.reply({
                        ephemeral: true,  
                        embeds: [
                            {
                                title: `${client.user.username} error`,
                                color: appearance.embed.errorColor,
                                description: `${newI.member}, Вы **не можете** записаться на мероприятие, **максимально** кол-во участников **уже** записано`,
                                thumbnail: { url: newIMemberAvatar }
                            }
                        ],
                        components: [

                        ]
                    });

                    if (parameters.position[newI.customId].length == eventOfCategory.record.position.list[newI.customId].maxMembers) 
                    return newI.reply({
                        ephemeral: true,  
                        embeds: [
                            {
                                title: `Мероприятие: ${eventOfCategory.name}`,
                                color: appearance.embed.errorColor,
                                description: `${newI.member}, Вы **не можете** записаться на данную позицию, **максимально** кол-во участников **уже** записано`,
                                thumbnail: { url: newIMemberAvatar }
                            }
                        ],
                        components: [

                        ]
                    });


                    if(newI.member._roles.includes(appearance.roles.Closes.ban))
                    return newI.reply({
                        ephemeral: true,  
                        embeds: [
                            {
                                title: `${client.user.username} error`,
                                color: appearance.embed.errorColor,
                                description: `${newI.member}, Вы **не можете** записаться на мероприятие, у Вас **есть** роль запрета <@&${appearance.roles.Closes.ban}>`,
                                thumbnail: { url: newIMemberAvatar }
                            }
                        ],
                        components: [

                        ]
                    });


                    parameters.memberInEvent = parameters.memberInEvent.filter((n) => { return n != newI.member.id });
                    for (const position in parameters.position) parameters.position[position] = parameters.position[position].filter((n) => { return n != newI.member.id });
                    parameters.position[newI.customId].push(newI.member.id);
                    parameters.memberInEvent.push(newI.member.id);

                    newI.reply({
                        ephemeral: true,  
                        embeds: [
                            {
                                title: `Мероприятие: ${eventOfCategory.name}`,
                                color: appearance.embed.color,
                                description: `${newI.member}, Вы **успешно** записаны на мероприятие и выбрали позицию **${eventOfCategory.record.position.list[newI.customId].emoji} ${newI.customId}**`,
                                thumbnail: { url: newIMemberAvatar }
                            }
                        ],
                        components: [

                        ]
                    });


                    const goToVoice = [
                        {
                            type: 1,
                            components: [
                                {
                                    type: 2, 
                                    label: 'Записаться на мероприятие', 
                                    url: `https://discord.com/channels/${eventRecordChannel.guild.id}/${eventRecordChannel.id}`,
                                    style: 5
                                }
                            ]
                        }
                    ];

                    const eventOwner = await guild.members.fetch(guilds[EventId].Owner).catch(() => {});
                    if (parameters.announcementMessage) parameters.announcementMessage.edit(await announcementMessageSend (eventOfCategory.name, eventOwner, goToVoice, `${parameters.memberInEvent.length} из ${eventOfCategory.record.maxMembers}`));
                    return await recordMessage.edit(await updateRecordMessage ());

                });

                const recordButton = (async (newI) => {

                    const newIMemberAvatar = await getAvatar(newI.member);

                    if (parameters.memberInEvent.includes(newI.member.id)) {

                        parameters.memberInEvent = parameters.memberInEvent.filter((n) => { return n != newI.member.id });

                        await recordMessage.edit(await updateRecordMessage ());

                        newI.reply({
                            ephemeral: true,  
                            embeds: [
                                {
                                    title: `Мероприятие: ${eventOfCategory.name}`,
                                    color: appearance.embed.color,
                                    description: `${newI.member}, Вы **успешно** выписались из данного мероприятия`,
                                    thumbnail: { url: newIMemberAvatar }
                                }
                            ],
                            components: [

                            ]
                        });


                        const goToVoice = [
                            {
                                type: 1,
                                components: [
                                    {
                                        type: 2, 
                                        label: 'Записаться на мероприятие', 
                                        url: `https://discord.com/channels/${eventRecordChannel.guild.id}/${eventRecordChannel.id}`,
                                        style: 5
                                    }
                                ]
                            }
                        ];

                        const eventOwner = await guild.members.fetch(guilds[EventId].Owner).catch(() => {});
                        if (parameters.announcementMessage) parameters.announcementMessage.edit(await announcementMessageSend (eventOfCategory.name, eventOwner, goToVoice, `${parameters.memberInEvent.length} из ${eventOfCategory.record.maxMembers}`));

                        return;
                        
                    };   

                    if (parameters.memberInEvent.length == eventOfCategory.record.maxMembers) 
                    return newI.reply({
                        ephemeral: true,  
                        embeds: [
                            {
                                title: `${client.user.username} error`,
                                color: appearance.embed.errorColor,
                                description: `${newI.member}, Вы **не можете** записаться на мероприятие, **максимально** кол-во участников **уже** записано`,
                                thumbnail: { url: newIMemberAvatar }
                            }
                        ],
                        components: [

                        ]
                    });


                    if(newI.member._roles.includes(appearance.roles.Closes.ban))
                    return newI.reply({
                        ephemeral: true,  
                        embeds: [
                            {
                                title: `${client.user.username} error`,
                                color: appearance.embed.errorColor,
                                description: `${newI.member}, Вы **не можете** записаться на мероприятие, у Вас **есть** роль запрета <@&${appearance.roles.Closes.ban}>`,
                                thumbnail: { url: newIMemberAvatar }
                            }
                        ],
                        components: [

                        ]
                    });


                    parameters.memberInEvent = parameters.memberInEvent.filter((n) => { return n != newI.member.id });
                    parameters.memberInEvent.push(newI.member.id);

                    newI.reply({
                        ephemeral: true,  
                        embeds: [
                            {
                                title: `Мероприятие: ${eventOfCategory.name}`,
                                color: appearance.embed.color,
                                description: `${newI.member}, Вы **успешно** записаны на мероприятие`,
                                thumbnail: { url: newIMemberAvatar }
                            }
                        ],
                        components: [

                        ]
                    });


                    const goToVoice = [
                        {
                            type: 1,
                            components: [
                                {
                                    type: 2, 
                                    label: 'Записаться на мероприятие', 
                                    url: `https://discord.com/channels/${eventRecordChannel.guild.id}/${eventRecordChannel.id}`,
                                    style: 5
                                }
                            ]
                        }
                    ];

                    const eventOwner = await guild.members.fetch(guilds[EventId].Owner).catch(() => {});
                    if (parameters.announcementMessage) parameters.announcementMessage.edit(await announcementMessageSend (eventOfCategory.name, eventOwner, goToVoice, `${parameters.memberInEvent.length} из ${eventOfCategory.record.maxMembers}`));
                    return await recordMessage.edit(await updateRecordMessage ());

                });

                if (parameters.typeRecord == 'positions') {
                    
                    for (const pickPosition in eventOfCategory.record.position.list) {

                        actions[pickPosition] = {
                            actions: [positionButton],
                            all: false
                        };

                    };

                }

                else if (parameters.typeRecord == 'teams') {
                    
                    for (const pickTeam in eventOfCategory.record.teams.list) {

                        actions[pickTeam] = {
                            actions: [teamButton],
                            all: false
                        };

                    };
                
                }

                else if (parameters.typeRecord == 'random') {

                    actions['record'] = {
                        actions: [recordButton],
                        all: false
                    };
                    
                };

                
                const recordMessage = await eventRecordChannel.send(await updateRecordMessage ()).catch(() => {});
                
                recordMessage.startThread({ name: appearance.custom.Closes.default.notes }).catch(() => {});
                recordMessage.pin().catch(() => {});


                const chRecordInt = setInterval(async () => {

                    if (parameters.deleted || parameters.started) clearInterval(chRecordInt);

                    for (const pickMember in parameters.memberInEvent) {
                        
                        const fetchPickMember = await guild.members.fetch(parameters.memberInEvent[pickMember]).catch(() => {});
                        if (!fetchPickMember) {

                            parameters.memberInEvent = parameters.memberInEvent.filter((n) => { return n != fetchPickMember.id });
                            for (const position in parameters.position) parameters.position[position] = parameters.position[position].filter((n) => { return n != fetchPickMember.id });
                            await recordMessage.edit(await updateRecordMessage ());

                        };
                        
                        if(fetchPickMember._roles.includes(appearance.roles.Closes.ban)) {

                            parameters.memberInEvent = parameters.memberInEvent.filter((n) => { return n != fetchPickMember.id });
                            for (const position in parameters.position) parameters.position[position] = parameters.position[position].filter((n) => { return n != fetchPickMember.id });
                            await recordMessage.edit(await updateRecordMessage ());
                            
                        };

                    };

                }, 2000);


                let additionInformationOrCommand = '';
                const commands = await client.application.commands.fetch().catch(() => {});

                commands.forEach(command => {
                    if (command.name == 'event') {
                        additionInformationOrCommand += `\n-# ~~</event reward:${command.id}> — Награды выдаются автоматически~~\n</event transfer:${command.id}> — Передать мероприятие\n-# </event delete:${command.id}> — (Резервное) удаление мероприятия`
                    };
                });

                let manageMessage = await eventManageChannel.send({  
                    embeds: [
                        {
                            title: `Управление: ${eventOfCategory.name}`,
                            color: appearance.embed.color,
                            fields: additionInformationOrCommand ?
                            [
                                {
                                    name: 'Кнопки:',
                                    value: `${appearance.emoji.Announcement} — Анонсировать в <#${appearance.channels.Announcement}>\n${appearance.emoji.Start} — **Начать** данное мероприятие\n${appearance.emoji.UserBlock} — Удалить пользователя из списка участников\n${appearance.emoji.Delete} — Досрочно **завершить** данное мероприятие`,
                                    inline: false
                                },
                                {
                                    name: 'Команды:',
                                    value: `${additionInformationOrCommand}`,
                                    inline: false
                                }
                            ]
                            :
                            [
                                {
                                    name: 'Кнопки:',
                                    value: `${appearance.emoji.Announcement} — Анонсировать в <#${appearance.channels.Announcement}>\n${appearance.emoji.Start} — **Начать** данное мероприятие\n${appearance.emoji.UserBlock} — Удалить пользователя из списка участников\n${appearance.emoji.Delete} — Досрочно **завершить** данное мероприятие`,
                                    inline: false
                                }
                            ]
                        }
                    ],
                    components: [
                        {
                            type: 1,
                            components: [
                                {
                                    type: 3,
                                    customId: 'selectType', 
                                    placeholder: 'Выберите режим записи', 
                                    minValues: 1, 
                                    maxValues: 1, 
                                    options: optionsType
                                }
                            ]
                        },
                        {
                            type: 1,
                            components: [
                                {
                                    type: 2, 
                                    style: appearance.buttons_menu.Default.style, 
                                    customId: 'announcement', 
                                    emoji: appearance.emoji.Announcement
                                },
                                {
                                    type: 2, 
                                    style: appearance.buttons_menu.Default.style, 
                                    customId: 'start', 
                                    emoji: appearance.emoji.Start
                                },
                                {
                                    type: 2, 
                                    style: appearance.buttons_menu.Default.style, 
                                    customId: 'kick', 
                                    emoji: appearance.emoji.UserBlock
                                },
                                {
                                    type: 2, 
                                    style: appearance.buttons_menu.Default.style, 
                                    customId: 'delete', 
                                    emoji: appearance.emoji.Delete
                                }
                            ]
                        }
                    ]
                }).catch(() => {});

                
                guilds[EventId] = {

                    type: 'close',
                    started: false,
                    deleted: false,

                    channels: {

                        category: eventCategory.id,
                        manage: eventManageChannel.id,
                        record: eventRecordChannel.id,
                        voice: eventVoiceChannel.id

                    },

                    ManageLink: `https://discord.com/channels/${guild.id}/${eventManageChannel.id}`,
                    Owner: member.id,
                    Created: Date.now () / 1000,
                    Event: eventOfCategory,
                    Online: [],

                    message: {

                        record: recordMessage,
                        manage: manageMessage,
                        log: logMessage,
                        announcement: false

                    }

                };

                guilds[eventVoiceChannel.id] = {

                    id: EventId

                };
                

                const collectorConponentsOfRecordMessage = await recordMessage.createMessageComponentCollector();
                collectorConponentsOfRecordMessage.on('collect', async i => {

                    switch (i.customId) { 

                        case 'info': {

                            let posDesc = '';
                            if (parameters.typeRecord == 'positions') {

                                for (const pickPosition in eventOfCategory.record.position.list) {
    
                                    posDesc += `**${eventOfCategory.record.position.list[pickPosition].emoji} ${pickPosition}**\n・${eventOfCategory.record.position.list[pickPosition].description || 'Остутствует'}\n\n`;
        
                                };

                            };


                            i.reply({
                                ephemeral: true,  
                                embeds: [
                                    {
                                        title: `Информация: ${eventOfCategory.name}`,
                                        color: appearance.embed.color,
                                        description: `${appearance.emoji.Info} ${eventOfCategory.embed.info.description ? eventOfCategory.embed.info.description : 'Отсутствует'}\n\n${posDesc}`,
                                    }
                                ],
                                components: [

                                ]
                            });

                            break;

                        }

                        default: {
            
                            if (actions[i.customId] && actions[i.customId].all == false) await actions[i.customId].actions[0](i);
            
                            break;
            
                        }
                    
                    };

                });


                async function announcementMessageSend (One, Two, Three, Four) {

                    const eventOwnerAvatar = await getAvatar(Two);

                    let fields = [
                        {
                            name: 'Игроки',
                            value: Four,
                            inline: true
                        }
                    ];

                    for (const pickReward in eventOfCategory.rewards) {

                        fields.push(
                            {
                                name: `${pickReward}`,
                                value: `${eventOfCategory.rewards[pickReward].reward} ${appearance.emoji.Coin}`,
                                inline: true
                            }
                        );

                    };

                    if (!fields[0]) {

                        fields.push(
                            {
                                name: `Награды за мероприятие`,
                                value: 'Отсутствуют',
                                inline: true
                            }
                        );

                    };

                    let contentPingRoles = '';
                    for (let role in appearance.roles.Closes.notification) {

                        const roleFetch = await guild.roles.fetch(appearance.roles.Closes.notification[role]).catch(() => {});
                        if (roleFetch && contentPingRoles == '') contentPingRoles += `${roleFetch}`;
                        else if (roleFetch && contentPingRoles !== '') contentPingRoles += `, ${roleFetch}`;

                    };
                    
                    return {

                        content: contentPingRoles == '' ? ' ' : contentPingRoles,
                        embeds: [
                            {
                                title: `Мероприятие: ${One}`,
                                color: appearance.embed.color,
                                description: `\`\`\`${eventOfCategory.miniDescription ? eventOfCategory.miniDescription : 'Отсутствует'}\`\`\``,
                                fields: fields,
                                image: { url: eventOfCategory.embed.info.image || appearance.custom.Events.default.nullImage },
                                footer: { text: `・Ведущий: ${Two.displayName}`, icon_url: eventOwnerAvatar }
                            }
                        ], 
                        components: Three

                    };

                };
                
                async function errorNoEventsOwnerMessage (One) {

                    const pickMemberAvater = await getAvatar(One);

                    return {
                        ephemeral: true,
                        embeds: [
                            {
                                title: `${client.user.username} error`,
                                color: appearance.embed.errorColor,
                                description: `${One}, для того, чтобы **использовать** данную кнопку, Вам **необходимо** быть ведущим** данного** мероприятия`,
                                thumbnail: { url: pickMemberAvater }
                            }
                        ], 
                        components: [
                            
                        ]
                    };

                };
                

                client.on('interactionCreate', async i => {
            
                    if (!i.isModalSubmit()) return;
            
                    if (!i.member || i.member.id !== member.id) return;
                    if (i.message.id !== manageMessage.id) return;
            
                    lastInt = Date.now() / 1000;
            
                    switch (i.customId) {  
                        
                        default: {
            
                            if (actions[i.customId] && actions[i.customId].all == false) return await actions[i.customId].actions[0](i);
            
                        }
            
                    };
            
                });

                const collectorConponentsOfEventManageChannel = await eventManageChannel.createMessageComponentCollector();
                collectorConponentsOfEventManageChannel.on('collect', async i => {
                    
                    const iMemberAvatar = await getAvatar(i.member);
                    const eventOwner = await guild.members.fetch(guilds[EventId].Owner).catch(() => {});

                    switch (i.customId) { 

                        case 'selectType': {
                            
                            if (guilds[EventId].Owner !== i.member.id) return i.reply(await errorNoEventsOwnerMessage (i.member));

                            parameters.teams = {};
                            parameters.position = {};
                            parameters.memberInEvent = [];
                            let old = parameters.typeRecord;
                            parameters.typeRecord = i.values[0];

                            if (parameters.typeRecord == 'positions') {
                                
                                for (const pickPosition in eventOfCategory.record.position.list) {
    
                                    actions[pickPosition] = {
                                        actions: [positionButton],
                                        all: false
                                    };
        
                                };
    
                            }
    
                            else if (parameters.typeRecord == 'teams') {
                                
                                for (const pickTeam in eventOfCategory.record.teams.list) {
    
                                    actions[pickTeam] = {
                                        actions: [teamButton],
                                        all: false
                                    };
        
                                };
                            
                            }
    
                            else if (parameters.typeRecord == 'random') {
    
                                actions['record'] = {
                                    actions: [recordButton],
                                    all: false
                                };
                                
                            };

                            optionsType = [];
                            for (const pickType in eventOfCategory.record.type) {
    
                                optionsType.push(
                                    {
                                        label: `${eventOfCategory.record.type[pickType].name}`, 
                                        value: `${eventOfCategory.record.type[pickType].type}`, 
                                        emoji: eventOfCategory.record.type[pickType].emoji,
                                        default: parameters.typeRecord == eventOfCategory.record.type[pickType].type
                                    }
                                );
    
                            };
        
                            manageMessage.edit({  
                                components: [
                                    {
                                        type: 1,
                                        components: [
                                            {
                                                type: 3,
                                                customId: 'selectType', 
                                                placeholder: 'Выберите режим записи', 
                                                minValues: 1, 
                                                maxValues: 1, 
                                                options: optionsType
                                            }
                                        ]
                                    },
                                    {
                                        type: 1,
                                        components: [
                                            {
                                                type: 2, 
                                                style: appearance.buttons_menu.Default.style, 
                                                customId: 'announcement', 
                                                emoji: appearance.emoji.Announcement,
                                                disabled: parameters.announcement
                                            },
                                            {
                                                type: 2, 
                                                style: appearance.buttons_menu.Default.style, 
                                                customId: 'start', 
                                                emoji: appearance.emoji.Start
                                            },
                                            {
                                                type: 2, 
                                                style: appearance.buttons_menu.Default.style, 
                                                customId: 'kick', 
                                                emoji: appearance.emoji.UserBlock
                                            },
                                            {
                                                type: 2, 
                                                style: appearance.buttons_menu.Default.style, 
                                                customId: 'delete', 
                                                emoji: appearance.emoji.Delete
                                            }
                                        ]
                                    }
                                ]
                            }).catch(() => {});
    
                            i.reply({  
                                ephemeral: true,  
                                embeds: [
                                    {
                                        title: `Управление: ${eventOfCategory.name}`,
                                        color: appearance.embed.color,
                                        description: `${member}, Вы успешно **изменили** режим записи на мероприятие с **${eventOfCategory.record.type.find(type => type.type == old).name}** на **${eventOfCategory.record.type.find(type => type.type == parameters.typeRecord).name}**`,
                                        thumbnail: { url: iMemberAvatar }
                                    }
                                ]
                            }).catch(() => {});

                            await recordMessage.edit(await updateRecordMessage ());

                            break;

                        }
            
                        case 'announcement': { 

                            if (guilds[EventId].Owner !== i.member.id) return i.reply(await errorNoEventsOwnerMessage (i.member));

                            parameters.announcement = true;
                            manageMessage.components.forEach(component => {

                                let Comp = component.components;
                
                                for (c = 0; c < Comp.length; c++) {
                
                                    if (Comp[c].data.custom_id == 'announcement') Comp[c].data.disabled = true;
                
                                };
                                
                            });

                            await manageMessage.edit({ components: manageMessage.components });

                            const announcementChannels = await client.channels.fetch(appearance.channels.Announcement).catch(() => {});

                            i.reply({  
                                ephemeral: true,
                                embeds: [
                                    {
                                        title: `Управление: ${eventOfCategory.name}`,
                                        color: appearance.embed.color,
                                        description: `${i.member}, Вы **успешно** анонсировали **данное **мероприятие, сообщение **было отправлено** в ${announcementChannels}`,
                                        thumbnail: { url: iMemberAvatar }
                                    }
                                ],
                                components: [

                                ]
                            }).catch(() => {});

        
                            const goToVoice = [
                                {
                                    type: 1,
                                    components: [
                                        {
                                            type: 2, 
                                            label: 'Записаться на мероприятие', 
                                            url: `https://discord.com/channels/${eventRecordChannel.guild.id}/${eventRecordChannel.id}`,
                                            style: 5
                                        }
                                    ]
                                }
                            ];

                            if (announcementChannels) {

                                const announcementMessage = await announcementChannels.send(await announcementMessageSend (eventOfCategory.name, i.member, goToVoice, `${parameters.memberInEvent.length} из ${eventOfCategory.record.maxMembers}`));
                                parameters.announcementMessage = announcementMessage;
                                
                                guilds[EventId].message.announcement = announcementMessage;

                            };

                            break;

                        }
            
                        case 'block': { 

                            if (guilds[EventId].Owner !== i.member.id) return i.reply(await errorNoEventsOwnerMessage (i.member));

                            if (!eventVoiceChannel.permissionsFor(guild.id).has(PermissionsBitField.Flags.Connect)) {

                                eventVoiceChannel.permissionOverwrites.edit(guild.id, { ViewChannel: true,  Connect: true }).catch(() => {});
                                return i.reply({
                                    ephemeral: true,  
                                    embeds: [
                                        {
                                            title: `Управление: ${eventOfCategory.name}`,
                                            color: appearance.embed.color,
                                            description: `${i.member}, Вы **успешно** открыли ${eventVoiceChannel}, для того, чтобы его **закрыть**, нажмите на кнопку ${appearance.emoji.Block} **повторно**`,
                                            thumbnail: { url: iMemberAvatar }
                                        }
                                    ],
                                    components: [

                                    ]
                                });

                            } 
                
                            else {

                                eventVoiceChannel.permissionOverwrites.edit(guild.id, { ViewChannel: true,  Connect: false }).catch(() => {});
                                i.reply({
                                    ephemeral: true,  
                                    embeds: [
                                        {
                                            title: `Управление: ${eventOfCategory.name}`,
                                            color: appearance.embed.color,
                                            description: `${i.member}, Вы **успешно** закрылы ${eventVoiceChannel}, для того, чтобы его **закрыть**, нажмите на кнопку ${appearance.emoji.Block} **повторно**`,
                                            thumbnail: { url: iMemberAvatar }
                                        }
                                    ],
                                    components: [

                                    ]
                                });

                            };

                            break;

                        }

                        case 'kick': { 

                            if (guilds[EventId].Owner !== i.member.id) return i.reply(await errorNoEventsOwnerMessage (i.member));

                            i.reply({  
                                ephemeral: true,  
                                embeds: [
                                    {
                                        title: `Управление: ${eventOfCategory.name}`,
                                        color: appearance.embed.color,
                                        description: `${member}, выберите **пользователя**, у которого Вы **хотите** удалить из записи мероприятия **${eventOfCategory.name}**`,
                                        thumbnail: { url: iMemberAvatar }
                                    }
                                ],
                                components: [

                                    menuUser ('pickMemberKick', '', '', true)

                                ]
                            }).catch(() => {});

                            
                            const pickMemberKick = (async (newI) => {

                                if (guilds[EventId].Owner !== newI.member.id) return newI.update(await errorNoEventsOwnerMessage (newI.member));
                
                                const pickMember = await guild.members.fetch(newI.values[0]).catch(() => {});

                                if (parameters.started) 
                                return newI.update({
                                    ephemeral: true,  
                                    embeds: [
                                        {
                                            title: `${client.user.username} error`,
                                            color: appearance.embed.errorColor,
                                            description: `${newI.member}, Вы **уже запустили** данное мероприятие`,
                                            thumbnail: { url: iMemberAvatar }
                                        }
                                    ],
                                    components: [

                                    ]
                                });

                                if (parameters.memberInEvent.includes(pickMember.id)) {

                                    for (const position in parameters.position) parameters.position[position] = parameters.position[position].filter((n) => { return n != pickMember.id });
                                    parameters.memberInEvent = parameters.memberInEvent.filter((n) => { return n != pickMember.id });

                                    newI.update({
                                        ephemeral: true,  
                                        embeds: [
                                            {
                                                title: `Управление: ${eventOfCategory.name}`,
                                                color: appearance.embed.color,
                                                description: `${newI.member}, Вы **успешно** удалили **пользователю** ${pickMember} из записи **${eventOfCategory.name}** (${eventRecordChannel})`,
                                                thumbnail: { url: iMemberAvatar }
                                            }
                                        ],
                                        components: [

                                        ]
                                    });

                                    return await recordMessage.edit(await updateRecordMessage ());

                                } 
                    
                                else {

                                    newI.update({
                                        ephemeral: true,  
                                        embeds: [
                                            {
                                                title: `${client.user.username} error`,
                                                color: appearance.embed.errorColor,
                                                description: `${newI.member}, ${pickMember} отсутствует **в записи** мероприятия **${eventOfCategory.name}** (${eventRecordChannel})`,
                                                thumbnail: { url: iMemberAvatar }
                                            }
                                        ],
                                        components: [

                                        ]
                                    });

                                };


                            });

                            actions['pickMemberKick'] = {
                                actions: [pickMemberKick],
                                all: false
                            };

                            break;

                        }

                        case 'delete': { 

                            if (guilds[EventId].Owner !== i.member.id) return i.reply(await errorNoEventsOwnerMessage (i.member));

                            i.reply({  
                                ephemeral: true,  
                                embeds: [
                                    {
                                        title: `Управление: ${eventOfCategory.name}`,
                                        color: appearance.embed.color,
                                        description: `${i.member}, Вы **уверены** что хотите **завершить** мероприятие? Если **да**, тогда **нажмите** на кнопку под этим сообщением`,
                                        thumbnail: { url: iMemberAvatar }
                                    }
                                ],
                                components: [
                                    {
                                        type: 1,
                                        components: [
                                            {
                                                type: 2, 
                                                style: appearance.buttons_menu.Default.style,
                                                customId: 'yesDelete', 
                                                label: 'Завершить мероприятие'
                                            }
                                        ]
                                    }
                                ]
                            }).catch(() => {});

                            
                            const yesDelete = (async (newI) => {

                                if (guilds[EventId].deleted) return newI.update({components: []}).catch(() => {}); 
                                
                                if (guilds[EventId].Owner !== newI.member.id) return newI.update(await errorNoEventsOwnerMessage (newI.member));
                
                                if (parameters.started) {
                                    
                                    guilds[EventId].deleted = true;

                                    newI.update({  
                                        ephemeral: true,  
                                        embeds: [],
                                        components: [
                                            {
                                                type: 1,
                                                components: [
                                                    {
                                                        type: 2, 
                                                        style: appearance.buttons_menu.Default.style,
                                                        customId: 'yesDelete', 
                                                        label: 'Завершить мероприятие',
                                                        disabled: true
                                                    }
                                                ]
                                            }
                                        ]
                                    }).catch(() => {});

                                    manageMessage.delete().catch(() => {});

                                    const teams = parameters.teams;
                                    for (const pickTeams in teams) {

                                        for (const pickMember in teams[pickTeams].membersList) channel.send(`!award ${eventOfCategory.rewards['Проигравшая команда'].reward} ${teams[pickTeams].membersList[pickMember]}`).catch(() => {});

                                    };

                                    let pick = 0;
                                    let pick2 = 0;
                                    let channelsEvent = [eventVoiceChannel, eventRecordChannel, eventManageChannel, eventCategory];
                                    let newChannelsEvent = parameters.newChannels;
                                    
                                    for (let pickVoice in newChannelsEvent) {

                                        newChannelsEvent[pickVoice].members.forEach(member => {
    
                                            member.voice.setChannel(appearance.channels.Closes.Discussion).catch(() => {});

                                        });

                                    };
                                    
                                    eventVoiceChannel.members.forEach(member => {
                                        
                                        member.voice.setChannel(appearance.channels.Closes.Discussion).catch(() => {});

                                    });

                                    let ti1 = setInterval(async () => {

                                        if (eventVoiceChannel && !eventVoiceChannel.members || eventVoiceChannel && !eventVoiceChannel.members.size) {

                                            if (pick == channelsEvent.length) return clearInterval(ti1);
                                            channelsEvent[pick].delete().catch(() => {});
                                            pick++;

                                        } 

                                        else if (!eventVoiceChannel) return clearInterval(ti1);

                                    }, 1000);

                                    let ti2 = setInterval(async () => {

                                        if (!newChannelsEvent[pick2]) if (pick2 == newChannelsEvent.length) return clearInterval(ti2);

                                        if (!newChannelsEvent[pick2].members || !newChannelsEvent[pick2].members.size) {

                                            if (pick2 == newChannelsEvent.length) return clearInterval(ti2);
                                            newChannelsEvent[pick2].delete().catch(() => {});
                                            pick2++;
                                            
                                        };

                                    }, 1000);


                                    logMessage.edit({  
                                        content: `<t:${Math.floor(Date.now()/1000)}:f>`,
                                        embeds: [
                                            {
                                                author: { name: 'Мероприятие завершено' },
                                                title: `${client.user.username + ' logs'}`,
                                                color: appearance.embed.color,
                                                description: `Создано: <t:${Math.floor(guilds[EventId].Created)}:f>\nЗавершено: <t:${Math.floor(Date.now()/1000)}:f>`,
                                                fields: [
                                                    {
                                                        name: `${appearance.embed.dot || appearance.emoji.Dot}Завершил:`,
                                                        value: `・${member}\n・${member.id}`,  
                                                        inline: true
                                                    },
                                                    {
                                                        name: `${appearance.embed.dot || appearance.emoji.Dot}Мероприятие:`,
                                                        value: `\`\`\`${eventOfCategory.name}\`\`\``,
                                                        inline: true
                                                    }
                                                ],
                                                footer: { text: `・Ведущий: ${member.displayName}` },
                                                thumbnail: { url: memberAvatar },
                                            }
                                        ],
                                        components: [

                                        ]
                                    }).catch(() => {});


                                    users[guilds[EventId].Owner].Events.unshift(
                                        {
                
                                            EventId: EventId,
                                            Ended: Date.now () / 1000,
                                            Created: guilds[EventId].Created,
                
                                            message: {

                                                log: logMessage,
                                                announcement: guilds[EventId].message.announcement
                
                                            }
                                            
                                        }
                                    );

                                    guilds[guild.id].Events.Active = guilds[guild.id].Events.Active.filter((n) => { return n != EventId });
                                    users[member.id].ActiveEvent = false;

                                    if (guilds[EventId].message.announcement) 
                                    guilds[EventId].message.announcement.edit({
                                        content: ' ',
                                        components: [
                                            {
                                                type: 1,
                                                components: [
                                                    {
                                                        type: 2, 
                                                        style: 5, 
                                                        label: 'Мероприятие окончено', 
                                                        url: `https://discord.gg/BneyWRqe`,
                                                        disabled: true 
                                                    }
                                                ]
                                            }
                                        ]
                                    }).catch(() => {});

                                }
                            
                                else {

                                    guilds[EventId].deleted = true;
                                    newI.update({  
                                        ephemeral: true,  
                                        embeds: [],
                                        components: [
                                            {
                                                type: 1,
                                                components: [
                                                    {
                                                        type: 2, 
                                                        style: appearance.buttons_menu.Default.style,
                                                        customId: 'yesDelete', 
                                                        label: 'Завершить мероприятие',
                                                        disabled: true
                                                    }
                                                ]
                                            }
                                        ]
                                    }).catch(() => {});

                                    manageMessage.delete().catch(() => {});
                                    eventVoiceChannel.members.forEach(member => {

                                        member.voice.setChannel(appearance.channels.Closes.Discussion).catch(() => {});

                                    });
                                    
                                    let pick = 0;
                                    let channelsEvent = [eventVoiceChannel, eventRecordChannel, eventManageChannel, eventCategory];
                                    let ti3 = setInterval(async () => {

                                        if (eventVoiceChannel && !eventVoiceChannel.members || eventVoiceChannel && !eventVoiceChannel.members.size) {

                                            if (pick == channelsEvent.length) return clearInterval(ti3);
                                            channelsEvent[pick].delete().catch(() => {});
                                            pick++;

                                        };

                                    }, 1000);


                                    logMessage.edit({  
                                        content: `<t:${Math.floor(Date.now()/1000)}:f>`,
                                        embeds: [
                                            {
                                                author: { name: 'Мероприятие завершено' },
                                                title: `${client.user.username + ' logs'}`,
                                                color: appearance.embed.color,
                                                description: `Создано: <t:${Math.floor(guilds[EventId].Created)}:f>\nЗавершено: <t:${Math.floor(Date.now()/1000)}:f>`,
                                                fields: [
                                                    {
                                                        name: `${appearance.embed.dot || appearance.emoji.Dot}Завершил:`,
                                                        value: `・${member}\n・${member.id}`,  
                                                        inline: true
                                                    },
                                                    {
                                                        name: `${appearance.embed.dot || appearance.emoji.Dot}Мероприятие:`,
                                                        value: `\`\`\`${eventOfCategory.name}\`\`\``,
                                                        inline: true
                                                    }
                                                ],
                                                footer: { text: `・Ведущий: ${member.displayName}` },
                                                thumbnail: { url: memberAvatar },
                                            }
                                        ],
                                        components: [
                                            
                                        ]
                                    }).catch(() => {});


                                    users[guilds[EventId].Owner].Events.unshift(
                                        {
                
                                            EventId: EventId,
                                            Ended: Date.now () / 1000,
                                            Created: guilds[EventId].Created,
                
                                            message: {

                                                log: logMessage,
                                                announcement: guilds[EventId].message.announcement
                
                                            }
                                            
                                        }
                                    );

                                    guilds[guild.id].Events.Active = guilds[guild.id].Events.Active.filter((n) => { return n != EventId });
                                    users[member.id].ActiveEvent = false;

                                    if (guilds[EventId].message.announcement) 
                                    guilds[EventId].message.announcement.edit({
                                        content: ' ',
                                        components: [
                                            {
                                                type: 1,
                                                components: [
                                                    {
                                                        type: 2, 
                                                        style: 5, 
                                                        label: 'Мероприятие окончено', 
                                                        url: `https://discord.gg/BneyWRqe`,
                                                        disabled: true 
                                                    }
                                                ]
                                            }
                                        ]
                                    }).catch(() => {});

                                };

                            });

                            actions['yesDelete'] = {
                                actions: [yesDelete],
                                all: false
                            };

                            break;

                        }

                        case 'start': { 

                            if (guilds[EventId].Owner !== i.member.id) return i.reply(await errorNoEventsOwnerMessage (i.member));
                            
                            if (parameters.memberInEvent.length < eventOfCategory.record.minMembers) 
                            return i.reply({
                                ephemeral: true,  
                                embeds: [
                                    {
                                        title: `${client.user.username} error`,
                                        color: appearance.embed.errorColor,
                                        description: `${i.member}, Вы **не можете** запустить мероприятие, до **минимального** кол-во участников необходимо еще **${eventOfCategory.record.minMembers - parameters.memberInEvent.length < 0 ? 0 : eventOfCategory.record.minMembers - parameters.memberInEvent.length}** игроков`,
                                        thumbnail: { url: iMemberAvatar }
                                    }
                                ],
                                components: [

                                ]
                            }).catch(() => {});

                            i.update({
                                content: 'Загружается...',
                                embeds: [

                                ],
                                components: [

                                ]
                            }).catch(() => {});

                            await eventVoiceChannel.setName(eventOfCategory.channels.updateVoice).catch(() => {});
                            await eventRecordChannel.setName(appearance.custom.Closes.channels.updateRecord).catch(() => {});


                            guilds[EventId].message.record.components.forEach(component => {

                                let Comp = component.components;
                
                                for (c = 0; c < Comp.length; c++) {
                
                                    if (Comp[c].data.style !== 5 && Comp[c].data.custom_id !== 'info') Comp[c].data.disabled = true;
                
                                };
                                
                            });
                        
                            await guilds[EventId].message.record.edit({ components: guilds[EventId].message.record.components });
                                
                            if (guilds[EventId].message.announcement) 
                            guilds[EventId].message.announcement.edit({
                                content: ' ',
                                components: [
                                    {
                                        type: 1,
                                        components: [
                                            {
                                                type: 2, 
                                                style: 5, 
                                                label: 'Смотреть мероприятие', 
                                                url: `https://discord.com/channels/${eventVoiceChannel.guild.id}/${eventVoiceChannel.id}`
                                            }
                                        ]
                                    }
                                ]
                            }).catch(() => {});

                            parameters.started = true;
                            guilds[EventId].started = true;
                            parameters.startedTime = Date.now()/1000;

                            let content = '';
                            for (const pickMember in parameters.memberInEvent) {
                                
                                const fetchPickMember = await guild.members.fetch(parameters.memberInEvent[pickMember]).catch(() => {});
                                if (!fetchPickMember) parameters.memberInEvent = parameters.memberInEvent.filter((n) => { return n != pickMember });
                    
                                if (content == '') content += `${fetchPickMember}`;
                                else content += `, ${fetchPickMember}`;

                            };

                            let teams = {};
                            let lastNames = [];
                            infoEmbedsFields = [];
                            manageEmbedsFields = '';

                            let newRecordComponents = [];
                            let manageComponents = {
    
                                type: 1,
                                components: [
    
                                ]
    
                            };

                            let teamsLength = 0;

                            parameters.newChannels = [];
                            if (eventOfCategory.start.teamChannels) {

                                for (const pickTeam in eventOfCategory.start.teams) {

                                    let teamName = await getArrayRandElement (eventOfCategory.start.teams[pickTeam].names);
                                    while (lastNames.includes(teamName.name)) teamName = await getArrayRandElement (eventOfCategory.start.teams[pickTeam].names);
                                    
                                    const eventTeamChannel = await guild.channels.create(
                                        {
                                            name: `${teamName.emoji + teamName.name}`,
                                            type: ChannelType.GuildVoice,
                                            parent: eventCategory.id
                                        }
                                    ).catch(() => {});

                                    parameters.newChannels.push(eventTeamChannel);

                                    teamsLength++;
                                    lastNames.push(teamName.name);
                                    teams[teamsLength] = {

                                        channel: eventTeamChannel,
                                        teamName: teamName,
                                        name: `${teamName.emoji + teamName.name}`,
                                        members: [],
                                        membersList: [],
                                        captain: eventOfCategory.start.teams[pickTeam].captain

                                    };

                                    setTimeout(() => {

                                        eventTeamChannel.permissionOverwrites.edit(guild.id, { ViewChannel: true, Connect: false }).catch(() => {});

                                    }, 1000);

                                };
                                
                                if (parameters.typeRecord == 'positions') {
                                    
                                    for (const pickPosition in eventOfCategory.record.position.list) {

                                        let randomMembers = [];
                                        for (const pickMember in parameters.position[pickPosition]) {

                                            const randomPickMember = await getArrayRandElement (parameters.position[pickPosition]);
                                            parameters.position[pickPosition] = parameters.position[pickPosition].filter((n) => { return n != randomPickMember });
                                            randomMembers.push(randomPickMember);
                                    
                                        };

                                        while (randomMembers[0]) {

                                            for (const pickTeams in teams) {

                                                if (randomMembers[0]) {

                                                    teams[pickTeams].members.push(
                                                        {
                                                            id: randomMembers[0],
                                                            position: {

                                                                emoji: eventOfCategory.record.position.list[pickPosition].emoji,
                                                                name: pickPosition

                                                            }
                                                        }  
                                                    );

                                                    teams[pickTeams].membersList.push(randomMembers[0]);
                                                    randomMembers = randomMembers.filter((n) => { return n != randomMembers[0] });
                                            
                                                };
                                            
                                            };

                                        };
            
                                    };

                                }
                                
                                else if (parameters.typeRecord == 'teams') {

                                    let includTeams = [];
                                    for (const pickTeams in teams) {

                                        for (const pickTeamsOfParameters in parameters.teams) {
                                            
                                            if (!includTeams.includes(pickTeamsOfParameters)) {

                                                includTeams.push(pickTeamsOfParameters);
                                                for (let pickMember in parameters.teams[pickTeamsOfParameters]) {

                                                    teams[pickTeams].members.push(
                                                        {
                                                            id: parameters.teams[pickTeamsOfParameters][pickMember],
                                                            position: false
                                                        }  
                                                    );

                                                    teams[pickTeams].membersList.push(parameters.teams[pickTeamsOfParameters][pickMember]);

                                                };

                                                break;
                                                
                                            };

                                        };

                                    };

                                }

                                else if (parameters.typeRecord == 'random') {

                                    let randomMembers = [];
                                    let randomMemberInEvent = parameters.memberInEvent;
                                    for (const pickMember in randomMemberInEvent) {

                                        const randomPickMember = await getArrayRandElement (randomMemberInEvent);
                                        randomMemberInEvent = randomMemberInEvent.filter((n) => { return n != randomPickMember });
                                        randomMembers.push(randomPickMember);
                                
                                    };

                                    while (randomMembers[0]) {

                                        for (const pickTeams in teams) {

                                            if (randomMembers[0]) {

                                                teams[pickTeams].members.push(
                                                    {
                                                        id: randomMembers[0],
                                                        position: false
                                                    }  
                                                );

                                                randomMembers = randomMembers.filter((n) => { return n != randomMembers[0] });
                                        
                                            };
                                        
                                        };

                                    };
                                    
                                };

                            }
                            
                            else {

                                if (parameters.typeRecord == 'positions') {
                        
                                    for (const pickPosition in eventOfCategory.record.position.list) {
            
                                        let posMembers = '';

                                        for (const pickMember in parameters.position[pickPosition]) {
                                            
                                            const fetchPickMember = await guild.members.fetch(parameters.position[pickPosition][pickMember]).catch(() => {});
                                            posMembers += `・${fetchPickMember}\n`;

                                        };
                                        

                                        if (parameters.position[pickPosition][0]) {

                                            infoEmbedsFields.push(
                                                {
                                                    name: `${eventOfCategory.record.position.list[pickPosition].emoji} ${pickPosition}`,
                                                    value: `${posMembers}`,
                                                    inline: false
                                                }
                                            );

                                        };
            
                                    };

                                }

                                else if (parameters.typeRecord == 'teams') {
                        
                                    for (const pickTeams in eventOfCategory.record.teams.list) {
            
                                        let posMembers = '';

                                        for (const pickMember in parameters.teams[pickTeams]) {
                                            
                                            const fetchPickMember = await guild.members.fetch(parameters.teams[pickTeams][pickMember]).catch(() => {});
                                            posMembers += `・${fetchPickMember}\n`;

                                        };
                                        

                                        if (parameters.teams[pickTeams][0]) {

                                            infoEmbedsFields.push(
                                                {
                                                    name: `${eventOfCategory.record.teams.list[pickTeams].emoji} ${pickTeams}`,
                                                    value: `${posMembers}`,
                                                    inline: false
                                                }
                                            );

                                        };
            
                                    };

                                }

                                else if (parameters.typeRecord == 'random') {
        
                                    let posMembers = '';

                                    for (const pickMember in parameters.memberInEvent) {
                                        
                                        const fetchPickMember = await guild.members.fetch(parameters.memberInEvent[pickMember]).catch(() => {});
                                        posMembers += `・${fetchPickMember}\n`;

                                    };
                                    
        
                                    if (parameters.memberInEvent[0]) {
        
                                        infoEmbedsFields.push(
                                            {
                                                name: `${appearance.emoji.Participants} Участники:`,
                                                value: `${posMembers}`,
                                                inline: false
                                            }
                                        );
        
                                    };
                                    
                                };
                                
                            };

                            for (const pickTeams in teams) {

                                let teamMembers = '';
                                let teamName = teams[pickTeams].name;

                                if (teams[pickTeams].captain)  teams[pickTeams].captain = await getArrayRandElement (teams[pickTeams].membersList);

                                for (const pickMember in teams[pickTeams].members) {
                                    
                                    const fetchPickMember = teams[pickTeams].members[pickMember];
                                    if(fetchPickMember.position) teamMembers += `・${fetchPickMember.position.emoji} <@${fetchPickMember.id}> ${teams[pickTeams].captain && fetchPickMember.id == teams[pickTeams].captain ? appearance.emoji.Captain : ''}\n`;
                                    if (!fetchPickMember.position) teamMembers += `・<@${fetchPickMember.id}> ${teams[pickTeams].captain && fetchPickMember.id == teams[pickTeams].captain ? appearance.emoji.Captain : ''}\n`;
                                    

                                };
                                
                                infoEmbedsFields.push(
                                    {
                                        name: `${teams[pickTeams].name}`,
                                        value: `${teams[pickTeams].channel}\n${teamMembers}`,
                                        inline: true
                                    }
                                );

                                manageEmbedsFields += `${teams[pickTeams].teamName.emoji} — Выбрать победителями команду ${teams[pickTeams].channel}\n`;

                                manageComponents.components.push(
                                    {
                                        type: 2, 
                                        style: appearance.buttons_menu.Default.style, 
                                        customId: teams[pickTeams].teamName.name, 
                                        emoji: teams[pickTeams].teamName.emoji
                                    }
                                );

                                
                                const deletePickTeam = (async (newI) => {

                                    if (guilds[EventId].Owner !== newI.member.id) return newI.reply(await errorNoEventsOwnerMessage (newI.member));

                                    newI.reply({  
                                        ephemeral: true,  
                                        embeds: [
                                            {
                                                title: `Управление: ${eventOfCategory.name}`,
                                                color: appearance.embed.color,
                                                description: `${newI.member}, Вы **уверены** что хотите **завершить** мероприятие с победой команды **${teams[pickTeams].name}**`,
                                                thumbnail: { url: iMemberAvatar }
                                            }
                                        ],
                                        components: [
                                            {
                                                type: 1,
                                                components: [
                                                    {
                                                        type: 2, 
                                                        style: appearance.buttons_menu.Default.style,
                                                        customId: 'yesDeleteTeam' + teams[pickTeams].teamName.name, 
                                                        label: 'Завершить мероприятие'
                                                    }
                                                ]
                                            }
                                        ]
                                    }).catch(() => {});

                                });

                                actions[teams[pickTeams].teamName.name] = {
                                    actions: [deletePickTeam],
                                    all: false
                                };

                                    
                                const yesDeleteTeam = (async (newI) => {

                                    if (guilds[EventId].deleted) return newI.update({components: []}).catch(() => {}); 
                                    if (guilds[EventId].Owner !== newI.member.id) return newI.update(await errorNoEventsOwnerMessage (newI.member));
                    
                                    guilds[EventId].deleted = true;
                                    newI.update({  
                                        ephemeral: true,  
                                        embeds: [],
                                        components: [
                                            {
                                                type: 1,
                                                components: [
                                                    {
                                                        type: 2, 
                                                        style: appearance.buttons_menu.Default.style,
                                                        customId: 'yesDelete', 
                                                        label: 'Завершить мероприятие',
                                                        disabled: true
                                                    }
                                                ]
                                            }
                                        ]
                                    }).catch(() => {});

                                    manageMessage.delete().catch(() => {});
                                    
                                    let pick = 0;
                                    let pick2 = 0;
                                    let channelsEvent = [eventVoiceChannel, eventRecordChannel, eventManageChannel, eventCategory];
                                    let newChannelsEvent = parameters.newChannels;

                                    for (const pickTeams in teams) {

                                        if (teams[pickTeams].name == teamName) for (const pickMember in teams[pickTeams].membersList) channel.send(`!award ${eventOfCategory.rewards['Победившая команда'].reward} ${teams[pickTeams].membersList[pickMember]}`).catch(() => {});
                                        else for (const pickMember in teams[pickTeams].membersList) channel.send(`!award ${eventOfCategory.rewards['Проигравшая команда'].reward} ${teams[pickTeams].membersList[pickMember]}`).catch(() => {});

                                    };
                                    
                                    for (let pickVoice in newChannelsEvent) {

                                        newChannelsEvent[pickVoice].members.forEach(member => {
    
                                            member.voice.setChannel(appearance.channels.Closes.Discussion).catch(() => {});

                                        });

                                    };
                                    
                                    eventVoiceChannel.members.forEach(member => {

                                        member.voice.setChannel(appearance.channels.Closes.Discussion).catch(() => {});

                                    });

                                    let ti1 = setInterval(async () => {

                                        if (eventVoiceChannel && !eventVoiceChannel.members || eventVoiceChannel && !eventVoiceChannel.members.size) {

                                            if (pick == channelsEvent.length) return clearInterval(ti1);
                                            channelsEvent[pick].delete().catch(() => {});
                                            pick++;

                                        } 
                                        
                                        else if (!eventVoiceChannel) return clearInterval(ti1);

                                    }, 1000);

                                    let ti2 = setInterval(async () => {

                                        if (!newChannelsEvent[pick2]) if (pick2 == newChannelsEvent.length) return clearInterval(ti2);

                                        if (!newChannelsEvent[pick2].members || !newChannelsEvent[pick2].members.size) {

                                            if (pick2 == newChannelsEvent.length) return clearInterval(ti2);
                                            newChannelsEvent[pick2].delete().catch(() => {});
                                            pick2++;
                                            
                                        };

                                    }, 1000);


                                    logMessage.edit({  
                                        content: `<t:${Math.floor(Date.now()/1000)}:f>`,
                                        embeds: [
                                            {
                                                author: { name: 'Мероприятие завершено' },
                                                title: `${client.user.username + ' logs'}`,
                                                color: appearance.embed.color,
                                                description: `Создано: <t:${Math.floor(guilds[EventId].Created)}:f>\nЗавершено: <t:${Math.floor(Date.now()/1000)}:f>`,
                                                fields: [
                                                    {
                                                        name: `${appearance.embed.dot || appearance.emoji.Dot}Длительность:`,
                                                        value: `\`\`\`${hourTranslator(Math.floor(Date.now()/1000 - parameters.startedTime))}\`\`\``, 
                                                        inline: false
                                                    },
                                                    {
                                                        name: `${appearance.embed.dot || appearance.emoji.Dot}Завершил:`,
                                                        value: `・${member}\n・${member.id}`,  
                                                        inline: true
                                                    },
                                                    {
                                                        name: `${appearance.embed.dot || appearance.emoji.Dot}Мероприятие:`,
                                                        value: `\`\`\`${eventOfCategory.name}\`\`\``,
                                                        inline: true
                                                    },
                                                    {
                                                        name: `${appearance.embed.dot || appearance.emoji.Dot}Победа:`,
                                                        value: `${appearance.emoji.Win} **${teams[pickTeams].name}**`,
                                                        inline: false
                                                    }
                                                ],
                                                footer: { text: `・Ведущий: ${member.displayName}` },
                                                thumbnail: { url: memberAvatar },
                                            }
                                        ],
                                        components: [

                                        ]
                                    }).catch(() => {});


                                    let resultEmbedsFields = [];
                                    let pickTeamName = teams[pickTeams].name;

                                    for (const pickTeams in teams) {

                                        let teamMembers = '';

                                        for (const pickMember in teams[pickTeams].members) {
                                            
                                            const fetchPickMember = teams[pickTeams].members[pickMember];
                                            if(fetchPickMember.position) teamMembers += `・${fetchPickMember.position.emoji} <@${fetchPickMember.id}> ${teams[pickTeams].captain && fetchPickMember.id == teams[pickTeams].captain ? appearance.emoji.Captain : ''}\n`;
                                            if (!fetchPickMember.position) teamMembers += `・<@${fetchPickMember.id}> ${teams[pickTeams].captain && fetchPickMember.id == teams[pickTeams].captain ? appearance.emoji.Captain : ''}\n`;
                                            

                                        };
                                        
                                        resultEmbedsFields.push(
                                            {
                                                name: `${pickTeamName == teams[pickTeams].name ? appearance.emoji.Win : ''} ${teams[pickTeams].name}`,
                                                value: `${teamMembers || 'Отсутствует'}`,
                                                inline: true
                                            }
                                        );

                                    };


                                    const resultsCloses = await guild.channels.fetch(appearance.channels.Closes.results).catch(() => {});
                
                                    const resultMessage = await resultsCloses.send({  
                                        embeds: [
                                            {
                                                title: `Результаты: ${eventOfCategory.name}`,
                                                color: appearance.embed.color,
                                                description: `Длительность: ${hourTranslatorBold(Math.floor(Date.now()/1000 - parameters.startedTime))}\n<t:${Math.floor(Date.now()/1000)}:D> Загрузка...`,
                                                fields: resultEmbedsFields,
                                                footer: { text: `・Ведущий: ${member.displayName} (${member.id})`, icon_url: iMemberAvatar }
                                            }
                                        ],
                                        components: [ 

                                        ]
                                    }).catch(() => {});
                                
                                    const gameLog = await resultMessage.startThread({ name: 'Информация' }).catch(() => {});

                                    resultMessage.edit({  
                                        embeds: [
                                            {
                                                title: `Результаты: ${eventOfCategory.name}`,
                                                color: appearance.embed.color,
                                                description: `Длительность: ${hourTranslatorBold(Math.floor(Date.now()/1000 - parameters.startedTime))}\n<t:${Math.floor(Date.now()/1000)}:D> ${gameLog}`,
                                                fields: resultEmbedsFields,
                                                footer: { text: `・Ведущий: ${member.displayName} (${member.id})`, icon_url: iMemberAvatar }
                                            }
                                        ],
                                        components: [ 

                                        ]
                                    }).catch(() => {});


                                    users[guilds[EventId].Owner].Events.unshift(
                                        {
                
                                            EventId: EventId,
                                            Ended: Date.now () / 1000,
                                            Created: guilds[EventId].Created,
                
                                            message: {

                                                log: logMessage,
                                                announcement: guilds[EventId].message.announcement,
                                                resultMessage: resultMessage
                
                                            }
                                            
                                        }
                                    );

                                    guilds[guild.id].Events.Active = guilds[guild.id].Events.Active.filter((n) => { return n != EventId });
                                    users[member.id].ActiveEvent = false;

                                    if (guilds[EventId].message.announcement) 
                                    guilds[EventId].message.announcement.edit({
                                        content: ' ',
                                        components: [
                                            {
                                                type: 1,
                                                components: [
                                                    {
                                                        type: 2, 
                                                        style: 5, 
                                                        label: 'Мероприятие окончено', 
                                                        url: `https://discord.gg/BneyWRqe`,
                                                        disabled: true 
                                                    }
                                                ]
                                            }
                                        ]
                                    }).catch(() => {});

                                });

                                actions['yesDeleteTeam' + teams[pickTeams].teamName.name] = {
                                    actions: [yesDeleteTeam],
                                    all: false
                                };
                                

                                if (!newRecordComponents[0]) 
                                newRecordComponents.push(
                                    { 

                                        type: 1,
                                        components: [
                                            
                                        ]
                                        
                                    }
                                );

                                newRecordComponents[0].components.push(
                                    {
                                        type: 2, 
                                        style: 5, 
                                        emoji: teams[pickTeams].teamName.emoji,
                                        url: `https://discord.com/channels/${teams[pickTeams].channel.guild.id}/${teams[pickTeams].channel.id}`,
                                        label: teams[pickTeams].teamName.name
                                    }
                                );
                                

                                if (teams[pickTeams].members[0]) {

                                    for (const pickMember in teams[pickTeams].members) teams[pickTeams].channel.permissionOverwrites.edit(teams[pickTeams].members[pickMember].id, { ViewChannel: true, Connect: true }).catch(() => {});

                                };
                            
                                teams[pickTeams].channel.permissionOverwrites.edit(i.member.id, { ViewChannel: true, Connect: true, MuteMembers: true, MoveMembers: true }).catch(() => {});

                            };

                            guilds[EventId].newChannels = parameters.newChannels;

                            const newRecordMessage = await eventRecordChannel.send({ 
                                content: content,
                                embeds: [
                                    {
                                        title: `Мероприятие: ${eventOfCategory.name}`,
                                        color: appearance.embed.color,
                                        description: `Игроков: **${parameters.memberInEvent.length}** из **${eventOfCategory.record.maxMembers}**\nCписок **участников** ${eventVoiceChannel} (**${eventOfCategory.name}**)\n-# Зайдите в **необходимые** голосовые каналы:`,
                                        footer: { text: `・Ведущий: ${eventOwner.displayName}`, icon_url: iMemberAvatar },
                                        fields: infoEmbedsFields
                                    }
                                ],
                                components: [
                                    {
                                        type: 1,
                                        components: [
                                            {
                                                type: 2, 
                                                style: appearance.buttons_menu.Default.style, 
                                                emoji: appearance.emoji.Continue,
                                                customId: 'continue', 
                                                label: 'Команды мероприятия готовы'
                                            }
                                        ]
                                    }
                                ]
                            }).catch(() => {});


                            i.editReply({  
                                content: ' ',
                                embeds: [
                                    {
                                        title: `Управление: ${eventOfCategory.name}`,
                                        color: appearance.embed.color,
                                        fields: additionInformationOrCommand ?
                                        [
                                            {
                                                name: 'Кнопки:',
                                                value: `${manageEmbedsFields !== '' ? manageEmbedsFields : ''}${appearance.emoji.UserMove} — Поменять/переместить **пользователей** в командах\n${appearance.emoji.Delete} — Досрочно **завершить** данное мероприятие`,
                                                inline: false
                                            },
                                            {
                                                name: 'Команды:',
                                                value: `${additionInformationOrCommand}`,
                                                inline: false
                                            }
                                        ]
                                        :
                                        [
                                            {
                                                name: 'Кнопки:',
                                                value: `${manageEmbedsFields !== '' ? manageEmbedsFields : ''}${appearance.emoji.UserMove} — Поменять/переместить **пользователей** в командах\n${appearance.emoji.Delete} — Досрочно **завершить** данное мероприятие`,
                                                inline: false
                                            }
                                        ]
                                    }
                                ],
                                components: 
                                    manageComponents.components[0] ? 
                                    [
                                        manageComponents,
                                        {
                                            type: 1,
                                            components: [
                                                {
                                                    type: 2, 
                                                    style: appearance.buttons_menu.Default.style, 
                                                    customId: 'swap', 
                                                    emoji: appearance.emoji.UserMove,
                                                    disabled: !eventOfCategory.start.teamChannels
                                                },
                                                {
                                                    type: 2, 
                                                    style: appearance.buttons_menu.Default.style, 
                                                    customId: 'delete', 
                                                    emoji: appearance.emoji.Delete
                                                }
                                            ]
                                        }
                                    ]
                                    :
                                    [
                                        {
                                            type: 1,
                                            components: [
                                                {
                                                    type: 2, 
                                                    style: appearance.buttons_menu.Default.style, 
                                                    customId: 'swap', 
                                                    emoji: appearance.emoji.UserMove
                                                },
                                                {
                                                    type: 2, 
                                                    style: appearance.buttons_menu.Default.style, 
                                                    customId: 'delete', 
                                                    emoji: appearance.emoji.Delete
                                                }
                                            ]
                                        }
                                    ]
                            }).catch(() => {});
                

                            parameters.teams = teams;
                            parameters.newRecordMessage = newRecordMessage;
                            const collectorConponentsOfNewRecordMessage = await newRecordMessage.createMessageComponentCollector();
                            collectorConponentsOfNewRecordMessage.on('collect', async i => {
                                
                                switch (i.customId) { 
    
                                    case 'continue': {

                                        if (guilds[EventId].Owner !== i.member.id) return i.reply(await errorNoEventsOwnerMessage (i.member));

                                        let serverInfoEmbedsFields = [];

                                        if (eventOfCategory.start.serverInfoAccess) {

                                            for (const pickServerInfo in eventOfCategory.start.serverInfo) {
        
                                                let key = '';

                                                if (eventOfCategory.start.serverInfo[pickServerInfo].key) key += eval (eventOfCategory.start.serverInfo[pickServerInfo].key);
                                                key += makeid (eventOfCategory.start.serverInfo[pickServerInfo].length);

                                                key = key.toLowerCase();
                                                key = key.split(' ');
                                                
                                                serverInfoEmbedsFields.push(
                                                    {
                                                        name: `${eventOfCategory.start.serverInfo[pickServerInfo].emoji} ${pickServerInfo}`,
                                                        value: `\`${key}\``,
                                                        inline: true
                                                    }
                                                );
        
                                            };
                                        
                                        };

                                        i.update({
                                            content: ' ',
                                            components: newRecordComponents
                                        }).catch(() => {});

                                        if (serverInfoEmbedsFields[0])
                                        eventRecordChannel.send({
                                            embeds: [
                                                {
                                                    title: `Мероприятие: ${eventOfCategory.name}`,
                                                    color: appearance.embed.color,
                                                    footer: { text: 'Необходимо создать' },
                                                    fields: serverInfoEmbedsFields
                                                }
                                            ]
                                        }).catch(() => {});
                                        
                                    }
    
                                    default: {
                        
                                        if (actions[i.customId] && actions[i.customId].all == false) await actions[i.customId].actions[0](i);
                        
                                        break;
                        
                                    }
                                
                                };
    
                            });

                            break;

                        }

                        case 'swap': { 

                            if (guilds[EventId].Owner !== i.member.id) return i.reply(await errorNoEventsOwnerMessage (i.member));

                            i.reply({  
                                ephemeral: true,  
                                embeds: [
                                    {
                                        title: `Управление: ${eventOfCategory.name}`,
                                        color: appearance.embed.color,
                                        description: `${member}, выберите **пользователя**, которого Вы **хотите** заменить/переместить`,
                                        thumbnail: { url: iMemberAvatar }
                                    }
                                ],
                                components: [

                                    menuUser ('pickMemberSwap', '', '', true)

                                ]
                            }).catch(() => {});

                            let memberSwap1 = '';
                            let memberSwap2 = '';

                            const pickMemberSwap = (async (newI) => {

                                if (guilds[EventId].Owner !== newI.member.id) return newI.update(await errorNoEventsOwnerMessage (newI.member));
                                const pickMember = await guild.members.fetch(newI.values[0]).catch(() => {});
                                memberSwap1 = pickMember;

                                if (parameters.memberInEvent.includes(pickMember.id)) {

                                    newI.update({  
                                        ephemeral: true,  
                                        embeds: [
                                            {
                                                title: `Управление: ${eventOfCategory.name}`,
                                                color: appearance.embed.color,
                                                description: `${member}, выберите **пользователя**, на которого Вы **хотите** заменить/переместить ${pickMember}`,
                                                thumbnail: { url: iMemberAvatar }
                                            }
                                        ],
                                        components: [

                                            menuUser ('pickMemberSwap2', '', '', true)

                                        ]
                                    }).catch(() => {});

                                } 
                    
                                else {

                                    newI.update({
                                        ephemeral: true,  
                                        embeds: [
                                            {
                                                title: `${client.user.username} error`,
                                                color: appearance.embed.errorColor,
                                                description: `${newI.member}, ${pickMember} **отсутствует** на мероприятие **${eventOfCategory.name}**`,
                                                thumbnail: { url: iMemberAvatar }
                                            }
                                        ],
                                        components: [

                                        ]
                                    });

                                };


                            });

                            actions['pickMemberSwap'] = {
                                actions: [pickMemberSwap],
                                all: false
                            };

                            const pickMemberSwap2 = (async (newI) => {

                                if (guilds[EventId].Owner !== newI.member.id) return newI.update(await errorNoEventsOwnerMessage (newI.member));
                                const pickMember = await guild.members.fetch(newI.values[0]).catch(() => {});
                                memberSwap2 = pickMember;

                                if (parameters.memberInEvent.includes(pickMember.id)) {

                                    for (const pickTeams in parameters.teams) {

                                        if (parameters.teams[pickTeams].captain == memberSwap1.id) parameters.teams[pickTeams].captain = memberSwap2.id;
                                        else if (parameters.teams[pickTeams].captain == memberSwap2.id) parameters.teams[pickTeams].captain = memberSwap1.id;

                                        
                                        for (const pickMember in parameters.teams[pickTeams].members) {
                                            
                                            const fetchPickMember = parameters.teams[pickTeams].members[pickMember];

                                            if (fetchPickMember.id == memberSwap1.id) {

                                                fetchPickMember.id = memberSwap2.id;
                                                parameters.teams[pickTeams].membersList = parameters.teams[pickTeams].membersList.filter ((n) => { return n != fetchPickMember.id });
                                                parameters.teams[pickTeams].membersList.push (memberSwap2.id);

                                                parameters.teams[pickTeams].channel.permissionOverwrites.edit(memberSwap2.id, { ViewChannel: true, Connect: true }).catch(() => {});
                                                parameters.teams[pickTeams].channel.permissionOverwrites.edit(memberSwap1.id, { ViewChannel: true, Connect: false }).catch(() => {});
                                            
                                            }

                                            else if (fetchPickMember.id == memberSwap2.id) {

                                                fetchPickMember.id = memberSwap1.id;
                                                parameters.teams[pickTeams].membersList = parameters.teams[pickTeams].membersList.filter ((n) => { return n != fetchPickMember.id });
                                                parameters.teams[pickTeams].membersList.push (memberSwap1.id);

                                                parameters.teams[pickTeams].channel.permissionOverwrites.edit(memberSwap1.id, { ViewChannel: true, Connect: true }).catch(() => {});
                                                parameters.teams[pickTeams].channel.permissionOverwrites.edit(memberSwap2.id, { ViewChannel: true, Connect: false }).catch(() => {});          

                                            };
                                            
                                        };

                                        parameters.teams[pickTeams].channel.permissionOverwrites.edit(i.member.id, { ViewChannel: true, Connect: true, MuteMembers: true, MoveMembers: true }).catch(() => {});

                                    };

                                    
                                    newI.update({
                                        ephemeral: true,  
                                        embeds: [
                                            {
                                                title: `Управление: ${eventOfCategory.name}`,
                                                color: appearance.embed.color,
                                                description: `${newI.member}, Вы **успешно** поменили **пользователей** ${memberSwap1} и ${memberSwap2} местами`,
                                                thumbnail: { url: iMemberAvatar }
                                            }
                                        ],
                                        components: [

                                        ]
                                    }).catch(() => {});

                                    parameters.newRecordMessage.reply({
                                        content: `${memberSwap1} ${appearance.emoji.UserMove} ${memberSwap2}`,
                                        embeds: [
                                            {
                                                title: `Управление: ${eventOfCategory.name}`,
                                                color: appearance.embed.color,
                                                description: `${newI.member} изменил **состав** команды, а именно поменял местами **пользователей** ${memberSwap1} и ${memberSwap2}`,
                                                thumbnail: { url: iMemberAvatar }
                                            }
                                        ],
                                        components: [

                                        ]
                                    }).catch(() => {});


                                    infoEmbedsFields = [];
                                    for (const pickTeams in parameters.teams) {

                                        let teamMembers = '';

                                        for (const pickMember in parameters.teams[pickTeams].members) {
                                            
                                            const fetchPickMember = parameters.teams[pickTeams].members[pickMember];
                                            if(fetchPickMember.position) teamMembers += `・${fetchPickMember.position.emoji} <@${fetchPickMember.id}> ${parameters.teams[pickTeams].captain && fetchPickMember.id == parameters.teams[pickTeams].captain ? appearance.emoji.Captain : ''}\n`;
                                            if (!fetchPickMember.position) teamMembers += `・<@${fetchPickMember.id}> ${parameters.teams[pickTeams].captain && fetchPickMember.id == parameters.teams[pickTeams].captain ? appearance.emoji.Captain : ''}\n`;

                                        };
                                        
                                        infoEmbedsFields.push(
                                            {
                                                name: `${parameters.teams[pickTeams].name}`,
                                                value: `${parameters.teams[pickTeams].channel}\n${teamMembers}`,
                                                inline: true
                                            }
                                        );

                                    };

                                    parameters.newRecordMessage.edit({
                                        embeds: [
                                            {
                                                title: `Мероприятие: ${eventOfCategory.name}`,
                                                color: appearance.embed.color,
                                                description: `Игроков: **${parameters.memberInEvent.length}** из **${eventOfCategory.record.maxMembers}**\nСнизу расположен **список** участников **${eventOfCategory.name}**\nЗайдите в **необходимые** войсы`,
                                                footer: { text: `・Ведущий: ${eventOwner.displayName}`, icon_url: iMemberAvatar },
                                                fields: infoEmbedsFields
                                            }
                                        ]
                                    }).catch(() => {});

                                } 
                    
                                else {

                                    for (const pickTeams in parameters.teams) {

                                        if (parameters.teams[pickTeams].captain == memberSwap1.id) parameters.teams[pickTeams].captain = memberSwap2.id;

                                        for (const pickMember in parameters.teams[pickTeams].members) {
                                            
                                            const fetchPickMember = parameters.teams[pickTeams].members[pickMember];

                                            if (fetchPickMember.id == memberSwap1.id) {

                                                fetchPickMember.id = memberSwap2.id;
                                                parameters.teams[pickTeams].membersList = parameters.teams[pickTeams].membersList.filter ((n) => { return n != fetchPickMember.id });
                                                parameters.teams[pickTeams].membersList.push (memberSwap2.id);

                                                parameters.teams[pickTeams].channel.permissionOverwrites.edit(memberSwap2.id, { ViewChannel: true, Connect: true }).catch(() => {});
                                                parameters.teams[pickTeams].channel.permissionOverwrites.edit(memberSwap1.id, { ViewChannel: true, Connect: false }).catch(() => {});
                                            
                                            };
                                            
                                        };

                                        parameters.teams[pickTeams].channel.permissionOverwrites.edit(i.member.id, { ViewChannel: true, Connect: true, MuteMembers: true, MoveMembers: true }).catch(() => {});

                                    };

                                    newI.update({
                                        ephemeral: true,  
                                        embeds: [
                                            {
                                                title: `Управление: ${eventOfCategory.name}`,
                                                color: appearance.embed.color,
                                                description: `${newI.member}, Вы **успешно** заменили **пользователя** ${memberSwap1} на ${memberSwap2}`,
                                                thumbnail: { url: iMemberAvatar }
                                            }
                                        ],
                                        components: [

                                        ]
                                    }).catch(() => {});

                                    parameters.newRecordMessage.reply({ 
                                        content: `${memberSwap1} ${appearance.emoji.UserMove} ${memberSwap2}`,
                                        embeds: [
                                            {
                                                title: `Управление: ${eventOfCategory.name}`,
                                                color: appearance.embed.color,
                                                description: `${newI.member} изменил **состав** команды, а именно заменил **пользователя** ${memberSwap1} на ${memberSwap2}`,
                                                thumbnail: { url: iMemberAvatar }
                                            }
                                        ],
                                        components: [

                                        ]
                                    }).catch(() => {});


                                    infoEmbedsFields = [];
                                    for (const pickTeams in parameters.teams) {

                                        let teamMembers = '';

                                        for (const pickMember in parameters.teams[pickTeams].members) {
                                            
                                            const fetchPickMember = parameters.teams[pickTeams].members[pickMember];
                                            if(fetchPickMember.position) teamMembers += `・${fetchPickMember.position.emoji} <@${fetchPickMember.id}> ${parameters.teams[pickTeams].captain && fetchPickMember.id == parameters.teams[pickTeams].captain ? appearance.emoji.Captain : ''}\n`;
                                            if (!fetchPickMember.position) teamMembers += `・<@${fetchPickMember.id}> ${parameters.teams[pickTeams].captain && fetchPickMember.id == parameters.teams[pickTeams].captain ? appearance.emoji.Captain : ''}\n`;

                                        };
                                        
                                        infoEmbedsFields.push(
                                            {
                                                name: `${parameters.teams[pickTeams].name}`,
                                                value: `${parameters.teams[pickTeams].channel}\n${teamMembers}`,
                                                inline: true
                                            }
                                        );

                                    };

                                    parameters.newRecordMessage.edit({
                                        embeds:[
                                            {
                                                title: `Мероприятие: ${eventOfCategory.name}`,
                                                color: appearance.embed.color,
                                                description: `Игроков: **${parameters.memberInEvent.length}** из **${eventOfCategory.record.maxMembers}**\nСнизу расположен **список** участников **${eventOfCategory.name}**\nЗайдите в **необходимые** войсы`,
                                                footer: { text: `・Ведущий: ${eventOwner.displayName}`, icon_url: iMemberAvatar },
                                                fields: infoEmbedsFields
                                            }
                                        ]
                                    }).catch(() => {});

                                };


                            });

                            actions['pickMemberSwap2'] = {
                                actions: [pickMemberSwap2],
                                all: false
                            };

                            break;

                        }

                        default: {
            
                            if (actions[i.customId] && actions[i.customId].all == false) await actions[i.customId].actions[0](i);
            
                            break;
            
                        }
                    
                    };

                });

            }

            else if (eventOfCategory.type == 'mafia') {
                
                const heightChannels = await guild.channels.fetch(appearance.channels.Closes.heightChannelCreate).catch(() => {});
                const Position = heightChannels.rawPosition ?? 0;

                const eventCategory = await guild.channels.create(
                    {
                        name: `${eventOfCategory.name}・${member.displayName}`,
                        type: ChannelType.GuildCategory,
                        position: Position
                    }
                ).catch(() => {});
                
                const eventManageChannel = await guild.channels.create(
                    {
                        name: `${appearance.custom.Mafia.channels.manage}`,
                        type: ChannelType.GuildText,
                        parent: eventCategory.id,
                        permissionOverwrites: [
                            {
                                id: guild.id,
                                deny: [PermissionsBitField.Flags.ViewChannel]
                            },
                            {
                                id: member.id,
                                allow: [PermissionsBitField.Flags.ViewChannel]
                            }
                        ]
                    }
                ).catch(() => {});


                if (reply) {

                    setTimeout(() => {
                        
                        i.editReply({
                            embeds: [
                                {
                                    title: `${client.user.username} create`,
                                    color: appearance.embed.color,
                                    description: `${member}, Вы **успешно** создали мероприятие **${eventOfCategory.name}**, для управления зайдите в ${eventManageChannel}`,
                                    thumbnail: { url: memberAvatar } 
                                }
                            ], 
                            components: [
                                
                            ]
                        }).catch(() => {});

                    }, 1000);

                }
                
                else 
                i.update({
                    embeds: [
                        {
                            title: `${client.user.username} create`,
                            color: appearance.embed.color,
                            description: `${member}, Вы **успешно** создали мероприятие **${eventOfCategory.name}**, для управления зайдите в ${eventManageChannel}`,
                            thumbnail: { url: memberAvatar } 
                        }
                    ], 
                    components: [
                        
                    ]
                }).catch(() => {});


                const eventRecordChannel = await guild.channels.create(
                    {
                        name: `${appearance.custom.Mafia.channels.record}`,
                        type: ChannelType.GuildText,
                        parent: eventCategory.id,
                        permissionOverwrites: [
                            {
                                id: guild.id,
                                deny: [PermissionsBitField.Flags.ViewChannel, PermissionsBitField.Flags.AttachFiles, PermissionsBitField.Flags.AddReactions, PermissionsBitField.Flags.UseExternalEmojis, PermissionsBitField.Flags.SendMessages, PermissionsBitField.Flags.ManageChannels],
                                allow: [PermissionsBitField.Flags.ViewChannel]
                            }, 
                            {
                                id: member.id, 
                                allow: [PermissionsBitField.Flags.ViewChannel, PermissionsBitField.Flags.AttachFiles, PermissionsBitField.Flags.ManageMessages, PermissionsBitField.Flags.SendMessages]
                            }
                        ]
                    }
                ).catch(() => {});

                const eventVoiceChannel = await guild.channels.create(
                    {
                        name: `${eventOfCategory.channels.voice}`,
                        type: ChannelType.GuildVoice,
                        parent: eventCategory.id,
                        permissionOverwrites: [
                            {
                                id: guild.id,
                                deny: [PermissionsBitField.Flags.ViewChannel, PermissionsBitField.Flags.SendMessages, PermissionsBitField.Flags.AttachFiles, PermissionsBitField.Flags.AddReactions, PermissionsBitField.Flags.UseExternalEmojis, PermissionsBitField.Flags.Stream, PermissionsBitField.Flags.UseEmbeddedActivities, PermissionsBitField.Flags.ManageChannels],
                                allow: [PermissionsBitField.Flags.ViewChannel, PermissionsBitField.Flags.Connect]
                            }, 
                            {
                                id: member.id, 
                                allow: [PermissionsBitField.Flags.ViewChannel, PermissionsBitField.Flags.AttachFiles, PermissionsBitField.Flags.ManageEvents, PermissionsBitField.Flags.Connect, PermissionsBitField.Flags.MuteMembers, PermissionsBitField.Flags.MoveMembers, PermissionsBitField.Flags.Stream, PermissionsBitField.Flags.Stream, PermissionsBitField.Flags.UseEmbeddedActivities]
                            }
                        ]
                    }
                ).catch(() => {});

                const EventId = makeid(20);
                users[member.id].ActiveEvent = EventId;
                guilds[guild.id].Events.Active.push(EventId);

                const logsMafia = await guild.channels.fetch(appearance.channels.Mafia.logs);

                const logMessage = await logsMafia.send({  
                    content: `<t:${Math.floor(Date.now()/1000)}:f>`,
                    embeds: [
                        {
                            author: { name: 'Мероприятие создано' },
                            title: `${client.user.username + ' logs'}`,
                            color: appearance.embed.color,
                            description: `Создано: <t:${Math.floor(Date.now()/1000)}:f>`,
                            fields: [
                                {
                                    name: `${appearance.embed.dot || appearance.emoji.Dot}Создал:`,
                                    value: `・${member}\n・${member.id}`,  
                                    inline: true
                                },
                                {
                                    name: `${appearance.embed.dot || appearance.emoji.Dot}Канал:`,
                                    value: `・${eventVoiceChannel}\n・${eventVoiceChannel.id}`,
                                    inline: true
                                },
                                {
                                    name: `${appearance.embed.dot || appearance.emoji.Dot}Мероприятие:`,
                                    value: `\`\`\`${eventOfCategory.name}\`\`\``,
                                    inline: false
                                }
                            ],
                            footer: { text: `・Ведущий: ${member.displayName}` },
                            thumbnail: { url: memberAvatar },
                        }
                    ],
                    components: [

                    ]
                }).catch(() => {});


                let midlRaiting = 0;
                parameters.started = false;
                parameters.announcementMessage = false;


                const scheduledEvent = await guild.scheduledEvents.create({
                    name: `${eventOfCategory.name}`,
                    scheduledStartTime: new Date(Date.now() + 5 * 1000), 
                    scheduledEndTime: new Date(Date.now() + 24 * 60 * 60 * 1000),
                    privacyLevel: GuildScheduledEventPrivacyLevel.GuildOnly, 
                    entityType: GuildScheduledEventEntityType.Voice, 
                    channel: eventVoiceChannel.id, 
                    description: `${eventOfCategory.embed.info.description ? eventOfCategory.embed.info.description : 'Отсутствует'}`,
                    image: eventOfCategory.embed.info.image || null
                }).catch(() => {});

                scheduledEvent.setStatus(2).catch(() => {});
                    

                parameters.announcementMessage = false;
                eventVoiceChannel.permissionOverwrites.edit(guild.id, { Stream: Boolean(eventOfCategory.video) }).catch(() => {});

                for (const roleOfFullA of appearance.roles.Events.fullAccess) {

                    eventRecordChannel.permissionOverwrites.edit(roleOfFullA, { ViewChannel: true, ManageMessages: true, SendMessages: true, AttachFiles: true }).catch(() => {});
                    eventVoiceChannel.permissionOverwrites.edit(roleOfFullA, { ViewChannel: true, Connect: true, MuteMembers: true, MoveMembers: true }).catch(() => {});

                };


                let infoEmbeds = [];
                let infoComponents = {

                    type: 1,
                    components: [

                    ]

                };

                let infoEmbedsFields = [];
                parameters.memberInEvent = [];
                parameters.savePriority = [];
                parameters.position = {};
                    

                async function updateRecordMessage () {
                    
                    let eventOwner = await guild.members.fetch(guilds[EventId].Owner).catch(() => {});
                    let infoComponents = {

                        type: 1,
                        components: [

                        ]

                    };

                    infoEmbedsFields = [];
                    
                    let in10Members = '';
                    let otherMembers = '';

                    let highPriority = [];
                    let defaultPriority = [];
                    let savePriority = [];
                    let lowPriority = [];

                    if (eventOfCategory.record.systemOfPriority) {

                        let newMemberInEvent = [];

                        for (const pickMember in parameters.memberInEvent) {
                            
                            let memberPriority = 0;
                            const fetchPickMember = await guild.members.fetch(parameters.memberInEvent[pickMember]).catch(() => {});
                            if (!fetchPickMember) parameters.memberInEvent = parameters.memberInEvent.filter((n) => { return n != fetchPickMember.id });
                            for (let a = 0; a < appearance.roles.Mafia.lowPriority.length; a++) if(fetchPickMember._roles.includes(appearance.roles.Mafia.lowPriority[a])) memberPriority = -1;
                            for (let a = 0; a < appearance.roles.Mafia.highPriority.length; a++) if(fetchPickMember._roles.includes(appearance.roles.Mafia.highPriority[a])) memberPriority = 1;
                            if (parameters.savePriority && parameters.savePriority.includes(fetchPickMember.id)) memberPriority = 2;
                        
                            if (memberPriority == 2) savePriority.push(fetchPickMember.id);
                            if (memberPriority == 1) highPriority.push(fetchPickMember.id);
                            if (memberPriority == 0) defaultPriority.push(fetchPickMember.id);
                            if (memberPriority == -1) lowPriority.push(fetchPickMember.id);

                        };

                        for (let a = 0; a < savePriority.length; a++) newMemberInEvent.push(savePriority[a]);
                        for (let a = 0; a < highPriority.length; a++) newMemberInEvent.push(highPriority[a]);
                        for (let a = 0; a < defaultPriority.length; a++) newMemberInEvent.push(defaultPriority[a]);
                        for (let a = 0; a < lowPriority.length; a++) newMemberInEvent.push(lowPriority[a]);

                        parameters.memberInEvent = newMemberInEvent;

                    };

                    let membersRaiting = [];

                    for (const pickMember in parameters.memberInEvent) {
                    
                        if (pickMember < eventOfCategory.record.maxMembers) {

                            const fetchPickMember = await guild.members.fetch(parameters.memberInEvent[pickMember]).catch(() => {});
                            checkingForAvailability (db, fetchPickMember);

                            membersRaiting.push(stats[fetchPickMember.id].Mafia[eventOfCategory.result].rating);

                        };

                    };

                    let minRaiting = Math.min(...membersRaiting);
                    let maxRaiting = Math.max(...membersRaiting);

                    midlRaiting = Math.floor((maxRaiting+minRaiting)/2);

                    for (const pickMember in parameters.memberInEvent) {
                    
                        if (pickMember < eventOfCategory.record.maxMembers) {

                            const fetchPickMember = await guild.members.fetch(parameters.memberInEvent[pickMember]).catch(() => {});
                            const memberRaiting = stats[fetchPickMember.id].Mafia[eventOfCategory.result].rating;

                            if (!fetchPickMember) parameters.memberInEvent = parameters.memberInEvent.filter((n) => { return n != fetchPickMember.id });
                            in10Members += `${eventOfCategory.record.systemOfPriority ? highPriority.includes(fetchPickMember.id) ? appearance.emoji.HighPriority : lowPriority.includes(fetchPickMember.id) ? appearance.emoji.LowPriority : savePriority.includes(fetchPickMember.id) ? appearance.emoji.SavePriority : appearance.emoji.DefaultPriority : ``} ${fetchPickMember}${midlRaiting + 75 < memberRaiting ? appearance.emoji.HighRaiting : midlRaiting > memberRaiting + 75 ? appearance.emoji.LowRaiting : appearance.emoji.MidlRaiting}\n`;

                        };

                        if (pickMember >= eventOfCategory.record.maxMembers) {

                            const fetchPickMember = await guild.members.fetch(parameters.memberInEvent[pickMember]).catch(() => {});
                            if (!fetchPickMember) parameters.memberInEvent = parameters.memberInEvent.filter((n) => { return n != fetchPickMember.id });
                            otherMembers += `${eventOfCategory.record.systemOfPriority ? highPriority.includes(fetchPickMember.id) ? appearance.emoji.HighPriority : lowPriority.includes(fetchPickMember.id) ? appearance.emoji.LowPriority : savePriority.includes(fetchPickMember.id) ? appearance.emoji.SavePriority : appearance.emoji.DefaultPriority : ``} ${fetchPickMember}\n`;

                        };

                    };

                    if (parameters.memberInEvent[0]) {

                        infoEmbedsFields.push(
                            {
                                name: `Записавшиеся:`, // `${appearance.emoji.Participants} Записавшиеся:`,
                                value: `${in10Members}`,
                                inline: false
                            }
                        );

                    };

                    if (parameters.memberInEvent[eventOfCategory.record.maxMembers]) {

                        infoEmbedsFields.push(
                            {
                                name: `Очередь:`, // `${appearance.emoji.Other} Очередь:`,
                                value: `${otherMembers}`,
                                inline: false
                            }
                        );

                    };

                    infoComponents.components.push(
                        {
                            type: 2, 
                            style: 1, 
                            customId: 'record', 
                            label: 'Записаться на игру'
                        }
                    );


                    return {  
                        embeds: [
                            {
                                title: `Мероприятие: ${eventOfCategory.name}`,
                                color: appearance.embed.color,
                                description: `Игроков: **${parameters.memberInEvent.length}** из **${eventOfCategory.record.maxMembers}**\nНеобходимо еще игроков: **${eventOfCategory.record.minMembers - parameters.memberInEvent.length < 0 ? 0 : eventOfCategory.record.minMembers - parameters.memberInEvent.length}**`,
                                footer: { text: `・Ведущий: ${eventOwner.displayName}`, icon_url: await getAvatar(eventOwner) },
                                fields: infoEmbedsFields
                            }
                        ],
                        components: [
                            infoComponents
                        ]
                    };

                };
                
                const recordButton = (async (newI) => {

                    const newIMemberAvatar = await getAvatar(newI.member);

                    if (parameters.memberInEvent.includes(newI.member.id)) {

                        parameters.memberInEvent = parameters.memberInEvent.filter((n) => { return n != newI.member.id });
                        if (!parameters.savePriority) parameters.savePriority = parameters.savePriority.filter((n) => { return n != newI.member.id });

                        await recordMessage.edit(await updateRecordMessage ());

                        newI.reply({
                            ephemeral: true,  
                            embeds: [
                                {
                                    title: `Мероприятие: ${eventOfCategory.name}`,
                                    color: appearance.embed.color,
                                    description: `${newI.member}, Вы **успешно** выписались из данного мероприятия`,
                                    thumbnail: { url: newIMemberAvatar }
                                }
                            ],
                            components: [

                            ]
                        });


                        const goToVoice = [
                            {
                                type: 1,
                                components: [
                                    {
                                        type: 2, 
                                        label: 'Записаться на мероприятие', 
                                        url: `https://discord.com/channels/${eventRecordChannel.guild.id}/${eventRecordChannel.id}`,
                                        style: 5
                                    }
                                ]
                            }
                        ];

                        let eventOwner = await guild.members.fetch(guilds[EventId].Owner).catch(() => {});
                        if (parameters.announcementMessage) parameters.announcementMessage.edit(await announcementMessageSend (eventOfCategory.name, eventOwner, goToVoice, `${parameters.memberInEvent.length} из ${eventOfCategory.record.maxMembers}`));

                        return;
                        
                    };   

                    if (eventOfCategory.record.roleAccess) {

                        let rolesInc = true;
                        let rolesText = '';
                        for (const pickRole of eventOfCategory.record.roleAccess) {
                            if (!newI.member._roles.includes(pickRole)) rolesInc = false;
                            rolesText += ` <@&${pickRole}>`;
                        };

                        if (!rolesInc) return newI.reply({
                            ephemeral: true,  
                            embeds: [
                                {
                                    title: `${client.user.username} error`,
                                    color: appearance.embed.errorColor,
                                    description: `${newI.member}, Вы **не можете** записаться на мероприятие, у Вас **нету** роли(ей):${rolesText || 'Отсутствует'}`,
                                    thumbnail: { url: newIMemberAvatar }
                                }
                            ],
                            components: [

                            ]
                        });

                    };
                    
                    if (parameters.memberInEvent.length == eventOfCategory.record.maxRecordMembers) 
                    return newI.reply({
                        ephemeral: true,  
                        embeds: [
                            {
                                title: `${client.user.username} error`,
                                color: appearance.embed.errorColor,
                                description: `${newI.member}, Вы **не можете** записаться на мероприятие, **максимально** кол-во участников **уже** записано`,
                                thumbnail: { url: newIMemberAvatar }
                            }
                        ],
                        components: [

                        ]
                    });

                    if(newI.member._roles.includes(appearance.roles.Mafia.ban))
                    return newI.reply({
                        ephemeral: true,  
                        embeds: [
                            {
                                title: `${client.user.username} error`,
                                color: appearance.embed.errorColor,
                                description: `${newI.member}, Вы **не можете** записаться на мероприятие, у Вас **есть** роль запрета <@&${appearance.roles.Mafia.ban}>`,
                                thumbnail: { url: newIMemberAvatar }
                            }
                        ],
                        components: [

                        ]
                    });

                    if(newI.member.id == guilds[EventId].Owner)
                    return newI.reply({
                        ephemeral: true,  
                        embeds: [
                            {
                                title: `${client.user.username} error`,
                                color: appearance.embed.errorColor,
                                description: `${newI.member}, Вы **не можете** записаться на мероприятие`,
                                thumbnail: { url: newIMemberAvatar }
                            }
                        ],
                        components: [

                        ]
                    });

                    parameters.memberInEvent = parameters.memberInEvent.filter((n) => { return n != newI.member.id });
                    parameters.memberInEvent.push(newI.member.id);

                    newI.reply({
                        ephemeral: true,  
                        embeds: [
                            {
                                title: `Мероприятие: ${eventOfCategory.name}`,
                                color: appearance.embed.color,
                                description: `${newI.member}, Вы **успешно** записаны на мероприятие`,
                                thumbnail: { url: newIMemberAvatar }
                            }
                        ],
                        components: [

                        ]
                    });


                    const goToVoice = [
                        {
                            type: 1,
                            components: [
                                {
                                    type: 2, 
                                    label: 'Записаться на мероприятие', 
                                    url: `https://discord.com/channels/${eventRecordChannel.guild.id}/${eventRecordChannel.id}`,
                                    style: 5
                                }
                            ]
                        }
                    ];

                    let eventOwner = await guild.members.fetch(guilds[EventId].Owner).catch(() => {});
                    if (parameters.announcementMessage) parameters.announcementMessage.edit(await announcementMessageSend (eventOfCategory.name, eventOwner, goToVoice, `${parameters.memberInEvent.length} из ${eventOfCategory.record.maxMembers}`));
                    return await recordMessage.edit(await updateRecordMessage ());

                });

                infoComponents.components.push(
                    {
                        type: 2, 
                        style: 1, 
                        customId: 'record', 
                        label: 'Записаться на игру'
                    }
                );

                actions['record'] = {
                    actions: [recordButton],
                    all: false
                };

                infoEmbeds.push(
                    {
                        title: `Мероприятие: ${eventOfCategory.name}`,
                        color: appearance.embed.color,
                        description: `Игроков: **${parameters.memberInEvent.length}** из **${eventOfCategory.record.maxMembers}**\nНеобходимо еще игроков: **${eventOfCategory.record.minMembers - parameters.memberInEvent.length < 0 ? 0 : eventOfCategory.record.minMembers - parameters.memberInEvent.length}**`,
                        footer: { text: `・Ведущий: ${member.displayName}`, icon_url: memberAvatar },
                        fields: infoEmbedsFields
                    }
                );


                const recordMessage = await eventRecordChannel.send({  
                    embeds: infoEmbeds,
                    components: [
                        infoComponents
                    ]
                }).catch(() => {});

                recordMessage.pin().catch(() => {});


                const chRecordInt = setInterval(async () => {

                    if (parameters.deleted || parameters.started) clearInterval(chRecordInt);

                    for (const pickMember in parameters.memberInEvent) {
                        
                        const fetchPickMember = await guild.members.fetch(parameters.memberInEvent[pickMember]).catch(() => {});
                        if (!fetchPickMember) {

                            parameters.memberInEvent = parameters.memberInEvent.filter((n) => { return n != parameters.memberInEvent[pickMember] });
                            await recordMessage.edit(await updateRecordMessage ());

                        };
                        
                        if(fetchPickMember._roles.includes(appearance.roles.Mafia.ban)) {

                            parameters.memberInEvent = parameters.memberInEvent.filter((n) => { return n != fetchPickMember.id });
                            await recordMessage.edit(await updateRecordMessage ());
                            
                        };
                        
                        if(fetchPickMember.id == guilds[EventId].Owner) {

                            parameters.memberInEvent = parameters.memberInEvent.filter((n) => { return n != fetchPickMember.id });
                            await recordMessage.edit(await updateRecordMessage ());
                            
                        };

                    };

                }, 2000);

                parameters.handOver = false;
                parameters.handOverMsg = false;

                parameters.autosbor = false;


                let additionInformationOrCommand = '';
                const commands = await client.application.commands.fetch().catch(() => {});

                commands.forEach(command => {
                    if (command.name == 'event') {
                        additionInformationOrCommand += `\n-# ~~</event reward:${command.id}> — Награды выдаются автоматически~~\n</event transfer:${command.id}> — Передать мероприятие\n-# </event delete:${command.id}> — (Резервное) удаление мероприятия`
                    };
                });

                let manageMessage = await eventManageChannel.send({  
                    embeds: [
                        {
                            title: `Управление: ${eventOfCategory.name}`,
                            color: appearance.embed.color,
                            fields: additionInformationOrCommand ?
                            [
                                {
                                    name: 'Кнопки:',
                                    value: `${appearance.emoji.Announcement} — Анонсировать в <#${appearance.channels.Announcement}>\n${appearance.emoji.Start} — **Начать** данное мероприятие\n${appearance.emoji.UserBlock} — **Удалить** пользователя из списка участников\n${appearance.emoji.Delete} — Досрочно **завершить** данное мероприятие`,
                                    inline: false
                                },
                                {
                                    name: 'Команды:',
                                    value: `${additionInformationOrCommand}`,
                                    inline: false
                                }
                            ]
                            :
                            [
                                {
                                    name: 'Кнопки:',
                                    value: `${appearance.emoji.Announcement} — Анонсировать в <#${appearance.channels.Announcement}>\n${appearance.emoji.Start} — **Начать** данное мероприятие\n${appearance.emoji.UserBlock} — **Удалить** пользователя из списка участников\n${appearance.emoji.Delete} — Досрочно **завершить** данное мероприятие`,
                                    inline: false
                                }
                            ]
                        }
                    ],
                    components: [
                        {
                            type: 1,
                            components: [
                                {
                                    type: 3,
                                    customId: 'typeSelectSbor', 
                                    placeholder: 'Настройка сбора стола', 
                                    minValues: 0, 
                                    maxValues: 2, 
                                    options: [
                                        {
                                            label: 'Можно забрать',      
                                            emoji: appearance.emoji.HandOver,     
                                            description: `Любой ведущий может забрать ваше мероприятие`,
                                            value: 'handOver'
                                        },
                                        {
                                            label: 'Автосбор',                       
                                            emoji: appearance.emoji.Autosbor,     
                                            description: `Автоматический пинг роли уведомления на мафию`,
                                            value: 'autosbor' 
                                        },
                                        {
                                            label: 'Остановить запись',         
                                            description: `Запрещает записываться/выписываться из записи на игру`,
                                            value: 'stop'
                                        }
                                    ]
                                }
                            ]
                        },
                        {
                            type: 1,
                            components: [
                                {
                                    type: 2, 
                                    style: appearance.buttons_menu.Default.style, 
                                    customId: 'announcement', 
                                    emoji: appearance.emoji.Announcement
                                },
                                {
                                    type: 2, 
                                    style: appearance.buttons_menu.Default.style, 
                                    customId: 'start', 
                                    emoji: appearance.emoji.Start
                                },
                                {
                                    type: 2, 
                                    style: appearance.buttons_menu.Default.style, 
                                    customId: 'kick', 
                                    emoji: appearance.emoji.UserBlock
                                },
                                {
                                    type: 2, 
                                    style: appearance.buttons_menu.Default.style, 
                                    customId: 'delete', 
                                    emoji: appearance.emoji.Delete
                                }
                            ]
                        }
                    ]
                }).catch(() => {});

                
                guilds[EventId] = {

                    EventId: EventId, 
                    
                    type: 'mafia',
                    started: false,
                    deleted: false,
                    examination: false,
                    game: {},

                    channels: {

                        category: eventCategory.id,
                        manage: eventManageChannel.id,
                        record: eventRecordChannel.id,
                        voice: eventVoiceChannel.id

                    },

                    ManageLink: `https://discord.com/channels/${guild.id}/${eventManageChannel.id}`,
                    Owner: member.id,
                    Created: Date.now () / 1000,
                    Event: eventOfCategory,
                    Online: [],

                    message: {

                        record: recordMessage,
                        manage: manageMessage,
                        log: logMessage,
                        announcement: false

                    }

                };

                guilds[eventVoiceChannel.id] = {

                    id: EventId

                };
                

                const collectorConponentsOfRecordChannel = await eventRecordChannel.createMessageComponentCollector();
                collectorConponentsOfRecordChannel.on('collect', async i => {

                    let eventOwner = await guild.members.fetch(guilds[EventId].Owner).catch(() => {});

                    switch (i.customId) { 

                        case 'handOver': {

                            if (!parameters.handOver) 
                            return i.reply({
                                ephemeral: true,  
                                embeds: [
                                    {
                                        title: `${client.user.username} error`,
                                        color: appearance.embed.errorColor,
                                        description: `${i.member}, мероприятие **невозможно** забрать`,
                                        thumbnail: { url: await getAvatar(i.member) }
                                    }
                                ],
                                components: [

                                ]
                            });

                            if (guilds[EventId].Owner == i.member.id) 
                            return i.reply({
                                ephemeral: true,
                                embeds: [
                                    {
                                        title: `${client.user.username} error`,
                                        color: appearance.embed.errorColor,
                                        description: `${i.member}, Вы **не можете** забрать данное мероприятие **${guilds[EventId].Event.name}**, повторите попытку **позже**`,
                                        thumbnail: { url: await getAvatar(i.member) }
                                    }
                                ], 
                                components: [ 
                        
                                ]
                            }).catch(() => {});

                            let rolesTxt = '';
                            let memberIfRole = false;
                            const memberRoles = i.member._roles;
                        
                            for (let a = 0; a < memberRoles.length; a++) if(appearance.roles.Events.access.includes(memberRoles[a])) memberIfRole = true;
                            for (let a = 0; a < appearance.roles.Events.access.length; a++) rolesTxt += ` <@&${appearance.roles.Events.access[a]}>`;

                            if (!memberIfRole) 
                            return i.reply({
                                ephemeral: true,  
                                embeds: [
                                    {
                                        title: `${i.client.user.username} error`,
                                        color: appearance.embed.errorColor,
                                        description: `${i.member}, у Вас **нет** доступа, точнее **необходимых** ролей:${rolesTxt}`,                          
                                        thumbnail: { url: await getAvatar (i.member) } 
                                    }
                                ]
                            }).catch(() => {});

                            
                            eventVoiceChannel.permissionOverwrites.edit(guilds[EventId].Owner, { MuteMembers: false, MoveMembers: false }).catch(() => {});
                            eventVoiceChannel.permissionOverwrites.edit(i.member.id, { MuteMembers: true, MoveMembers: true }).catch(() => {});
                            eventManageChannel.permissionOverwrites.edit(guilds[EventId].Owner, { ViewChannel: false, SendMessages: false }).catch(() => {});
                            eventManageChannel.permissionOverwrites.edit(i.member.id, { ViewChannel: true, SendMessages: false }).catch(() => {});
                            eventRecordChannel.permissionOverwrites.edit(guilds[EventId].Owner, { ManageMessages: false, SendMessages: false }).catch(() => {});
                            eventRecordChannel.permissionOverwrites.edit(i.member.id, { ViewChannel: true, ManageMessages: true, SendMessages: true }).catch(() => {});

                            
                            const eventCategory = await guild.channels.fetch(guilds[EventId].channels.category).catch(() => {});
                            if (eventCategory) eventCategory.setName(`${eventOfCategory.name}・${i.member.displayName}`);

                            parameters.handOver = false;
                            users[guilds[EventId].Owner].ActiveEvent = false;
                            users[i.member.id].ActiveEvent = EventId;
                            guilds[EventId].Owner = i.member.id;
                            
                            if (guilds[EventId].message.log) {

                                const channelOfLog = await guild.channels.fetch(guilds[EventId].message.log.channelId);
                                const messageOfChannelLog = await channelOfLog.messages.fetch(guilds[EventId].message.log.id);

                                if (messageOfChannelLog) messageOfChannelLog.reply({  
                                    content: `<t:${Math.floor(Date.now()/1000)}:f>`,
                                    embeds: [
                                        {
                                            author: { name: 'Мероприятие передано' },
                                            title: `${client.user.username + ' logs'}`,
                                            color: appearance.embed.color,
                                            fields: [
                                                {
                                                    name: `${appearance.embed.dot || appearance.emoji.Dot}Старый ведущий:`,
                                                    value: `・${eventOwner}\n・${eventOwner.id}`,  
                                                    inline: true
                                                },
                                                {
                                                    name: `${appearance.embed.dot || appearance.emoji.Dot}Новый ведущий:`,
                                                    value: `・${i.member}\n・${i.member.id}`,  
                                                    inline: true
                                                },
                                                {
                                                    name: `${appearance.embed.dot || appearance.emoji.Dot}Передал:`,
                                                    value: `・${i.member}\n・${i.member.id}`,  
                                                    inline: false
                                                },
                                                {
                                                    name: `${appearance.embed.dot || appearance.emoji.Dot}Канал:`,
                                                    value: `・${eventVoiceChannel ? eventVoiceChannel : 'Отсутствует'}\n・${eventVoiceChannel ? eventVoiceChannel.id : 'Отсутствует'}`,  
                                                    inline: true
                                                },
                                                {
                                                    name: `${appearance.embed.dot || appearance.emoji.Dot}Мероприятие:`,
                                                    value: `\`\`\`${eventOfCategory.name}\`\`\``,
                                                    inline: true
                                                }
                                            ],
                                            thumbnail: i.member ? { url: await getAvatar(i.member) } : {},
                                        }
                                    ],
                                    components: [
                                        
                                    ]
                                }).catch(() => {});
    
                            };

                            manageMessage.edit({  
                                components: [
                                    {
                                        type: 1,
                                        components: [
                                            {
                                                type: 3,
                                                customId: 'typeSelectSbor', 
                                                placeholder: 'Настройка сбора стола', 
                                                minValues: 0, 
                                                maxValues: 2, 
                                                options: [
                                                    {
                                                        label: 'Можно забрать',      
                                                        emoji: appearance.emoji.HandOver,     
                                                        description: `Любой ведущий может забрать ваше мероприятие`,
                                                        value: 'handOver',
                                                        default: parameters.handOver
                                                    },
                                                    {
                                                        label: 'Автосбор',                       
                                                        emoji: appearance.emoji.Autosbor,     
                                                        description: `Автоматический пинг роли уведомления на мафию`,
                                                        value: 'autosbor' ,
                                                        default: parameters.autosbor
                                                    },
                                                    {
                                                        label: 'Остановить запись',         
                                                        description: `Запрещает записываться/выписываться из записи на игру`,
                                                        value: 'stop'
                                                    }
                                                ]
                                            }
                                        ]
                                    },
                                    {
                                        type: 1,
                                        components: [
                                            {
                                                type: 2, 
                                                style: appearance.buttons_menu.Default.style, 
                                                customId: 'announcement', 
                                                emoji: appearance.emoji.Announcement,
                                                disabled: parameters.announcement
                                            },
                                            {
                                                type: 2, 
                                                style: appearance.buttons_menu.Default.style, 
                                                customId: 'start', 
                                                emoji: appearance.emoji.Start
                                            },
                                            {
                                                type: 2, 
                                                style: appearance.buttons_menu.Default.style, 
                                                customId: 'kick', 
                                                emoji: appearance.emoji.UserBlock
                                            },
                                            {
                                                type: 2, 
                                                style: appearance.buttons_menu.Default.style, 
                                                customId: 'delete', 
                                                emoji: appearance.emoji.Delete
                                            }
                                        ]
                                    }
                                ]
                            }).catch(() => {});

                            i.reply({
                                ephemeral: true,  
                                embeds: [
                                    {
                                        title: `Управление: ${eventOfCategory.name}`,
                                        color: appearance.embed.color,
                                        description: `${i.member}, Вы **успешно** забрали мероприятие пользователя ${eventOwner} **${eventOfCategory.name}**`,
                                        thumbnail: { url: await getAvatar(i.member) }
                                    }
                                ],
                                components: [

                                ]
                            });
                            
                            parameters.handOverMsg.delete().catch(() => {});
                            parameters.handOverMsg = false;
                            recordMessage.edit(await updateRecordMessage ());

                            break;

                        }

                        case 'info': {

                            let roleDesc = '';
                        
                            if (eventOfCategory.game.role.access) {

                                for (const pickRole in eventOfCategory.game.role.list) {
    
                                    roleDesc += `**${eventOfCategory.game.role.list[pickRole].emoji} ${pickRole}**\n・${eventOfCategory.game.role.list[pickRole].description || 'Остутствует'}\n\n`;
        
                                };

                            };


                            i.reply({
                                ephemeral: true,  
                                embeds: [
                                    {
                                        title: `Информация: ${eventOfCategory.name}`,
                                        color: appearance.embed.color,
                                        description: `${appearance.emoji.Info} ${eventOfCategory.embed.info.description ? eventOfCategory.embed.info.description : 'Отсутствует'}\n\n${roleDesc}`,
                                    }
                                ],
                                components: [

                                ]
                            });

                        }

                        default: {
            
                            if (actions[i.customId] && actions[i.customId].all == false) await actions[i.customId].actions[0](i);
            
                            break;
            
                        }
                    
                    };

                });


                function getNumber (number) {

                    let numberOfConfig = appearance.emoji.NumbersOfMafia[number];
                    if (numberOfConfig) return `${numberOfConfig}`;
                    else `**\`${number}\`**`;

                }; 

                async function announcementMessageSend (One, Two, Three, Four) {

                    const eventOwnerAvatar = await getAvatar(Two);

                    let fields = [
                        {
                            name: 'Игроки',
                            value: Four,
                            inline: true
                        }
                    ];

                    for (const pickReward in eventOfCategory.rewards) {

                        fields.push(
                            {
                                name: `${pickReward}`,
                                value: `${eventOfCategory.rewards[pickReward].reward} ${appearance.emoji.Coin}`,
                                inline: true
                            }
                        );

                    };

                    if (!fields[0]) {

                        fields.push(
                            {
                                name: `Награды за мероприятие`,
                                value: 'Отсутствуют',
                                inline: true
                            }
                        );

                    };

                    let contentPingRoles = '';
                    for (let role in appearance.roles.Mafia.notification) {

                        const roleFetch = await guild.roles.fetch(appearance.roles.Mafia.notification[role]).catch(() => {});
                        if (roleFetch && contentPingRoles == '') contentPingRoles += `${roleFetch}`;
                        else if (roleFetch && contentPingRoles !== '') contentPingRoles += `, ${roleFetch}`;

                    };
                    
                    return {

                        content: contentPingRoles == '' ? ' ' : contentPingRoles,
                        embeds: [
                            {
                                title: `Мероприятие: ${One}`,
                                color: appearance.embed.color,
                                description: `\`\`\`${eventOfCategory.miniDescription ? eventOfCategory.miniDescription : 'Отсутствует'}\`\`\``,
                                fields: fields,
                                image: { url: eventOfCategory.embed.info.image || appearance.custom.Events.default.nullImage },
                                footer: { text: `・Ведущий: ${Two.displayName}`, icon_url: eventOwnerAvatar }
                            }
                        ], 
                        components: Three

                    };

                };

                async function errorNoEventsOwnerMessage (One) {

                    const pickMemberAvater = await getAvatar(One);

                    return {
                        ephemeral: true,
                        embeds: [
                            {
                                title: `${client.user.username} error`,
                                color: appearance.embed.errorColor,
                                description: `${One}, для того, чтобы **использовать** данную кнопку, Вам **необходимо** быть ведущим** данного** мероприятия`,
                                thumbnail: { url: pickMemberAvater }
                            }
                        ], 
                        components: [
                            
                        ]
                    };

                };
                

                const intervalOfPing = setInterval(async () => {

                    if (guilds[EventId].deleted) return clearInterval(intervalOfPing);
                    if (guilds[EventId].started) return clearInterval(intervalOfPing);

                    if (!parameters.pingTime) parameters.pingTime = 0;
                    if (!parameters.pingMessage) parameters.pingMessage = false;

                    let matchOfTimePing = eventOfCategory.record.ping.match(/^\d{1,99}(s|m|h|d|w)$/);
                    let timeOfPing = (+matchOfTimePing[0].slice(0,-1))*(matchOfTimePing[1]=='s'?1:matchOfTimePing[1]=='m'?60:matchOfTimePing[1]=='h'?60*60:matchOfTimePing[1]=='d'?60*60*24:matchOfTimePing[1]=='w'?60*60*24*7:0);
                    
                    if (Date.now()/1000 - parameters.pingTime >= timeOfPing && parameters.autosbor) {

                        if (parameters.pingMessage) parameters.pingMessage.delete().catch(() => {});
                        if ((eventOfCategory.record.minMembers - parameters.memberInEvent.length < 0 ? 0 : eventOfCategory.record.minMembers - parameters.memberInEvent.length) !== 0) {
                            
                            let contentPingRoles = '';
                            for (let role in appearance.roles.Mafia.notification) {

                                const roleFetch = await guild.roles.fetch(appearance.roles.Mafia.notification[role]).catch(() => {});
                                if (roleFetch && contentPingRoles == '') contentPingRoles += `${roleFetch}`;
                                else if (roleFetch && contentPingRoles !== '') contentPingRoles += `, ${roleFetch}`;

                            };
                            
                            parameters.pingMessage = await eventRecordChannel.send(`${contentPingRoles == '' ? ' ' : contentPingRoles} +**${eventOfCategory.record.minMembers - parameters.memberInEvent.length < 0 ? 0 : eventOfCategory.record.minMembers - parameters.memberInEvent.length}** на мероприятие **${eventOfCategory.name}**`)
                            parameters.pingTime = Date.now()/1000;

                        };

                    };
                    
                }, 2000);

                client.on('interactionCreate', async i => {
            
                    if (!i.isModalSubmit()) return;
            
                    if (!i.member || i.member.id !== member.id) return;
                    if (i.message.id !== manageMessage.id) return;
            
                    lastInt = Date.now() / 1000;
            
                    switch (i.customId) {  
                        
                        default: {
            
                            if (actions[i.customId] && actions[i.customId].all == false) return await actions[i.customId].actions[0](i);
            
                        }
            
                    };
            
                });

                const collectorConponentsOfEventManageChannel = await eventManageChannel.createMessageComponentCollector();
                collectorConponentsOfEventManageChannel.on('collect', async i => {
                    
                    const iMemberAvatar = await getAvatar(i.member);
                    let eventOwner = await guild.members.fetch(guilds[EventId].Owner).catch(() => {});

                    switch (i.customId) { 
            
                        case 'typeSelectSbor': { 

                            if (guilds[EventId].Owner !== i.member.id) return i.reply(await errorNoEventsOwnerMessage (i.member));

                            if (i.values.includes('handOver')) {

                                parameters.handOver = true;
                                if (parameters.handOverMsg == false) {
                                    
                                    parameters.handOverMsg = await eventRecordChannel.send({
                                        content: `<t:${Math.floor(Date.now()/1000)}:f>`,
                                        embeds: [
                                            {
                                                color: appearance.embed.color,
                                                description: `Мероприятие [**${eventOfCategory.emoji}・${eventOfCategory.name}**](https://discord.com/channels/${guild.id}/${eventRecordChannel.id}) ${eventOwner} можно **забрать**\n-# Чтобы это сделать, **нажмите** кнопку под этим сообщение`,
                                            }
                                        ],
                                        components: [
                                            {
                                                type: 1,
                                                components: [
                                                    {
                                                        type: 2, 
                                                        style: 1, 
                                                        customId: 'handOver', 
                                                        label: `Забрать мероприятие ${eventOfCategory.name}`
                                                    }
                                                ]
                                            }
                                        ]
                                    }).catch(() => {});

                                };

                            }

                            else {

                                parameters.handOver = false;
                                if (parameters.handOverMsg !== false) parameters.handOverMsg.delete().catch(() => {});
                                else parameters.handOverMsg = false; 

                                parameters.handOverMsg = false; 

                            };

                            if (i.values.includes('autosbor')) parameters.autosbor = true;
                            else parameters.autosbor = false;

                            await i.update({ 
                                components: [
                                    {
                                        type: 1,
                                        components: [
                                            {
                                                type: 3,
                                                customId: 'typeSelectSbor', 
                                                placeholder: 'Настройка сбора стола', 
                                                minValues: 0, 
                                                maxValues: 2, 
                                                options: [
                                                    {
                                                        label: 'Можно забрать',      
                                                        emoji: appearance.emoji.HandOver,     
                                                        description: `Любой ведущий может забрать ваше мероприятие`,
                                                        value: 'handOver',
                                                        default: parameters.handOver
                                                    },
                                                    {
                                                        label: 'Автосбор',                       
                                                        emoji: appearance.emoji.Autosbor,     
                                                        description: `Автоматический пинг роли уведомления на мафию`,
                                                        value: 'autosbor' ,
                                                        default: parameters.autosbor
                                                    },
                                                    {
                                                        label: 'Остановить запись',         
                                                        description: `Запрещает записываться/выписываться из записи на игру`,
                                                        value: 'stop'
                                                    }
                                                ]
                                            }
                                        ]
                                    },
                                    {
                                        type: 1,
                                        components: [
                                            {
                                                type: 2, 
                                                style: appearance.buttons_menu.Default.style, 
                                                customId: 'announcement', 
                                                emoji: appearance.emoji.Announcement,
                                                disabled: parameters.announcement
                                            },
                                            {
                                                type: 2, 
                                                style: appearance.buttons_menu.Default.style, 
                                                customId: 'start', 
                                                emoji: appearance.emoji.Start
                                            },
                                            {
                                                type: 2, 
                                                style: appearance.buttons_menu.Default.style, 
                                                customId: 'kick', 
                                                emoji: appearance.emoji.UserBlock
                                            },
                                            {
                                                type: 2, 
                                                style: appearance.buttons_menu.Default.style, 
                                                customId: 'delete', 
                                                emoji: appearance.emoji.Delete
                                            }
                                        ]
                                    }
                                ]
                            });

                            break;

                        }

                        case 'announcement': { 

                            parameters.announcement = true
                            if (guilds[EventId].Owner !== i.member.id) return i.reply(await errorNoEventsOwnerMessage (i.member));

                            manageMessage.components.forEach(component => {

                                let Comp = component.components;
                
                                for (c = 0; c < Comp.length; c++) {
                
                                    if (Comp[c].data.custom_id == 'announcement') Comp[c].data.disabled = true;
                
                                };
                                
                            });

                            await manageMessage.edit({ components: manageMessage.components });

                            const announcementChannels = await client.channels.fetch(appearance.channels.Announcement).catch(() => {});

                            i.reply({  
                                ephemeral: true,
                                embeds: [
                                    {
                                        title: `Управление: ${eventOfCategory.name}`,
                                        color: appearance.embed.color,
                                        description: `${i.member}, Вы **успешно** анонсировали **данное **мероприятие, сообщение **было отправлено** в ${announcementChannels}`,
                                        thumbnail: { url: iMemberAvatar }
                                    }
                                ],
                                components: [

                                ]
                            }).catch(() => {});

        
                            if (announcementChannels) {

                                const goToVoice = [
                                    {
                                        type: 1,
                                        components: [
                                            {
                                                type: 2, 
                                                label: 'Записаться на мероприятие', 
                                                url: `https://discord.com/channels/${eventRecordChannel.guild.id}/${eventRecordChannel.id}`,
                                                style: 5
                                            }
                                        ]
                                    }
                                ];

                                const announcementMessage = await announcementChannels.send(await announcementMessageSend (eventOfCategory.name, i.member, goToVoice, `${parameters.memberInEvent.length} из ${eventOfCategory.record.maxMembers}`));
                                parameters.announcementMessage = announcementMessage;
                                
                                guilds[EventId].message.announcement = announcementMessage;

                            };

                            break;

                        }

                        case 'kick': { 

                            if (guilds[EventId].Owner !== i.member.id) return i.reply(await errorNoEventsOwnerMessage (i.member));

                            i.reply({  
                                ephemeral: true,  
                                embeds: [
                                    {
                                        title: `Управление: ${eventOfCategory.name}`,
                                        color: appearance.embed.color,
                                        description: `${member}, выберите **пользователя**, у которого Вы **хотите** удалить из записи мероприятия **${eventOfCategory.name}**`,
                                        thumbnail: { url: iMemberAvatar }
                                    }
                                ],
                                components: [

                                    menuUser ('pickMemberKick', '', '', true)

                                ]
                            }).catch(() => {});

                            
                            const pickMemberKick = (async (newI) => {

                                if (guilds[EventId].Owner !== newI.member.id) return newI.update(await errorNoEventsOwnerMessage (newI.member));
                
                                const pickMember = await guild.members.fetch(newI.values[0]).catch(() => {});

                                if (parameters.started) 
                                return newI.update({
                                    ephemeral: true,  
                                    embeds: [
                                        {
                                            title: `${client.user.username} error`,
                                            color: appearance.embed.errorColor,
                                            description: `${newI.member}, Вы **уже запустили** данное мероприятие`,
                                            thumbnail: { url: iMemberAvatar }
                                        }
                                    ],
                                    components: [

                                    ]
                                });

                                if (parameters.memberInEvent.includes(pickMember.id)) {

                                    for (const position in parameters.position) parameters.position[position] = parameters.position[position].filter((n) => { return n != pickMember.id });
                                    parameters.memberInEvent = parameters.memberInEvent.filter((n) => { return n != pickMember.id });

                                    newI.update({
                                        ephemeral: true,  
                                        embeds: [
                                            {
                                                title: `Управление: ${eventOfCategory.name}`,
                                                color: appearance.embed.color,
                                                description: `${newI.member}, Вы **успешно** удалили **пользователю** ${pickMember} из записи **${eventOfCategory.name}** (${eventRecordChannel})`,
                                                thumbnail: { url: iMemberAvatar }
                                            }
                                        ],
                                        components: [

                                        ]
                                    });

                                    return await recordMessage.edit(await updateRecordMessage ());

                                } 
                    
                                else {

                                    newI.update({
                                        ephemeral: true,  
                                        embeds: [
                                            {
                                                title: `${client.user.username} error`,
                                                color: appearance.embed.errorColor,
                                                description: `${newI.member}, ${pickMember} отсутствует **в записи** мероприятия **${eventOfCategory.name}** (${eventRecordChannel})`,
                                                thumbnail: { url: iMemberAvatar }
                                            }
                                        ],
                                        components: [

                                        ]
                                    });

                                };


                            });

                            actions['pickMemberKick'] = {
                                actions: [pickMemberKick],
                                all: false
                            };

                            break;

                        }

                        case 'delete': { 

                            if (guilds[EventId].Owner !== i.member.id) return i.reply(await errorNoEventsOwnerMessage (i.member));

                            i.reply({  
                                ephemeral: true,  
                                embeds: [
                                    {
                                        title: `Управление: ${eventOfCategory.name}`,
                                        color: appearance.embed.color,
                                        description: `${i.member}, Вы **уверены** что хотите **завершить** мероприятие? Если **да**, тогда **нажмите** на кнопку под этим сообщением`,
                                        thumbnail: { url: iMemberAvatar }
                                    }
                                ],
                                components: [
                                    {
                                        type: 1,
                                        components: [
                                            {
                                                type: 2, 
                                                style: appearance.buttons_menu.Default.style,
                                                customId: 'yesDelete', 
                                                label: 'Завершить мероприятие'
                                            }
                                        ]
                                    }
                                ]
                            }).catch(() => {});

                            
                            const yesDelete = (async (newI) => {

                                if (guilds[EventId].Owner !== newI.member.id) return newI.update(await errorNoEventsOwnerMessage (newI.member));
                
                                if (parameters.started) {
                                    
                                    guilds[EventId].deleted = true;
                                    newI.update({  
                                        ephemeral: true,  
                                        embeds: [],
                                        components: [
                                            {
                                                type: 1,
                                                components: [
                                                    {
                                                        type: 2, 
                                                        style: appearance.buttons_menu.Default.style,
                                                        customId: 'yesDelete', 
                                                        label: 'Завершить мероприятие',
                                                        disabled: true
                                                    }
                                                ]
                                            }
                                        ]
                                    }).catch(() => {});

                                    manageMessage.delete().catch(() => {});
                                    
                                    let pick = 0;
                                    let pick2 = 0;
                                    let channelsEvent = [eventVoiceChannel, eventRecordChannel, eventManageChannel, eventCategory];
                                    let newChannelsEvent = parameters.newChannels;
                                    let ti1 = setInterval(async () => {

                                        if (pick == channelsEvent.length) return clearInterval(ti1);
                                        channelsEvent[pick].delete().catch(() => {});
                                        pick++;

                                    }, 1000);

                                    let ti2 = setInterval(async () => {

                                        if (pick2 == newChannelsEvent.length) return clearInterval(ti2);
                                        newChannelsEvent[pick2].delete().catch(() => {});
                                        pick2++;

                                    }, 1000);


                                    logMessage.edit({  
                                        embeds: [
                                            {
                                                author: { name: 'Мероприятие завершено' },
                                                title: `${client.user.username + ' logs'}`,
                                                color: appearance.embed.color,
                                                description: `Создано: <t:${Math.floor(guilds[EventId].Created)}:f>\nЗавершено: <t:${Math.floor(Date.now()/1000)}:f>`,
                                                fields: [
                                                    {
                                                        name: `${appearance.embed.dot || appearance.emoji.Dot}Завершил:`,
                                                        value: `・${member}\n・${member.id}`,  
                                                        inline: true
                                                    },
                                                    {
                                                        name: `${appearance.embed.dot || appearance.emoji.Dot}Мероприятие:`,
                                                        value: `\`\`\`${eventOfCategory.name}\`\`\``,
                                                        inline: true
                                                    }
                                                ],
                                                footer: { text: `・Ведущий: ${member.displayName}` },
                                                thumbnail: { url: memberAvatar },
                                            }
                                        ],
                                        components: [

                                        ]
                                    }).catch(() => {});


                                    users[guilds[EventId].Owner].Events.unshift(
                                        {
                
                                            EventId: EventId,
                                            Event: eventOfCategory,
                                            Ended: Date.now () / 1000,
                                            Created: guilds[EventId].Created,
                
                                            message: {

                                                log: logMessage,
                                                announcement: guilds[EventId].message.announcement
                
                                            }
                                            
                                        }
                                    );

                                    guilds[guild.id].Events.Active = guilds[guild.id].Events.Active.filter((n) => { return n != EventId });
                                    users[member.id].ActiveEvent = false;

                                    if (guilds[EventId].message.announcement) 
                                    guilds[EventId].message.announcement.edit({
                                        content: ' ',
                                        components: [
                                            {
                                                type: 1,
                                                components: [
                                                    {
                                                        type: 2, 
                                                        style: 5, 
                                                        label: 'Мероприятие окончено', 
                                                        url: `https://discord.gg/BneyWRqe`,
                                                        disabled: true 
                                                    }
                                                ]
                                            }
                                        ]
                                    }).catch(() => {});

                                }
                            
                                else {

                                    guilds[EventId].deleted = true;
                                    newI.update({  
                                        ephemeral: true,  
                                        embeds: [],
                                        components: [
                                            {
                                                type: 1,
                                                components: [
                                                    {
                                                        type: 2, 
                                                        style: appearance.buttons_menu.Default.style,
                                                        customId: 'yesDelete', 
                                                        label: 'Завершить мероприятие',
                                                        disabled: true
                                                    }
                                                ]
                                            }
                                        ]
                                    }).catch(() => {});

                                    manageMessage.delete().catch(() => {});

                                    
                                    let pick = 0;
                                    let channelsEvent = [eventVoiceChannel, eventRecordChannel, eventManageChannel, eventCategory];
                                    let ti1 = setInterval(async () => {

                                        if (pick == channelsEvent.length) return clearInterval(ti1);
                                        channelsEvent[pick].delete().catch(() => {});
                                        pick++;

                                    }, 1000);


                                    logMessage.edit({  
                                        embeds: [
                                            {
                                                author: { name: 'Мероприятие завершено' },
                                                title: `${client.user.username + ' logs'}`,
                                                color: appearance.embed.color,
                                                description: `Создано: <t:${Math.floor(guilds[EventId].Created)}:f>\nЗавершено: <t:${Math.floor(Date.now()/1000)}:f>`,
                                                fields: [
                                                    {
                                                        name: `${appearance.embed.dot || appearance.emoji.Dot}Завершил:`,
                                                        value: `・${member}\n・${member.id}`,  
                                                        inline: true
                                                    },
                                                    {
                                                        name: `${appearance.embed.dot || appearance.emoji.Dot}Мероприятие:`,
                                                        value: `\`\`\`${eventOfCategory.name}\`\`\``,
                                                        inline: true
                                                    }
                                                ],
                                                footer: { text: `・Ведущий: ${member.displayName}` },
                                                thumbnail: { url: memberAvatar },
                                            }
                                        ],
                                        components: [

                                        ]
                                    }).catch(() => {});


                                    users[guilds[EventId].Owner].Events.unshift(
                                        {
                
                                            EventId: EventId,
                                            Event: eventOfCategory,
                                            Ended: Date.now () / 1000,
                                            Created: guilds[EventId].Created,
                
                                            message: {

                                                log: logMessage,
                                                announcement: guilds[EventId].message.announcement
                
                                            }
                                            
                                        }
                                    );

                                    guilds[guild.id].Events.Active = guilds[guild.id].Events.Active.filter((n) => { return n != EventId });
                                    users[member.id].ActiveEvent = false;

                                    if (guilds[EventId].message.announcement) 
                                    guilds[EventId].message.announcement.edit({
                                        content: ' ',
                                        components: [
                                            {
                                                type: 1,
                                                components: [
                                                    {
                                                        type: 2, 
                                                        style: 5, 
                                                        label: 'Мероприятие окончено', 
                                                        url: `https://discord.gg/BneyWRqe`,
                                                        disabled: true 
                                                    }
                                                ]
                                            }
                                        ]
                                    }).catch(() => {});

                                };

                            });

                            actions['yesDelete'] = {
                                actions: [yesDelete],
                                all: false
                            };

                            break;

                        }

                        case 'start': { 

                            if (guilds[EventId].Owner !== i.member.id) return i.reply(await errorNoEventsOwnerMessage (i.member)).catch(() => {});
                            
                            if (parameters.memberInEvent.length < eventOfCategory.record.minMembers) 
                            return i.reply({
                                ephemeral: true,  
                                embeds: [
                                    {
                                        title: `${client.user.username} error`,
                                        color: appearance.embed.errorColor,
                                        description: `${i.member}, Вы **не можете** запустить мероприятие, до **минимального** кол-во участников необходимо еще **${eventOfCategory.record.minMembers - parameters.memberInEvent.length < 0 ? 0 : eventOfCategory.record.minMembers - parameters.memberInEvent.length}** игроков`,
                                        thumbnail: { url: iMemberAvatar }
                                    }
                                ],
                                components: [

                                ]
                            }).catch(() => {});


                            const match = eventOfCategory.game.lasts.examination.match(/^\d{1,99}(s|m|h|d|w)$/);
                            let examinationTime = (+match[0].slice(0,-1))*(match[1]=='s'?1:match[1]=='m'?60:match[1]=='h'?60*60:match[1]=='d'?60*60*24:match[1]=='w'?60*60*24*7:0);

                            const matchRepeat = eventOfCategory.game.lasts.examinationRepeat.match(/^\d{1,99}(s|m|h|d|w)$/);
                            const examinationTimeRepeat = (+matchRepeat[0].slice(0,-1))*(matchRepeat[1]=='s'?1:matchRepeat[1]=='m'?60:matchRepeat[1]=='h'?60*60:matchRepeat[1]=='d'?60*60*24:matchRepeat[1]=='w'?60*60*24*7:0);


                            async function mafiaStart () {
                                
                                async function startTrack (Text, Voice) {

                                    // const voiceChannel = await guild.members.me.voice.channel;

                                    // if (voiceChannel) {

                                    //     Text.send({
                                    //         embeds: [
                                    //             {
                                    //                 title: `${client.user.username} error`,
                                    //                 color: appearance.embed.errorColor,
                                    //                 description: `${client.user} **уже проигрывает** музыку в другом канале ${voiceChannel}`,
                                    //                 thumbnail: { url: await getAvatar(client.user) } 
                                    //             }
                                    //         ], 
                                    //         components: [ 
                                    
                                    //         ]
                                    //     }).catch(() => {});

                                    // }

                                    // else {

                                    //     const playList = ['https://www.youtube.com/embed/PkB5FLuYPJk'];
                                    //     const url = getArrayRandElement(playList);

                                        
                                    //     if (ytdl.validateURL(url)) {
                                
                                    //         const info = await ytdl.getInfo(url);
                                    //         console.log(info)
                                    //         const title = info.videoDetails.title;
    
                                    //         Text.send({
                                    //             embeds: [
                                    //                 {
                                    //                     author: {
                                    //                         name: bot.user.username,
                                    //                         icon_url: await getAvatar(bot.user)
                                    //                     },
                                    //                     title: title,
                                    //                     description: "От _Elton John_",
                                    //                     url: "https://discohook.org/?data=eyJtZXNzYWdlcyI6W3siZGF0YSI6eyJjb250ZW50IjpudWxsLCJlbWJlZHMiOlt7InRpdGxlIjoiVW5rbm93biB0aXRsZSIsImNvbG9yIjozMjI0Mzc2LCJhdXRob3IiOnsibmFtZSI6ImZkYXNzZGYiLCJ1cmwiOiJodHRwczovL2Rpc2NvaG9vay5vcmcvP2RhdGE9ZXlKdFpYTnpZV2RsY3lJNlczc2laR0YwWVNJNmV5SmpiMjUwWlc1MElqcHVkV3hzTENKbGJXSmxaSE1pT2x0N0ltTnZiRzl5SWpvek1qSTBNemMyTENKaGRYUm9iM0lpT25zaWJtRnRaU0k2SW1aa1lYTnpaR1lpZlgxZExDSmhkSFJoWTJodFpXNTBjeUk2VzExOWZWMTkiLCJpY29uX3VybCI6Imh0dHBzOi8vZGlzY29ob29rLm9yZy8_ZGF0YT1leUp0WlhOellXZGxjeUk2VzNzaVpHRjBZU0k2ZXlKamIyNTBaVzUwSWpwdWRXeHNMQ0psYldKbFpITWlPbHQ3SW1OdmJHOXlJam96TWpJME16YzJMQ0poZFhSb2IzSWlPbnNpYm1GdFpTSTZJbVprWVhOelpHWWlmWDFkTENKaGRIUmhZMmh0Wlc1MGN5STZXMTE5ZlYxOSJ9fV0sImF0dGFjaG1lbnRzIjpbXX19XX0",
                                    //                     fields: [
                                    //                         {
                                    //                             name: "Длительность трека",
                                    //                             value: "`4:15`",
                                    //                             inline: true
                                    //                         },
                                    //                         {
                                    //                             name: "Длительность трека",
                                    //                             value: "`4:15`",
                                    //                             inline: true
                                    //                         }
                                    //                     ],
                                    //                     color: appearance.embed.color,
                                    //                     thumbnail: { url: 'https://cdn.discordapp.com/attachments/1288110153526280273/1291832235108077682/uncheakOfMafia.png?size=64' } 
                                    //                 }
                                    //             ], 
                                    //             components: [ 
                                        
                                    //             ]
                                    //         }).catch(() => {});

                                    //     };

                                    //     // const connection = joinVoiceChannel({
                                    //     //     channelId: Voice.id,
                                    //     //     guildId: guild.id,
                                    //     //     adapterCreator: guild.voiceAdapterCreator, 
                                    //     //     selfDeaf: true
                                    //     // });

                                    //     // const audioPlayer = createAudioPlayer();
                                    //     // const audioResource = createAudioResource('./assets/music/mafia2.mp3');

                                    //     // audioPlayer.play(audioResource);
                                    //     // connection.subscribe(audioPlayer);

                                    // };

                                };

                                async function cancelTrack () {

                                    const connection = getVoiceConnection(guild.id);
                            
                                    if (connection) connection.destroy();
                                
                                };
                                
                                eventOwner = await guild.members.fetch(guilds[EventId].Owner).catch(() => {});

                                if (guilds[EventId].message.announcement) 
                                guilds[EventId].message.announcement.edit({
                                    content: ' ',
                                    components: [
                                        {
                                            type: 1,
                                            components: [
                                                {
                                                    type: 2, 
                                                    style: 5, 
                                                    label: 'Смотреть мероприятие', 
                                                    url: `https://discord.com/channels/${eventVoiceChannel.guild.id}/${eventVoiceChannel.id}`
                                                }
                                            ]
                                        }
                                    ]
                                }).catch(() => {});

                                await eventVoiceChannel.setName(eventOfCategory.channels.updateVoice).catch(() => {});
                                await eventRecordChannel.setName(appearance.custom.Mafia.channels.updateRecord).catch(() => {});
                                eventVoiceChannel.permissionOverwrites.edit(guild.id, { Speak: false }).catch(() => {});

                                eventOwner.setNickname('! Ведущий').catch(() => {});
                                eventVoiceChannel.members.forEach(member => {

                                    if (member.id == guilds[EventId].Owner) return;
                                    eventVoiceChannel.permissionOverwrites.edit(member.id, { Speak: false })
                                        .then(() => {
                                            member.voice.setChannel(eventVoiceChannel.id).catch(() => {});
                                        })
                                        .catch(() => {});

                                });

                                parameters.started = true;
                                guilds[EventId].started = true;
                                parameters.startedTime = Date.now()/1000;
                                
                                game = {

                                    timer: false,
                                    timerOfStopwatchStart: false,
                                    stopwatch: false,

                                    members: [],
                                    servers: [],
                                    confirmation: [],
                                    join: [],
                                    message: {

                                        roles: {},
                                        info: {}

                                    },

                                    punishment: {

                                        pick: false,
                                        list : false

                                    },

                                    actions: {

                                        day: 0

                                    },

                                    history: {

                                        vote: [],
                                        kill: [],
                                        lx: [],
                                        heal: [],

                                        cheack: []

                                    },

                                    vote: {

                                        members: [],
                                        vote: {}

                                    },

                                    time: 'start',
                                    ready: false
                                
                                };                                            
                                
                                const timeStart = Date.now() / 1000;
                                const matchConfirmation = eventOfCategory.game.lasts.confirmation.match(/^\d{1,99}(s|m|h|d|w)$/);
                                const examinationTimeConfirmation = (+matchConfirmation[0].slice(0,-1))*(matchConfirmation[1]=='s'?1:matchConfirmation[1]=='m'?60:matchConfirmation[1]=='h'?60*60:matchConfirmation[1]=='d'?60*60*24:matchConfirmation[1]=='w'?60*60*24*7:0);


                                for (const pickServer in eventOfCategory.game.servers) {

                                    const pickServerOfList = eventOfCategory.game.servers[pickServer];
                                    const createdGuild = await client.guilds.create(
                                        {
                                        name: pickServerOfList.name
                                        }
                                    ).catch(() => {});

                                    // let guildAvatar = await guild.iconURL({ dynamic: true, size: 512, format: 'png' });
                            
                                    // const Avatar = canvas.createCanvas(512, 512);
                                    // const context = Avatar.getContext('2d');
                                    // context.fillStyle = '#000000';
                                    // context.fillRect(0, 0, 512, 512);
                            
                            
                                    // if (guildAvatar) {
                            
                                    //     guildAvatar = guildAvatar.replace('.gif', '');
                                    //     guildAvatar = guildAvatar.replace('.webp', '');
                                    //     guildAvatar = guildAvatar + '.png';
                                    //     const imageAvatar = await canvas.loadImage(guildAvatar).catch(() => {});
                                    //     context.drawImage(imageAvatar, 0, 0, 512, 512);
                            
                                    // };

                                    // if (pickServerOfList.avatar) {

                                    //     const imageIdentification = await canvas.loadImage(pickServerOfList.avatar);
                                    //     context.drawImage(imageIdentification, 0, 0, 512, 512);

                                    // };

                                    // const avatar = Avatar.toBuffer();
                                    // const createdGuildFetch = await client.guilds.fetch(createdGuild.id).catch(() => {});
                                    // createdGuildFetch.setIcon(avatar).catch(() => {});

                                    for (const channel of createdGuild.channels.cache) channel[1].delete().catch(() => {});

                                    let roles = [];
                                    let channels = [];

                                    for (const pickRole in pickServerOfList.parameters.roles) {

                                        const pickRoleOfList = pickServerOfList.parameters.roles[pickRole];
                                        const createdRole = await createdGuild.roles.create(pickRoleOfList).catch(() => {});

                                        roles.push(
                                            {
                                                name: pickRoleOfList.name,
                                                role: createdRole
                                            }
                                        );

                                    };

                                    for (const pickChannel in pickServerOfList.parameters.channels) {

                                        const pickChannelOfList = pickServerOfList.parameters.channels[pickChannel];
                                        const createdChannel = await createdGuild.channels.create(pickChannelOfList.parameters).catch(() => {});

                                        for (const pickPermission in pickChannelOfList.permission) {

                                            if (pickPermission == game.time) {

                                                for (const pickPermissionOfTime in pickChannelOfList.permission[pickPermission]) {

                                                    if (pickChannelOfList.permission[pickPermission][pickPermissionOfTime].Role == 'everyone') createdChannel.permissionOverwrites.edit(createdGuild.id, pickChannelOfList.permission[pickPermission][pickPermissionOfTime].Permission).catch(() => {});
                                                    else {

                                                        const pickRoleFetch = roles.find(role => role.name == pickChannelOfList.permission[pickPermission][pickPermissionOfTime].Role);
                                                        createdChannel.permissionOverwrites.edit(pickRoleFetch.role.id, pickChannelOfList.permission[pickPermission][pickPermissionOfTime].Permission).catch(() => {});
                                                        
                                                    };

                                                };

                                            };

                                        };

                                        channels.push(
                                            {
                                                name: pickChannelOfList.parameters.name,
                                                channel: createdChannel,
                                                config: pickChannelOfList
                                            }
                                        );

                                    };

                                    game.servers.push(

                                        {
                                            
                                            guild: createdGuild,
                                            server: pickServerOfList,
                                            channels: channels,
                                            roles: roles,
                                            members: []

                                        }

                                    );

                                    client.on('guildMemberAdd', async memberOfServer => {

                                        const member = await createdGuild.members.fetch(memberOfServer.id).catch(() => {});

                                        let includesGame = false;
                                        if (!member || !member.guild || member.guild.id !== createdGuild.id) return;

                                        for (n=0; n < game.members.length; n++) {
                                            
                                            if (game.members[n].id == member.id) includesGame = game.members[n];

                                        };

                                        if (includesGame == false && member.id !== guilds[EventId].Owner) return member.kick('Отсутствие в обстоновке').catch(() => {});
                                        if (member.id == guilds[EventId].Owner) {
                                            
                                            member.setNickname('Ведущий').catch(() => {});

                                            setTimeout(() => {
                                                let pickRoleFetch = roles.find(role => role.name == 'Ведущий');
                                                setTimeout(() => {
                                                    member.roles.add(pickRoleFetch.role.id).catch(() => {});
                                                }, 600);
                                            }, 600);

                                            return;

                                        };

                                        let includesServer = false; 
                                        for (const pickServer in includesGame.role.servers) {
                                            
                                            if (includesGame.role.servers[pickServer].name == createdGuild.name) includesServer = true;

                                        };

                                        if (includesServer == false || !game.members.find(memberGame => memberGame.id == member.id).alive) return member.kick('Отсутствие в обстоновке').catch(() => {});

                                        for (const pickServer in includesGame.role.servers) {
                                            
                                            let pickServerOfRole = includesGame.role.servers[pickServer];
                                            if (includesGame.role.servers[pickServer].name == createdGuild.name) {

                                                for (const pickRole in pickServerOfRole.addRoles) {

                                                    setTimeout(() => {
                                                        let pickRoleFetch = roles.find(role => role.name == pickServerOfRole.addRoles[pickRole]);
                                                        setTimeout(() => {
                                                            member.roles.add(pickRoleFetch.role.id).catch(() => {});
                                                        }, 600);
                                                    }, 600);

                                                };

                                                member.setNickname(includesGame.number).catch(() => {});


                                            };

                                        };
                                
                                    });

                                };

                                
                                let tempMemberInEvent = [];
                                let randomMemberInEvent = [];
                                let membersOfT = 0;

                                for (const pickMember in parameters.memberInEvent) if (tempMemberInEvent.length < eventOfCategory.record.maxMembers) tempMemberInEvent.push(parameters.memberInEvent[pickMember]);
                                for (const pickMember in tempMemberInEvent) {

                                    const randomMember = await getArrayRandElement (tempMemberInEvent);
                                    tempMemberInEvent = tempMemberInEvent.filter((n) => { return n != randomMember });
                                    randomMemberInEvent.push(randomMember);

                                };

                                membersOfT = randomMemberInEvent.length;


                                // game.message.info = await eventRecordChannel.send({  
                                //     components: [
                                //         {
                                //             type: 1,
                                //             components: [
                                //                 {
                                //                     type: 2, 
                                //                     style: appearance.buttons_menu.Default.style, 
                                //                     customId: 'start', 
                                //                     label: 'Автоматически'
                                //                 },
                                //                 {
                                //                     type: 2, 
                                //                     style: appearance.buttons_menu.Default.style, 
                                //                     customId: 'kick', 
                                //                     label: 'Выбор игроков'
                                //                 }
                                //             ]
                                //         }
                                //     ]
                                // }).catch(() => {});


                                let timeout = 5000;
                                if (eventOfCategory.game.role.access) {

                                    let gameRoleList = [];
                                    for (const pickRole in eventOfCategory.game.role.list) {

                                        for (i = 0; i < eventOfCategory.game.role.list[pickRole].maxMembers; i++) {

                                            gameRoleList.push(
                                                {
                                                    number: i,
                                                    role: eventOfCategory.game.role.list[pickRole]
                                                }
                                            );      

                                        };
            
                                    };


                                    for (const pickMember in randomMemberInEvent) {

                                        const fetchPickMember = await guild.members.fetch(randomMemberInEvent[pickMember]).catch(() => {});

                                        let pickMemberNumber = Number(pickMember) + 1;
                                        if (pickMemberNumber < 10) pickMemberNumber = `0${pickMemberNumber}`;
                                        
                                        const randomRole = await getArrayRandElement (gameRoleList);
                                        gameRoleList = gameRoleList.filter((n) => { return n != randomRole });

                                        game.members.push(

                                            {
                                                
                                                number: pickMemberNumber,
                                                id: fetchPickMember.id,
                                                role: randomRole.role,
                                                nickName: fetchPickMember.displayName,
                                                confirmation: false,
                                                punishment: {},
                                                alive: true

                                            }

                                        );

                                        let componets = [];
                                        let memberOfServers = false;

                                        if (randomRole.role.confirmation) {

                                            if (!componets[0] || componets[componets.length-1].components.length == 5) 
                                            componets.push(
                                                {
                                                    type: 1,
                                                    components: []
                                                }
                                            );

                                            componets[componets.length-1].components.push(
                                                {
                                                    type: 2, 
                                                    style: appearance.buttons_menu.Default.style, 
                                                    label: 'Я увидел свою роль',
                                                    customId: 'confirmation'
                                                }
                                            );


                                        };

                                        if (randomRole.role.servers[0]) {

                                            for (i=0; i < randomRole.role.servers.length; i++) {
                                            
                                                if (!componets[0] || componets[componets.length-1].components.length == 5) 
                                                componets.push(
                                                    {
                                                        type: 1,
                                                        components: []
                                                    }
                                                );
                                                
                                                
                                                for (n=0; n < game.servers.length; n++) {

                                                    let randomChannel = {};
                                                    for (const channel of game.servers[n].guild.channels.cache) randomChannel = await game.servers[n].guild.channels.fetch(channel[0]);

                                                    const inviteOfRandomChannel = await randomChannel.createInvite();
                                                    if (randomRole.role.servers[i].name == game.servers[n].server.name) {

                                                        memberOfServers = true;
                                                        componets[componets.length-1].components.push(
                                                            {
                                                                type: 2, 
                                                                label: `Перейти на сервер: ${game.servers[n].server.name}`, 
                                                                url: inviteOfRandomChannel.url,
                                                                style: 5
                                                            }
                                                        );

                                                    };

                                                };

                                            };

                                        };

                                        if (fetchPickMember && fetchPickMember.id) {

                                            setTimeout(async () => {

                                                fetchPickMember.setNickname(pickMemberNumber).catch(() => {});

                                                if (guilds[EventId].deleted) return;

                                                let teamMembers = '';
                                                for (const pickTeams in eventOfCategory.game.teams) {
    
                                                    if (eventOfCategory.game.teams[pickTeams].roles.includes(randomRole.role.name)) {
    
                                                        for (const pickMember in game.members) {
                                                            
                                                            const fetchPickMember = game.members[pickMember];
                                                            if(eventOfCategory.game.teams[pickTeams].roles.includes(fetchPickMember.role.name)) teamMembers += `${getNumber (fetchPickMember.number)} ${fetchPickMember.role.emoji} <@${fetchPickMember.id}>\n`;
                                                            
                                                        };
    
                                                    };
    
                                                };

                                                await checkingForAvailability (db, fetchPickMember);

                                                const fetchPickMemberMessage = await fetchPickMember.send({  
                                                    embeds: 
                                                    randomRole.role.showTeam ? 
                                                    [
                                                        {
                                                            title: `Роль: ${eventOfCategory.name}`,
                                                            color: appearance.embed.color,
                                                            description: `Игровой номер: ${getNumber(pickMemberNumber)}\nРоль: ${randomRole.role.emoji} **${randomRole.role.name}**\n${randomRole.role.confirmation ? `\nНажмите на кнопку под сообщением` : ''}${memberOfServers ? `\nЗайдите на сервер по кнопке ниже` : ''}${!randomRole.role.confirmation && !memberOfServers ? '' : `\n-# Если вы не подтвердите свою активную роль или\n-# не зайдёте на сервер, то **<t:${Math.floor(timeStart+examinationTimeConfirmation)}:R>** вы получите наказание`}`,
                                                            thumbnail: { url: await getAvatar(fetchPickMember) }
                                                        },
                                                        {
                                                            title: `Команда: ${eventOfCategory.name}`,
                                                            color: appearance.embed.color,
                                                            description: `${teamMembers}`,
                                                        }
                                                    ]
                                                    :
                                                    [
                                                        {
                                                            title: `Роль: ${eventOfCategory.name}`,
                                                            color: appearance.embed.color,
                                                            description: `Игровой номер: ${getNumber(pickMemberNumber)}\nРоль: ${randomRole.role.emoji} **${randomRole.role.name}**\n${randomRole.role.confirmation ? `\nНажмите на кнопку под сообщением` : ''}${memberOfServers ? `\nЗайдите на сервер по кнопке ниже` : ''}${!randomRole.role.confirmation && !memberOfServers ? '' : `\n-# Если вы не подтвердите свою активную роль или\n-# не зайдёте на сервер, то **<t:${Math.floor(timeStart+examinationTimeConfirmation)}:R>** вы получите наказание`}`,
                                                            thumbnail: { url: await getAvatar(fetchPickMember) }
                                                        }
                                                    ],
                                                    components: componets
                                                }).catch(() => {});


                                                if (!fetchPickMemberMessage) eventOwner.send({  
                                                    embeds: [
                                                        {
                                                            title: `Раздача ролей: ${eventOfCategory.name}`,
                                                            color: appearance.embed.color,
                                                            description: `## У **${pickMemberNumber}** ${fetchPickMember} **\`закрыты личные сообщения\`**\nРоль: ${randomRole.role.emoji} **${randomRole.role.name}**\n\nСообщите пользователю о его роли и попросите **открыть** сообщения\n-# Если у него **активная** роль, то она подтвержена`,
                                                            thumbnail: { url: await getAvatar(fetchPickMember) }
                                                        }
                                                    ]
                                                })
                                                    .then(() => {
                                                        if (randomRole.role.confirmation) {
    
                                                            for (i = 0; i < game.members.length; i++) {

                                                                if (game.members[i].id == fetchPickMember.id) game.members[i].confirmation = true;

                                                            };

                                                        };
                                                    })
                                                    .catch(() => {});

                                                else {

                                                    const collectorConponentsOfFetchPickMemberMessage = await fetchPickMemberMessage.createMessageComponentCollector();
                                                    collectorConponentsOfFetchPickMemberMessage.on('collect', async newI => {
                            
                                                        switch (newI.customId) { 
                            
                                                            case 'confirmation': {
    
                                                                if (guilds[EventId].deleted) {

                                                                    newI.update({
                                                                        componets: []
                                                                    }).catch(() => {});

                                                                };

                                                                componets = [];
                
                                                                if (randomRole.role.confirmation) {
                
                                                                    if (!componets[0] || componets[componets.length-1].components.length == 5) 
                                                                    componets.push(
                                                                        {
                                                                            type: 1,
                                                                            components: []
                                                                        }
                                                                    );
                
                                                                    componets[componets.length-1].components.push(
                                                                        {
                                                                            type: 2, 
                                                                            style: 3, 
                                                                            label: 'Я увидел свою роль',
                                                                            customId: 'confirmation', 
                                                                            disabled: true
                                                                        }
                                                                    );
                
                
                                                                };
                
                                                                if (randomRole.role.servers[0]) {
                
                                                                    for (i=0; i < randomRole.role.servers.length; i++) {
                                                                    
                                                                        if (!componets[0] || componets[componets.length-1].components.length == 5) 
                                                                        componets.push(
                                                                            {
                                                                                type: 1,
                                                                                components: []
                                                                            }
                                                                        );
                                                                        
                                                                        
                                                                        for (n=0; n < game.servers.length; n++) {
                
                                                                            let randomChannel = {};
                                                                            for (const channel of game.servers[n].guild.channels.cache) randomChannel = await game.servers[n].guild.channels.fetch(channel[0]);
                
                                                                            const inviteOfRandomChannel = await randomChannel.createInvite();
                                                                            if (randomRole.role.servers[i].name == game.servers[n].server.name) 
                                                                            componets[componets.length-1].components.push(
                                                                                {
                                                                                    type: 2, 
                                                                                    label: `Сервер: ${game.servers[n].server.name}`, 
                                                                                    url: inviteOfRandomChannel.url,
                                                                                    style: 5
                                                                                }
                                                                            );
                
                                                                        };
                
                                                                    };
                
                                                                };
    
                                                                for (i = 0; i < game.members.length; i++) {
    
                                                                    if (game.members[i].id == fetchPickMember.id) game.members[i].confirmation = true;
    
                                                                };
                            
                                                                newI.update({
                                                                    components: componets
                                                                }).catch(() => {});
                            
                                                            }
                                                        
                                                        };
                            
                                                    });

                                                };

                                            }, timeout);

                                            timeout += 1300;

                                        };
                                
                                    };

                                };

                                // let pickCards = [];
                                // function sdfasd () {
                                
                                //     for (const pickMember in game.vote.members) {
                                
                                //         if (game.vote.members[pickMember]) {
                                
                                //             const memeberOfVote = game.members.find(member => member.id == game.vote.members[pickMember].id);
                                //             if (memeberOfVote.alive == false) game.vote.members = game.vote.members.filter((n) => {return n != game.vote.members[pickMember]});
                                
                                //         };
                                
                                //     };
                                
                                //     let exhibitedText = '';
                                //     let componentsVote = [];
                                    
                                //     componentsVote.push(
                                //         {
                                //             type: 1,
                                //             components: []
                                //         }
                                //     );
                                
                                //     componentsVote[componentsVote.length-1].components.push(
                                //         {
                                //             type: 2, 
                                //             style: 1, 
                                //             customId: `random`,
                                //             label: `Вытянуть случайную карту`
                                //         }
                                //     );

                                
                                //     componentsVote.push(
                                //         {
                                //             type: 1,
                                //             components: []
                                //         }
                                //     );
                                
                                //     for (let i = 0; i < membersOfT; i++) {
                                            
                                //         if (!componentsVote[0] || componentsVote[componentsVote.length-1].components.length == 5) 
                                //         componentsVote.push(
                                //             {
                                //                 type: 1,
                                //                 components: []
                                //             }
                                //         );
                                
                                //         componentsVote[componentsVote.length-1].components.push(
                                //             {
                                //                 type: 2, 
                                //                 style: pickCards.includes(i) ? 3 : appearance.buttons_menu.Default.style, 
                                //                 customId: `pickCard${i}`,
                                //                 label: `${i}`, 
                                //                 disabled: false
                                //             }
                                //         );

                                //         const pickVoteutton = (async (newI) => {
                                
                                //         });
                                
                                //         actions[`vote${game.members[pickMember].number}`] = {
                                //             actions: [pickVoteutton],
                                //             all: false
                                //         };
                                
                                //     };
                                
                                //     return {
                                //         embeds: [
                                //             {
                                //                 color: appearance.embed.color,
                                //                 description: `# ${eventOfCategory.game.vote.emoji} ${eventOfCategory.game.vote.name}\nВыставлены: ${exhibitedText || 'Пусто'}`,
                                //                 // footer: { text: 'Выставляйте с помощью кнопок' }
                                //             }
                                //         ],
                                //         components: componentsVote
                                //     };
                                
                                // };

                                async function startGame () {

                                    if (guilds[EventId].deleted) return;
                                    eventOwner = await guild.members.fetch(guilds[EventId].Owner).catch(() => {});


                                    let rolesNoConfirmation = [];
                                    let contentOfMessageLeading = '';
                                    let componetsOfMessageLeading = [];

                                    async function sendEventOwnerRoles () {
    
                                        for (const pickMember in game.members) {
    
                                            const pickMemberOfGameMembers = game.members[pickMember];
                                            const fetchPickMember = await guild.members.fetch(pickMemberOfGameMembers.id).catch(() => {});
    
                                            confirmation = false;
                                            let confirmationOfRole = false;
                                            if (pickMemberOfGameMembers.role.confirmation) {
    
                                                confirmationOfRole = true;
    
                                                if (pickMemberOfGameMembers.confirmation) contentOfMessageLeading += appearance.emoji.Confirmation + ' ';
    
                                                else {
    
                                                    confirmation = true;
                                                    contentOfMessageLeading += appearance.emoji.NoConfirmation + ' ';
    
                                                };
    
    
                                            };
    
                                            if (pickMemberOfGameMembers.role.servers[0]) {
    
                                                confirmationOfRole = true;
    
                                                for (i=0; i < pickMemberOfGameMembers.role.servers.length; i++) {
    
                                                    if (pickMemberOfGameMembers.role.servers[i].join) {
        
                                                        for (n=0; n < game.servers.length; n++) {
    
                                                            game.servers[n].guild.members.fetch().catch(() => {});
                                                            const fetchPickMemberOfPickServer = await game.servers[n].guild.members.fetch(fetchPickMember.id).catch(() => {});
    
                                                            if (fetchPickMemberOfPickServer) contentOfMessageLeading += appearance.emoji.Confirmation + ' ';
    
                                                            else {
            
                                                                confirmation = true;
                                                                contentOfMessageLeading += appearance.emoji.NoConfirmation + ' ';
            
                                                            };
    
                                                        };
            
                                                    };
    
                                                };
    
                                            };
    
                                            if (confirmation && !rolesNoConfirmation.includes(`${pickMemberOfGameMembers.role.emoji} **${pickMemberOfGameMembers.role.name}**`)) rolesNoConfirmation.push(`${pickMemberOfGameMembers.role.emoji} **${pickMemberOfGameMembers.role.name}**`);
                                            
                                            if (!confirmationOfRole) contentOfMessageLeading += appearance.emoji.Null + ' ';
                                            contentOfMessageLeading += `${getNumber (pickMemberOfGameMembers.number)} ${pickMemberOfGameMembers.role.emoji} ${fetchPickMember}\n`;
                                            
                                        };
    
                                        for (n=0; n < game.servers.length; n++) {
    
                                            let randomChannel = {};
                                            for (const channel of game.servers[n].guild.channels.cache) randomChannel = await game.servers[n].guild.channels.fetch(channel[0]);
    
                                            if (!componetsOfMessageLeading[0] || componetsOfMessageLeading[componetsOfMessageLeading.length-1].components.length == 5) 
                                            componetsOfMessageLeading.push(
                                                {
                                                    type: 1,
                                                    components: []
                                                }
                                            );
    
                                            const inviteOfRandomChannel = await randomChannel.createInvite();
                                            componetsOfMessageLeading[componetsOfMessageLeading.length-1].components.push(
                                                {
                                                    type: 2, 
                                                    label: `Сервер: ${game.servers[n].guild.name}`, 
                                                    url: inviteOfRandomChannel.url,
                                                    style: 5
                                                }
                                            );
    
                                        };
    
                                        game.message.roles = await eventOwner.send({  
                                            embeds: [
                                                {
                                                    title: `Роли: ${eventOfCategory.name}`,
                                                    color: appearance.embed.color,
                                                    description: `${contentOfMessageLeading}`
                                                }
                                            ],
                                            components: componetsOfMessageLeading
                                        }).catch(() => {});

                                    };

                                    await sendEventOwnerRoles ();


                                    let textGame = '';
                                    let fieldsRole = [];
                                    infoEmbedsFields = [];
                                    let textRoleNoConfirmation = '';

                                    async function sendInfoMessage () {

                                        for (const pickMember in game.members) textGame += `${getNumber (game.members[pickMember].number)} <@${game.members[pickMember].id}>\n`;
    
                                        infoEmbedsFields.push(
                                            {
                                                name: `Игровая рассадка:`,
                                                value: `${textGame}`,
                                                inline: false
                                            }
                                        );
    
                                        if (eventOfCategory.game.role.access) {
    
                                            for (const pickRole in eventOfCategory.game.role.list) {
                
                                                fieldsRole.push(
                                                    {
                                                        name: ``,
                                                        value: `${eventOfCategory.game.role.list[pickRole].emoji} __**${eventOfCategory.game.role.list[pickRole].name}**__ — ${eventOfCategory.game.role.list[pickRole].description}`,
                                                        inline: false
                                                    }
                                                );
                    
                                            };
    
                                        };
    
                                        for (const pickRole in rolesNoConfirmation) {
            
                                            if (textRoleNoConfirmation == '') textRoleNoConfirmation += `${rolesNoConfirmation[pickRole]}`;
                                            else textRoleNoConfirmation += `, ${rolesNoConfirmation[pickRole]}`;
                
                                        };
                                        
                                        game.message.info = await eventRecordChannel.send({  
                                            embeds: [
                                                {
                                                    title: `Мероприятие: ${eventOfCategory.name}`,
                                                    color: appearance.embed.color,
                                                    description: `Игроков: **${membersOfT}** из **${eventOfCategory.record.maxMembers}**\nВедущий: ${eventOwner}`,
                                                    footer: { text: `Вам в личные сообщения была отправлена карточка с рандомной ролью` },
                                                    image: { url: appearance.custom.Events.default.nullImage },
                                                    fields: infoEmbedsFields
                                                },
                                                {
                                                    title: `Роли: ${eventOfCategory.name}`,
                                                    color: appearance.embed.color,
                                                    fields: fieldsRole,
                                                    image: { url: appearance.custom.Events.default.nullImage }
                                                },
                                                {
                                                    title: `Готовность: ${eventOfCategory.name}`,
                                                    color: appearance.embed.color,
                                                    description: !textRoleNoConfirmation ? `Все роли **на столе** были приняты\n-# Игра запускается` : `Время **на подтверждение** закончится <t:${Math.floor(timeStart+examinationTimeConfirmation)}:R>\n-# Активные роли подтвердите свою готовность\n-# или зайдите на необходимый сервер`, //${textRoleNoConfirmation}`,
                                                    image: { url: appearance.custom.Events.default.nullImage }
                                                }
                                            ]
                                        }).catch(() => {});

                                    };

                                    await sendInfoMessage ();
                                        

                                    let allNigth = '';
                                    let textPunishment = '';
                                    
                                    const endGame = (async (newI) => {

                                        if (guilds[EventId].Owner !== newI.member.id) return newI.reply(await errorNoEventsOwnerMessage (newI.member));
                                        const pickTeam = eventOfCategory.game.teams[newI.values[0]];
                                        eventOwner = await guild.members.fetch(guilds[EventId].Owner).catch(() => {});

                                        guilds[EventId].deleted = true;
                                        manageMessage.delete().catch(() => {});

                                        newI.update().catch(() => {});
                                        eventOwner.setNickname('').catch(() => {});
                                        for (const pickMember in game.members) {

                                            const fetchPickMember = await guild.members.fetch(game.members[pickMember].id).catch(() => {});
                                            if (fetchPickMember) fetchPickMember.setNickname(game.members[pickMember].nickName).catch(() => {});

                                        };


                                        let txtOfDinfo = ``; //Кругов сыграно: ${game.actions.day}\nЗавершена: ${getCurrentDateTime(Date.now() / 1000)}`; //\n\n\n${allNigth !== '' ? allNigth + '\n\n\n' : ''}${textPunishment !== '' ? textPunishment + '\n\n\n' : ''}`;
                                        for (const pickServer in game.servers) {

                                            for (const pickChannel in game.servers[pickServer].channels) {

                                                let channelMsgHistory = '';
                                                const messageOfPickChannel = [];
                                                const messagesOfServerPickChannel = await game.servers[pickServer].channels[pickChannel].channel.messages.fetch();

                                                for (const pickMessage of messagesOfServerPickChannel) messageOfPickChannel.push(pickMessage[1]);
                                                messageOfPickChannel.sort((a, b) => a.createdTimestamp - b.createdTimestamp);
                            
                                                for (const pickMessage of messageOfPickChannel) if (pickMessage.author.id !== client.user.id) channelMsgHistory += `\n\n${getCurrentDateTime(pickMessage.createdTimestamp / 1000)} Отправил: ${pickMessage.author.username} [ID: ${pickMessage.author.id}]\nСообщение: ${pickMessage.content}`
                                                txtOfDinfo += `Канал: ${game.servers[pickServer].channels[pickChannel].name} - ${game.servers[pickServer].channels[pickChannel].channel.id}\n[Сервер: ${game.servers[pickServer].server.name}]\n\nИстория сообщений: ${channelMsgHistory ? channelMsgHistory : 'Отсутствуют'}\n\n`;

                                            };

                                        };


                                        let pick = 0;
                                        let channelsEvent = [eventVoiceChannel, eventRecordChannel, eventManageChannel, eventCategory];
                                        let ti1 = setInterval(async () => {

                                            if (eventVoiceChannel && !eventVoiceChannel.members || eventVoiceChannel && !eventVoiceChannel.members.size) {

                                                if (pick == channelsEvent.length) return clearInterval(ti1);
                                                channelsEvent[pick].delete().catch(() => {});
                                                pick++;

                                            };

                                        }, 1000);

                                        for (n=0; n < game.servers.length; n++) game.servers[n].guild.delete().catch(() => {});


                                        logMessage.edit({  
                                            content: `<t:${Math.floor(Date.now()/1000)}:f>`,
                                            embeds: [
                                                {
                                                    author: { name: 'Мероприятие завершено' },
                                                    title: `${client.user.username + ' logs'}`,
                                                    color: appearance.embed.color,
                                                    description: `Создано: <t:${Math.floor(guilds[EventId].Created)}:f>\nЗавершено: <t:${Math.floor(Date.now()/1000)}:f>`,
                                                    fields: [
                                                        {
                                                            name: `${appearance.embed.dot || appearance.emoji.Dot}Длительность:`,
                                                            value: `\`\`\`${hourTranslator(Math.floor(Date.now()/1000 - parameters.startedTime))}\`\`\``, 
                                                            inline: false
                                                        },
                                                        {
                                                            name: `${appearance.embed.dot || appearance.emoji.Dot}Завершил:`,
                                                            value: `・${member}\n・${member.id}`,  
                                                            inline: true
                                                        },
                                                        {
                                                            name: `${appearance.embed.dot || appearance.emoji.Dot}Мероприятие:`,
                                                            value: `\`\`\`${eventOfCategory.name}\`\`\``,
                                                            inline: true
                                                        },
                                                        {
                                                            name: `${appearance.embed.dot || appearance.emoji.Dot}Победа:`,
                                                            value: `${appearance.emoji.Win} **${pickTeam.emoji} ${newI.values[0]}**`,
                                                            inline: false
                                                        }
                                                    ],
                                                    footer: { text: `・Ведущий: ${member.displayName}` },
                                                    thumbnail: { url: memberAvatar },
                                                }
                                            ],
                                            components: [

                                            ]
                                        }).catch(() => {});


                                        let pickWinTeam = newI.values[0];

                                        function calculateRaitingChange(win, type, memberRaiting) {

                                            let reward = 0;

                                            const rewardW = {
                                                verybad: 5,
                                                bad: 10,
                                                default: 19,
                                                good: 25,
                                                verygood: 29
                                            };

                                            const rewardL = {
                                                verybad: -31,
                                                bad: -26,
                                                default: -20,
                                                good: -13,
                                                verygood: -9
                                            };

                                            if (memberRaiting) {

                                                win ? reward = rewardW[type] : reward = rewardL[type];
    
                                                let ci = midlRaiting < memberRaiting ? Math.round((memberRaiting-midlRaiting)/55*-1) : Math.round((midlRaiting-memberRaiting)/45);

                                                return reward+ci;

                                            }

                                            else {

                                                win ? reward = rewardW[type] : reward = rewardL[type];
    
                                                return reward;

                                            };


                                        };

                                        let allsRaiting = [];
                                        for (const pickMember in game.members) allsRaiting.push(stats[game.members[pickMember].id].Mafia[eventOfCategory.result].rating);

                                        let minElo = Math.min(...allsRaiting);
                                        let maxElo = Math.max(...allsRaiting);
                                        
                                        let resultEmbedsText = '';

                                        for (const pickTeams in eventOfCategory.game.teams) {

                                            if (newI.values[0] == pickTeams) for (const pickMember in game.members) if(eventOfCategory.game.teams[pickTeams].roles.includes(game.members[pickMember].role.name)) channel.send(`!award ${eventOfCategory.rewards['Победившая команда'].reward} ${game.members[pickMember].id}`).catch(() => {});
                                            else for (const pickMember in game.members) if(!eventOfCategory.game.teams[pickTeams].roles.includes(game.members[pickMember].role.name)) channel.send(`!award ${eventOfCategory.rewards['Проигравшая команда'].reward} ${game.members[pickMember].id}`).catch(() => {});

                                        };

                                        for (const pickTeams in eventOfCategory.game.teams) {
    
                                            if (newI.values[0] == pickTeams) {

                                                let teamMembers = '';
        
                                                for (const pickMember in game.members) {
                                                    
                                                    const fetchPickMember = game.members[pickMember];   
                                                    if(eventOfCategory.game.teams[pickTeams].roles.includes(fetchPickMember.role.name)) {                                                     
                                                        teamMembers += `${getNumber (fetchPickMember.number)} ${fetchPickMember.role.emoji} <@${fetchPickMember.id}>${fetchPickMember.alive ? '' : ' ' + appearance.emoji.Kill}\n`;
                                                    };

                                                };
                                                
                                                if (teamMembers !== '') resultEmbedsText += `## ${appearance.emoji.Win} **${eventOfCategory.game.teams[pickTeams].emoji} ${pickTeams}**\n${teamMembers}`;

                                            };  

                                        };

                                        for (const pickTeams in eventOfCategory.game.teams) {
    
                                            if (newI.values[0] !== pickTeams) {

                                                let teamMembers = '';
        
                                                for (const pickMember in game.members) {
                                                    
                                                    const fetchPickMember = game.members[pickMember];
                                                    if(eventOfCategory.game.teams[pickTeams].roles.includes(fetchPickMember.role.name)) {             
                                                        teamMembers += `${getNumber (fetchPickMember.number)} ${fetchPickMember.role.emoji} <@${fetchPickMember.id}>${fetchPickMember.alive ? '' : ' ' + appearance.emoji.Kill}\n`;
                                                    };

                                                };
                                                
                                                if (teamMembers !== '') resultEmbedsText += `### ${eventOfCategory.game.teams[pickTeams].emoji} ${pickTeams}\n${teamMembers}`;

                                            };

                                        };

                                        if (game.history.lx[0]) {

                                            for (const pickMember in game.history.lx) {

                                                let txt = '';
                                                let quantity = 0;
                                                for (const i in game.history.lx[pickMember].lx) {

                                                    for (const pickMember2 in game.members) if (game.members[pickMember2].number == game.history.lx[pickMember].lx[i] && eventOfCategory.game.lx.roles.includes(game.members[pickMember2].role.name)) quantity++;

                                                    if (txt == '') txt += `${getNumber(game.history.lx[pickMember].lx[i])}`;
                                                    else txt += `, ${getNumber(game.history.lx[pickMember].lx[i])}`;

                                                };

                                                resultEmbedsText += `### Лучший ход от ${getNumber(game.history.lx[pickMember].member.number)}:\n-# Попадание: **${quantity}** из **${game.history.lx[pickMember].lx.length}**\n${txt}\n`;

                                            };

                                        };

                                        if (game.history.vote[0]) {

                                            let txt = '';
                                            for (const pickMember in game.history.vote) {

                                                if (txt == '') txt += `${getNumber(game.history.vote[pickMember].number)}`;
                                                else txt += `, ${getNumber(game.history.vote[pickMember].number)}`;

                                            };

                                            resultEmbedsText += `### Заголосованные:\n${txt}\n`;

                                        };

                                        if (game.history.kill[0]) {

                                            let txt = '';
                                            for (const pickMember in game.history.kill) {

                                                if (txt == '') txt += `${getNumber(game.history.kill[pickMember].number)}`;
                                                else txt += `, ${getNumber(game.history.kill[pickMember].number)}`;

                                            };

                                            resultEmbedsText += `### Убитые:\n${txt}\n`;

                                        };

                                        // if (game.history.cheack[0]) {

                                        //     cheacks = {};
                                        //     for (const pickMember in game.history.cheack) {

                                        //         if (!cheacks[game.history.cheack[pickMember].roles[0].name]) {
                                                    
                                        //             cheacks[game.history.cheack[pickMember].roles[0].name] = {
                                        //                 roles: game.history.cheack[pickMember].roles,
                                        //                 cheacks: []
                                        //             };

                                        //         };

                                        //         cheacks[game.history.cheack[pickMember].roles[0].name].cheacks.push(game.history.cheack[pickMember].number);
                                            
                                        //     };

                                        //     for (const pickCheack in cheacks) {

                                        //         let txtRoles = '';
                                        //         for (const pickRole in cheacks[pickCheack].roles) {

                                        //             const fetchRole = eventOfCategory.game.role[cheacks[pickCheack].roles[pickRole]];
                                        //             if (fetchRole) {

                                        //                 if (txtRoles == '') txtRoles += `${fetchRole.emoji} ${fetchRole.name}`;
                                        //                 else txtRoles += `, ${fetchRole.emoji} ${fetchRole.name}`;

                                        //             };

                                        //         };

                                        //         let txt = '';
                                        //         for (const pickMember in cheacks[pickCheack].cheacks) {

                                        //             if (txt == '') txt += `**${cheacks[pickCheack].cheacks[pickMember]}**`;
                                        //             else txt += `, **${cheacks[pickCheack].cheacks[pickMember]}**`;

                                        //         };

                                        //         resultEmbedsFields.push(
                                        //             {
                                        //                 name: `Проверка на ${txtRoles}:`,
                                        //                 value: `${txt}`,
                                        //                 inline: false
                                        //             }
                                        //         );

                                        //     };

                                        // };

                                        const resultsMafia = await guild.channels.fetch(appearance.channels.Mafia.results).catch(() => {});
                                        const resultMessage = await resultsMafia.send({  
                                            embeds: [
                                                {
                                                    title: `Результаты: ${eventOfCategory.name}`,
                                                    color: pickTeam.color,  
                                                    footer: { text: `Ведущий: ${eventOwner.displayName} (${eventOwner.id})`, icon_url: iMemberAvatar }
                                                }
                                            ]
                                        }).catch(() => {});
                                    
                                        const gameLog = await resultMessage.startThread({ name: 'Информация' }).catch(() => {});
                                    
                                        setTimeout(() => {

                                            resultMessage.edit({  
                                                embeds: [
                                                    {
                                                        title: `Результаты: ${eventOfCategory.name}`,
                                                        color: pickTeam.color,
                                                        description: `Длительность: ${hourTranslatorBold(Math.floor(Date.now()/1000 - parameters.startedTime))}\n<t:${Math.floor(Date.now()/1000)}:D> ${gameLog}\n${resultEmbedsText}`,
                                                        footer: { text: `Ведущий: ${eventOwner.displayName} (${eventOwner.id})\nРейтинг: Ожидание выставления баллов`, icon_url: iMemberAvatar }
                                                    }
                                                ]
                                            }).catch(() => {});
                                            
                                        }, 4000);

                                        let timeEnd = Date.now()/1000;
                                        let timeCode = Date.now()/2000;
                                        writeFile(`./assets/information-mafia-${timeCode}.txt`, txtOfDinfo, (err) => {

                                            if (err) return console.error(err);
                                            
                                            gameLog.send({
                                                files: [
                                                    {
                                                        attachment: `./assets/information-mafia-${timeCode}.txt`,
                                                        name: `mafia-${eventRecordChannel.id}-${getCurrentDateTime(Date.now() / 1000)}.txt`
                                                    }
                                                ]
                                            });

                                        });

                                        setTimeout(() => {

                                            gameLog.send({  
                                                embeds: [
                                                    {
                                                        title: `Ход игры: ${eventOfCategory.name}`,
                                                        color: appearance.embed.color,  
                                                        description: `${allNigth}`,
                                                        footer: { text: `* Кругов сыграно ${game.actions.day}` }
                                                    }
                                                ]
                                            }).catch(() => {});
                                            
                                        }, 1000);


                                        eventVoiceChannel.members.forEach(member => {

                                            member.voice.setChannel(appearance.channels.Mafia.Discussion).catch(() => {});

                                        });


                                        guilds[EventId].game = game;
                                        guilds[EventId].status = pickTeam.status;
                                        users[guilds[EventId].Owner].Events.unshift(
                                            {
                    
                                                EventId: EventId,
                                                Ended: Date.now () / 1000,
                                                Created: guilds[EventId].Created,
                    
                                                message: {

                                                    log: logMessage,
                                                    announcement: guilds[EventId].message.announcement,
                                                    resultMessage: resultMessage
                    
                                                }
                                                
                                            }
                                        );

                                        guilds[guild.id].Events.Active = guilds[guild.id].Events.Active.filter((n) => { return n != EventId });
                                        users[member.id].ActiveEvent = false;

                                        if (guilds[EventId].message.announcement) 
                                        guilds[EventId].message.announcement.edit({
                                            content: ' ',
                                            components: [
                                                {
                                                    type: 1,
                                                    components: [
                                                        {
                                                            type: 2, 
                                                            style: 5, 
                                                            label: 'Мероприятие окончено', 
                                                            url: `https://discord.gg/BneyWRqe`,
                                                            disabled: true 
                                                        }
                                                    ]
                                                }
                                            ]
                                        }).catch(() => {});

                                        
                                        let type = 'default';
                                        let membersOfDop = {};

                                        let q = 0;
                                        for (const pickMember in game.members) q++;
                                        
                                        for (const pickTeams in eventOfCategory.game.teams) {

                                            if (newI.values[0] == pickTeams) {
        
                                                for (const pickMember in game.members) {
                                                    
                                                    const fetchPickMember = game.members[pickMember];
                                                    if(eventOfCategory.game.teams[pickTeams].roles.includes(fetchPickMember.role.name)) {
                                                        
                                                        if (!membersOfDop[fetchPickMember.number]) 
                                                        membersOfDop[fetchPickMember.number] = {
                                                            default: calculateRaitingChange(true, 'default', stats[fetchPickMember.id].Mafia[eventOfCategory.result].rating),
                                                            fetchPickMember: fetchPickMember,
                                                            type: 'default',
                                                            lx: 0,
                                                            result: calculateRaitingChange(true, 'default', stats[fetchPickMember.id].Mafia[eventOfCategory.result].rating),
                                                            win: true
                                                        };

                                                    };

                                                };
                                                
                                            };  

                                        };

                                        for (const pickTeams in eventOfCategory.game.teams) {

                                            if (newI.values[0] !== pickTeams) {

                                                let teamMembers = '';
        
                                                for (const pickMember in game.members) {
                                                    
                                                    const fetchPickMember = game.members[pickMember];

                                                    if(eventOfCategory.game.teams[pickTeams].roles.includes(fetchPickMember.role.name)) {

                                                        if (!membersOfDop[fetchPickMember.number]) 
                                                        membersOfDop[fetchPickMember.number] = {
                                                            default: calculateRaitingChange(false, 'default', stats[fetchPickMember.id].Mafia[eventOfCategory.result].rating),
                                                            fetchPickMember: fetchPickMember,
                                                            type: 'default',
                                                            lx: 0,
                                                            result: calculateRaitingChange(false, 'default', stats[fetchPickMember.id].Mafia[eventOfCategory.result].rating),
                                                            win: false

                                                        };
                                                        
                                                    };

                                                };
                                                
                                                if (teamMembers !== '') resultEmbedsText += `### ${eventOfCategory.game.teams[pickTeams].emoji} ${pickTeams}\n${teamMembers}`;

                                            };

                                        };

                                        if (game.history.lx[0]) {

                                            for (const pickMember in game.history.lx) {

                                                let quantity = 0;
                                                for (const i in game.history.lx[pickMember].lx) for (const pickMember2 in game.members) if (game.members[pickMember2].number == game.history.lx[pickMember].lx[i] && eventOfCategory.game.lx.roles.includes(game.members[pickMember2].role.name)) quantity++;

                                                if (game.history.lx[pickMember].lx.length > 0 && quantity == 0) membersOfDop[game.history.lx[pickMember].member.number].lx = -4;
                                                if (game.history.lx[pickMember].lx.length > 0 && quantity == 1) membersOfDop[game.history.lx[pickMember].member.number].lx = 0;
                                                if (game.history.lx[pickMember].lx.length > 0 && quantity == 2) membersOfDop[game.history.lx[pickMember].member.number].lx = 3;
                                                if (game.history.lx[pickMember].lx.length > 0 && quantity == 3) membersOfDop[game.history.lx[pickMember].member.number].lx = 6;


                                            };

                                        };
                                        

                                        function getDopComponents () {

                                            let componentsComponents = [];
                                            
                                            componentsComponents.push(
                                                {
                                                    type: 1,
                                                    components: []
                                                }
                                            );

                                        
                                            componentsComponents[componentsComponents.length-1].components.push(
                                                {
                                                    type: 2, 
                                                    style: 'verybad' == type ? 3 : appearance.buttons_menu.Default.style, 
                                                    customId: `verybad`,
                                                    label: 'Ужасно',
                                                    disabled: 'verybad' == type ? true : false
                                                }
                                            );
                                        
                                            componentsComponents[componentsComponents.length-1].components.push(
                                                {
                                                    type: 2, 
                                                    style: 'bad' == type ? 3 : appearance.buttons_menu.Default.style, 
                                                    customId: `bad`,
                                                    label: 'Плохо',
                                                    disabled: 'bad' == type ? true : false
                                                }
                                            );
                                        
                                            componentsComponents[componentsComponents.length-1].components.push(
                                                {
                                                    type: 2, 
                                                    style: 'default' == type ? 3 : appearance.buttons_menu.Default.style, 
                                                    customId: `default`,
                                                    label: 'Средне',
                                                    disabled: 'default' == type ? true : false
                                                }
                                            );
                                        
                                            componentsComponents[componentsComponents.length-1].components.push(
                                                {
                                                    type: 2, 
                                                    style: 'good' == type ? 3 : appearance.buttons_menu.Default.style, 
                                                    customId: `good`,
                                                    label: 'Хорошо',
                                                    disabled: 'good' == type ? true : false
                                                }
                                            );
                                        
                                            componentsComponents[componentsComponents.length-1].components.push(
                                                {
                                                    type: 2, 
                                                    style: 'verygood' == type ? 3 : appearance.buttons_menu.Default.style, 
                                                    customId: `verygood`,
                                                    label: 'Отлично',
                                                    disabled: 'verygood' == type ? true : false
                                                }
                                            );
                                                
                                            const editType = (async (newI) => {
                                    
                                                type = newI.customId;
                                                newI.update(getDopMessage ()).catch(() => {});

                                            });
                                    
                                            actions['verybad'] = {
                                                actions: [editType],
                                                all: false
                                            };

                                            actions['bad'] = {
                                                actions: [editType],
                                                all: false
                                            };

                                            actions['default'] = {
                                                actions: [editType],
                                                all: false
                                            };

                                            actions['good'] = {
                                                actions: [editType],
                                                all: false
                                            };

                                            actions['verygood'] = {
                                                actions: [editType],
                                                all: false
                                            };
                                

                                            for (let i = 1; i < q+1; i++) {

                                                let numberPickMember = i < 10 ? `0${i}` : `${i}`;
                                                const fetchPickMember = membersOfDop[numberPickMember].fetchPickMember;
                                            
                                                if (!componentsComponents[0] || componentsComponents[componentsComponents.length-1].components.length == 5) 
                                                    componentsComponents.push(
                                                    {
                                                        type: 1,
                                                        components: []
                                                    }
                                                );
                                        
                                                componentsComponents[componentsComponents.length-1].components.push(
                                                    {
                                                        type: 2, 
                                                        style: membersOfDop[numberPickMember].type == type ? 3 : appearance.buttons_menu.Default.style, 
                                                        customId: `dop${i}`,
                                                        label: `${fetchPickMember.number}`, 
                                                        disabled: membersOfDop[numberPickMember].type == type ? true : false
                                                    }
                                                );
                                                
                                                const pickDopOfMember = (async (newI) => {
                                        
                                                    membersOfDop[numberPickMember].type = type;
                                                    membersOfDop[numberPickMember].result = calculateRaitingChange(membersOfDop[numberPickMember].win, type, stats[fetchPickMember.id].Mafia[eventOfCategory.result].rating);

                                                    newI.update(getDopMessage ()).catch(() => {});

                                                });
                                        
                                                if (!actions[`dop${i}`])
                                                actions[`dop${i}`] = {
                                                    actions: [pickDopOfMember],
                                                    all: false
                                                };
                                        
                                            };


                                            componentsComponents.push(
                                                {
                                                    type: 1,
                                                    components: []
                                                }
                                            );
                                        
                                            componentsComponents[componentsComponents.length-1].components.push(
                                                {
                                                    type: 2, 
                                                    style: 1, 
                                                    customId: 'endResult',
                                                    label: 'Опубликовать'
                                                }
                                            );
                                                
                                            const endResult = (async (newI) => {
                                    
                                                newI.message.delete().catch(() => {});

                                                resultEmbedsText = '';

                                                for (const pickTeams in eventOfCategory.game.teams) {
            
                                                    if (pickWinTeam == pickTeams) {
        
                                                        let teamMembers = '';
                
                                                        for (const pickMember in game.members) {
                                                            
                                                            const fetchPickMember = game.members[pickMember];
        
                                                            if(eventOfCategory.game.teams[pickTeams].roles.includes(fetchPickMember.role.name)) {
                                                                
                                                                const eloChange = membersOfDop[fetchPickMember.number].result + membersOfDop[fetchPickMember.number].lx;
                                                                stats[fetchPickMember.id].Mafia[eventOfCategory.result].rating += Number(eloChange);
                                                                teamMembers += `${getNumber (fetchPickMember.number)} ${fetchPickMember.role.emoji} <@${fetchPickMember.id}>${fetchPickMember.alive ? '' : ' ' + appearance.emoji.Kill}・**${stats[fetchPickMember.id].Mafia[eventOfCategory.result].rating}** (${eloChange > 0 ? '+' : ''}${eloChange})\n`;
                                                                
                                                                stats[fetchPickMember.id].Mafia[eventOfCategory.result].games.unshift(
                                                                    {
                                                                        raiting: stats[fetchPickMember.id].Mafia[eventOfCategory.result].rating + ` (${eloChange > 0 ? '+' : ''}${eloChange})`,
                                                                        roleOfText: `${fetchPickMember.role.name.toUpperCase()} ${fetchPickMember.alive ? '' : '(У)'}`,
                                                                        date: Date.now()/1000,
                                                                        win: true,
                                                                        lose: false
                                                                    }
                                                                );
                                                                
                                                                stats[fetchPickMember.id].Mafia[eventOfCategory.result].all++;
                                                                stats[fetchPickMember.id].Mafia[eventOfCategory.result].win++;
                                                                stats[fetchPickMember.id].Mafia[eventOfCategory.result].roles[fetchPickMember.role.name].all++;
                                                                stats[fetchPickMember.id].Mafia[eventOfCategory.result].roles[fetchPickMember.role.name].win++;
        
                                                            };
        
                                                        };
                                                        
                                                        if (teamMembers !== '') resultEmbedsText += `## ${appearance.emoji.Win} **${eventOfCategory.game.teams[pickTeams].emoji} ${pickTeams}**\n${teamMembers}`;
        
                                                    };  
        
                                                };
        
                                                for (const pickTeams in eventOfCategory.game.teams) {
            
                                                    if (pickWinTeam !== pickTeams) {
        
                                                        let teamMembers = '';
                
                                                        for (const pickMember in game.members) {
                                                            
                                                            const fetchPickMember = game.members[pickMember];
        
                                                            if(eventOfCategory.game.teams[pickTeams].roles.includes(fetchPickMember.role.name)) {
        
                                                                const eloChange = membersOfDop[fetchPickMember.number].result + membersOfDop[fetchPickMember.number].lx;
                                                                stats[fetchPickMember.id].Mafia[eventOfCategory.result].rating += Number(eloChange);
                                                                teamMembers += `${getNumber (fetchPickMember.number)} ${fetchPickMember.role.emoji} <@${fetchPickMember.id}>${fetchPickMember.alive ? '' : ' ' + appearance.emoji.Kill}・**${stats[fetchPickMember.id].Mafia[eventOfCategory.result].rating}** (${eloChange > 0 ? '+' : ''}${eloChange})\n`;
                                                                
                                                                stats[fetchPickMember.id].Mafia[eventOfCategory.result].games.unshift(
                                                                    {
                                                                        raiting: stats[fetchPickMember.id].Mafia[eventOfCategory.result].rating + ` (${eloChange > 0 ? '+' : ''}${eloChange})`,
                                                                        roleOfText: `${fetchPickMember.role.name.toUpperCase()} ${fetchPickMember.alive ? '' : '(У)'}`,
                                                                        date: Date.now()/1000,
                                                                        win: false,
                                                                        lose: true
                                                                    }
                                                                );
        
                                                                stats[fetchPickMember.id].Mafia[eventOfCategory.result].all++;
                                                                stats[fetchPickMember.id].Mafia[eventOfCategory.result].roles[fetchPickMember.role.name].all++;
                                                                
                                                            };
        
                                                        };
                                                        
                                                        if (teamMembers !== '') resultEmbedsText += `### ${eventOfCategory.game.teams[pickTeams].emoji} ${pickTeams}\n${teamMembers}`;
        
                                                    };
        
                                                };

                                                if (game.history.lx[0]) {
        
                                                    for (const pickMember in game.history.lx) {
        
                                                        let txt = '';
                                                        let quantity = 0;
                                                        for (const i in game.history.lx[pickMember].lx) {
        
                                                            for (const pickMember2 in game.members) if (game.members[pickMember2].number == game.history.lx[pickMember].lx[i] && eventOfCategory.game.lx.roles.includes(game.members[pickMember2].role.name)) quantity++;
        
                                                            if (txt == '') txt += `${getNumber(game.history.lx[pickMember].lx[i])}`;
                                                            else txt += `, ${getNumber(game.history.lx[pickMember].lx[i])}`;
        
                                                        };
        
                                                        resultEmbedsText += `### Лучший ход от ${getNumber(game.history.lx[pickMember].member.number)}:\n-# Попадание: **${quantity}** из **${game.history.lx[pickMember].lx.length}**\n${txt}\n`;
        
                                                    };
        
                                                };
        
                                                if (game.history.vote[0]) {
        
                                                    let txt = '';
                                                    for (const pickMember in game.history.vote) {
        
                                                        if (txt == '') txt += `${getNumber(game.history.vote[pickMember].number)}`;
                                                        else txt += `, ${getNumber(game.history.vote[pickMember].number)}`;
        
                                                    };
        
                                                    resultEmbedsText += `### Заголосованные:\n${txt}\n`;
        
                                                };
        
                                                if (game.history.kill[0]) {
        
                                                    let txt = '';
                                                    for (const pickMember in game.history.kill) {
        
                                                        if (txt == '') txt += `${getNumber(game.history.kill[pickMember].number)}`;
                                                        else txt += `, ${getNumber(game.history.kill[pickMember].number)}`;
        
                                                    };
        
                                                    resultEmbedsText += `### Убитые:\n${txt}\n`;
        
                                                };
                                    
                                                resultMessage.edit({  
                                                    embeds: [
                                                        {
                                                            title: `Результаты: ${eventOfCategory.name}`,
                                                            color: pickTeam.color,
                                                            description: `Длительность: ${hourTranslatorBold(Math.floor(timeEnd - parameters.startedTime))}\n<t:${Math.floor(timeEnd)}:D> ${gameLog}\n${resultEmbedsText}`,
                                                            footer: { text: `Ведущий: ${eventOwner.displayName} (${eventOwner.id})\nРейтинг: Включен`, icon_url: iMemberAvatar }
                                                        }
                                                    ]
                                                }).catch(() => {});

                                            });
                                    
                                            actions[`endResult`] = {
                                                actions: [endResult],
                                                all: false
                                            };
                                            
                                            return componentsComponents;

                                        };

                                        function getDopMessage () {

                                            let txtDop = '';

                                            for (let i = 1; i < q+1; i++) {

                                                let numberPickMember = i < 10 ? `0${i}` : `${i}`;
                                                const fetchPickMember = membersOfDop[numberPickMember].fetchPickMember;
                                                const memberRaiting = stats[fetchPickMember.id].Mafia[eventOfCategory.result].rating;
                                                
                                                txtDop += `${!membersOfDop[numberPickMember].win ? appearance.emoji.Null : appearance.emoji.Win} ${getNumber (fetchPickMember.number)} ${fetchPickMember.role.emoji} <@${fetchPickMember.id}> ${midlRaiting + 75 < memberRaiting ? appearance.emoji.HighRaiting : midlRaiting > memberRaiting + 75 ? appearance.emoji.LowRaiting : appearance.emoji.MidlRaiting} — ${membersOfDop[numberPickMember].result > 0 ? '+' : ''}${membersOfDop[numberPickMember].result}${membersOfDop[numberPickMember].lx !== 0 ? membersOfDop[numberPickMember].lx > 0 ? ' +' : ' ' + membersOfDop[numberPickMember].lx + '' : ''}\n`;

                                            };

                                            return {  
                                                embeds: [
                                                    {
                                                        title: `Выставление баллов: ${eventOfCategory.name}`,
                                                        color: appearance.embed.color,
                                                        description: `${txtDop}`,
                                                        footer: { text: `* После ника стоит уровень птс игрока (на столе)` }
                                                    }
                                                ], 
                                                components: getDopComponents ()
                                            };

                                        };


                                        const messageOfOwnerDop = await eventOwner.send(getDopMessage ()).catch(() => {});

                                        const collectorConponentsOfMessageOfOwnerDop = await messageOfOwnerDop.createMessageComponentCollector();
                                        collectorConponentsOfMessageOfOwnerDop.on('collect', async newI => {

                                            switch (newI.customId) { 

                                                default: {
                                    
                                                    if (actions[newI.customId] && actions[newI.customId].all == false) await actions[newI.customId].actions[0](newI);
                                    
                                                    break;
                                    
                                                }

                                            }

                                        });

                                    });

                                    actions['endGame'] = {
                                        actions: [endGame],
                                        all: false
                                    };


                                    const anticipatorily = (async (newI) => {

                                        if (guilds[EventId].Owner !== newI.member.id) return newI.reply(await errorNoEventsOwnerMessage (newI.member));
                                        eventOwner = await guild.members.fetch(guilds[EventId].Owner).catch(() => {});

                                        guilds[EventId].deleted = true;
                                        manageMessage.delete().catch(() => {});

                                        newI.update().catch(() => {});
                                        eventOwner.setNickname('').catch(() => {});


                                        let txtOfDinfo = ''; // `Кругов сыграно: ${game.actions.day}\nЗавершена: ${getCurrentDateTime(Date.now() / 1000)}`;
                                        for (const pickServer in game.servers) {

                                            for (const pickChannel in game.servers[pickServer].channels) {

                                                let channelMsgHistory = '';
                                                const messageOfPickChannel = [];
                                                const messagesOfServerPickChannel = await game.servers[pickServer].channels[pickChannel].channel.messages.fetch();

                                                for (const pickMessage of messagesOfServerPickChannel) messageOfPickChannel.push(pickMessage[1]);
                                                messageOfPickChannel.sort((a, b) => a.createdTimestamp - b.createdTimestamp);
                            
                                                for (const pickMessage of messageOfPickChannel) if (pickMessage.author.id !== client.user.id) channelMsgHistory += `\n\n${getCurrentDateTime(pickMessage.createdTimestamp / 1000)} Отправил: ${pickMessage.author.username} [ID: ${pickMessage.author.id}]\nСообщение: ${pickMessage.content}`
                                                txtOfDinfo += `Канал: ${game.servers[pickServer].channels[pickChannel].name} - ${game.servers[pickServer].channels[pickChannel].channel.id}\n[Сервер: ${game.servers[pickServer].server.name}]\n\nИстория сообщений: ${channelMsgHistory ? channelMsgHistory : 'Отсутствуют'}\n\n`;

                                            };

                                        };
                                        

                                        for (const pickMember in game.members) {

                                            const fetchPickMember = await guild.members.fetch(game.members[pickMember].id).catch(() => {});
                                            if (fetchPickMember) fetchPickMember.setNickname(game.members[pickMember].nickName).catch(() => {});
                                            
                                        };

                                        eventVoiceChannel.members.forEach(member => {

                                            member.voice.setChannel(appearance.channels.Mafia.Discussion).catch(() => {});

                                        });

                                        let pick = 0;
                                        let channelsEvent = [eventVoiceChannel, eventRecordChannel, eventManageChannel, eventCategory];
                                        let ti1 = setInterval(async () => {

                                            if (eventVoiceChannel && !eventVoiceChannel.members || eventVoiceChannel && !eventVoiceChannel.members.size) {

                                                if (pick == channelsEvent.length) return clearInterval(ti1);
                                                channelsEvent[pick].delete().catch(() => {});
                                                pick++;

                                            };

                                        }, 1000);

                                        for (n=0; n < game.servers.length; n++) game.servers[n].guild.delete().catch(() => {});


                                        logMessage.edit({  
                                            content: `<t:${Math.floor(Date.now()/1000)}:f>`,
                                            embeds: [
                                                {
                                                    author: { name: 'Мероприятие досрочно окончено' },
                                                    title: `${client.user.username + ' logs'}`,
                                                    color: appearance.embed.color,
                                                    description: `Создано: <t:${Math.floor(guilds[EventId].Created)}:f>\nЗавершено: <t:${Math.floor(Date.now()/1000)}:f>`,
                                                    fields: [
                                                        {
                                                            name: `${appearance.embed.dot || appearance.emoji.Dot}Длительность:`,
                                                            value: `\`\`\`${hourTranslator(Math.floor(Date.now()/1000 - parameters.startedTime))}\`\`\``, 
                                                            inline: false
                                                        },
                                                        {
                                                            name: `${appearance.embed.dot || appearance.emoji.Dot}Завершил:`,
                                                            value: `・${member}\n・${member.id}`,  
                                                            inline: true
                                                        },
                                                        {
                                                            name: `${appearance.embed.dot || appearance.emoji.Dot}Мероприятие:`,
                                                            value: `\`\`\`${eventOfCategory.name}\`\`\``,
                                                            inline: true
                                                        },
                                                        {
                                                            name: `${appearance.embed.dot || appearance.emoji.Dot}Причина:`,
                                                            value: `\`\`\`Досрочно завершена\`\`\``,
                                                            inline: false
                                                        }
                                                    ],
                                                    footer: { text: `・Ведущий: ${member.displayName}` },
                                                    thumbnail: { url: memberAvatar },
                                                }
                                            ],
                                            components: [

                                            ]
                                        }).catch(() => {});


                                        let resultEmbedsText = '';
                                        for (const pickTeams in eventOfCategory.game.teams) {
    
                                            let teamMembers = '';
    
                                            for (const pickMember in game.members) {
                                                
                                                const fetchPickMember = game.members[pickMember];
                                                if(eventOfCategory.game.teams[pickTeams].roles.includes(fetchPickMember.role.name)) teamMembers += `${getNumber (fetchPickMember.number)} ${fetchPickMember.role.emoji} <@${fetchPickMember.id}> ${fetchPickMember.alive ? '' : appearance.emoji.Kill}\n`;
                                                
                                            };
                                            
                                            if (teamMembers !== '') resultEmbedsText += `### ${eventOfCategory.game.teams[pickTeams].emoji} ${pickTeams}\n${teamMembers}`;

                                        };


                                        const resultsMafia = await guild.channels.fetch(appearance.channels.Mafia.results).catch(() => {});
                                        const resultMessage = await resultsMafia.send({  
                                            embeds: [
                                                {
                                                    title: `Результаты: ${eventOfCategory.name}`,
                                                    color: eventOfCategory.game.actions.anticipatorily.color,
                                                    footer: { text: `Ведущий: ${eventOwner.displayName} (${eventOwner.id})`, icon_url: iMemberAvatar }
                                                }
                                            ]
                                        }).catch(() => {});
                                    
                                        const gameLog = await resultMessage.startThread({ name: 'Информация' }).catch(() => {});
                                    
                                        setTimeout(() => {

                                            resultMessage.edit({  
                                                embeds: [
                                                    {
                                                        title: `Результаты: ${eventOfCategory.name}`,
                                                        color: eventOfCategory.game.actions.anticipatorily.color,
                                                        description: `Длительность: ${hourTranslatorBold(Math.floor(Date.now()/1000 - parameters.startedTime))}\n<t:${Math.floor(Date.now()/1000)}:D> ${gameLog}\n${resultEmbedsText}`,
                                                        footer: { text: `Ведущий: ${eventOwner.displayName} (${eventOwner.id})\nРейтинг: Выключен`, icon_url: iMemberAvatar }
                                                    }
                                                ]
                                            }).catch(() => {});
                                            
                                        }, 4000);

                                        let timeCode = Date.now()/2000;
                                        writeFile(`./assets/information-mafia-${timeCode}.txt`, txtOfDinfo, (err) => {

                                            if (err) return console.error(err);
                                            
                                            gameLog.send({
                                                files: [
                                                    {
                                                        attachment: `./assets/information-mafia-${timeCode}.txt`,
                                                        name: `mafia-${eventRecordChannel.id}-${getCurrentDateTime(Date.now() / 1000)}.txt`
                                                    }
                                                ]
                                            });

                                        });

                                        setTimeout(() => {

                                            gameLog.send({  
                                                embeds: [
                                                    {
                                                        title: `Ход игры: ${eventOfCategory.name}`,
                                                        color: appearance.embed.color,  
                                                        description: `Оформляется без хода игры`,
                                                        footer: { text: `* Кругов сыграно ${game.actions.day}` }
                                                    }
                                                ]
                                            }).catch(() => {});
                                            
                                        }, 1000);


                                        guilds[EventId].game = game;
                                        guilds[EventId].status = eventOfCategory.game.actions.anticipatorily.status;
                                        users[guilds[EventId].Owner].Events.unshift(
                                            {
                    
                                                EventId: EventId,
                                                Ended: Date.now () / 1000,
                                                Created: guilds[EventId].Created,
                    
                                                message: {

                                                    log: logMessage,
                                                    announcement: guilds[EventId].message.announcement,
                                                    resultMessage: resultMessage
                    
                                                }
                                                
                                            }
                                        );

                                        guilds[guild.id].Events.Active = guilds[guild.id].Events.Active.filter((n) => { return n != EventId });
                                        users[member.id].ActiveEvent = false;

                                        if (guilds[EventId].message.announcement) 
                                        guilds[EventId].message.announcement.edit({
                                            content: ' ',
                                            components: [
                                                {
                                                    type: 1,
                                                    components: [
                                                        {
                                                            type: 2, 
                                                            style: 5, 
                                                            label: 'Мероприятие окончено', 
                                                            url: `https://discord.gg/BneyWRqe`,
                                                            disabled: true 
                                                        }
                                                    ]
                                                }
                                            ]
                                        }).catch(() => {});

                                    });

                                    actions['anticipatorily'] = {
                                        actions: [anticipatorily],
                                        all: false
                                    };


                                    const pause = (async (newI) => {

                                        if(guilds[EventId].Owner !== newI.member.id) return newI.reply(await errorNoEventsOwnerMessage (newI.member));
                                        eventOwner = await guild.members.fetch(guilds[EventId].Owner).catch(() => {});

                                        if (game.time !== 'day' && game.time !== 'pause') 
                                        return newI.reply({
                                            ephemeral: true,
                                            embeds: [
                                                {
                                                    title: `${client.user.username} error`,
                                                    color: appearance.embed.errorColor,
                                                    description: `${newI.member}, паузу можно ставить **только** днём`,
                                                    thumbnail: { url: iMemberAvatar }
                                                }
                                            ]
                                        }).catch(() => {});

                                        if (game.time == 'pause') {

                                            game.time = 'day';
                                            let timeout = 0;
                                            for (const pickMember in game.members) {

                                                if (game.members[pickMember].alive) {

                                                    const fetchPickMember = await guild.members.fetch(game.members[pickMember].id).catch(() => {});

                                                    if (fetchPickMember) {

                                                        eventVoiceChannel.permissionOverwrites.edit(fetchPickMember.id, { Speak: true })
                                                            .then(() => {
                                                                fetchPickMember.voice.setChannel(eventVoiceChannel.id).catch(() => {});
                                                            })
                                                            .catch(() => {});
                                                        eventRecordChannel.permissionOverwrites.edit(fetchPickMember.id, { SendMessages: true }).catch(() => {});

                                                    };

                                                };

                                            };


                                            manageMessage.components.forEach(component => {
        
                                                let Comp = component.components;
                                
                                                for (c = 0; c < Comp.length; c++) {
                                
                                                    if (Comp[c].data.style !== 5 && Comp[c].data.custom_id == 'pause') Comp[c].data.style = 2;
                                
                                                };
                                                
                                            });
        
                                            await newI.update({ components: manageMessage.components });


                                            eventRecordChannel.send({
                                                // content: `<t:${Math.floor(Date.now()/1000)}:f>`,
                                                embeds: [
                                                    {
                                                        title: `Отмена паузы: ${eventOfCategory.name}`,
                                                        color: appearance.embed.color,
                                                        // color: eventOfCategory.game.actions['pause'].color,
                                                        // description: `### Отмена паузы: ${eventOfCategory.name}`,
                                                        image: { url: eventOfCategory.game.image.unpause },
                                                        // timestamp: getCurrentDateTimeTxt(3),
                                                        // footer: { text: `・Ведущий: ${eventOwner.displayName}`, icon_url: await getAvatar(eventOwner) }
                                                    }
                                                ]
                                            }).catch(() => {});

                                            await cancelTrack ();

                                        }

                                        else {

                                            game.time = 'pause';

                                            for (const pickMember in game.members) {

                                                if (game.members[pickMember].alive) {

                                                    const fetchPickMember = await guild.members.fetch(game.members[pickMember].id).catch(() => {});

                                                    if (fetchPickMember) {

                                                        eventVoiceChannel.permissionOverwrites.edit(fetchPickMember.id, { Speak: false })
                                                            .then(() => {
                                                                fetchPickMember.voice.setChannel(eventVoiceChannel.id).catch(() => {});
                                                            })
                                                            .catch(() => {});
                                                        eventRecordChannel.permissionOverwrites.edit(fetchPickMember.id, { SendMessages: false }).catch(() => {});

                                                    };

                                                };

                                            };
                                            

                                            manageMessage.components.forEach(component => {
        
                                                let Comp = component.components;
                                
                                                for (c = 0; c < Comp.length; c++) {
                                
                                                    if (Comp[c].data.style !== 5 && Comp[c].data.custom_id == 'pause') Comp[c].data.style = 1;
                                
                                                };
                                                
                                            });
        
                                            await newI.update({ components: manageMessage.components });

                                            game.message.pause = await eventRecordChannel.send({
                                                // content: `<t:${Math.floor(Date.now()/1000)}:f>`,
                                                embeds: [
                                                    {
                                                        title: `Пауза: ${eventOfCategory.name}`,
                                                        color: appearance.embed.color,
                                                        // color: eventOfCategory.game.actions['pause'].color,
                                                        // description: `### Поставлена пауза: ${eventOfCategory.name}`,
                                                        image: { url: eventOfCategory.game.image.pause },
                                                        // timestamp: getCurrentDateTimeTxt(3),
                                                        // footer: { text: `・Ведущий: ${eventOwner.displayName}`, icon_url: await getAvatar(eventOwner) }
                                                    }
                                                ]
                                            }).catch(() => {});

                                            await startTrack (eventRecordChannel, eventVoiceChannel);

                                        };

                                    });

                                    actions['pause'] = {
                                        actions: [pause],
                                        all: false
                                    };


                                    let menuEvery = {};
                                    const nigth = (async (newI) => {

                                        if(guilds[EventId].Owner !== newI.member.id) return newI.reply(await errorNoEventsOwnerMessage (newI.member));
                                        eventOwner = await guild.members.fetch(guilds[EventId].Owner).catch(() => {});

                                        if (game.time !== 'day') 
                                        return newI.reply({
                                            ephemeral: true,
                                            embeds: [
                                                {
                                                    title: `${client.user.username} error`,
                                                    color: appearance.embed.errorColor,
                                                    description: `${newI.member}, **не возможно** поставить ночь`,
                                                    thumbnail: { url: iMemberAvatar }
                                                }
                                            ]
                                        }).catch(() => {});


                                        manageMessage.components.forEach(component => {

                                            let Comp = component.components;
                            
                                            for (c = 0; c < Comp.length; c++) {
                            
                                                if (Comp[c].data.custom_id == 'nigth') Comp[c].data.style = 3;
                                                if (Comp[c].data.custom_id == 'pause' || Comp[c].data.custom_id == 'endGame' || Comp[c].data.custom_id == 'anticipatorily') Comp[c].data.disabled = true;
                            
                                            };
                                            
                                        });

                                        await newI.update({ components: manageMessage.components });


                                        await startTrack (eventRecordChannel, eventVoiceChannel);

                                        let menu = {};
                                        let nigth = {
                                            killing: [],
                                            cheack: [],
                                            healing: []
                                        };

                                        const matchNigth = eventOfCategory.game.lasts.nigth.match(/^\d{1,99}(s|m|h|d|w)$/);
                                        const timeNigth = (+matchNigth[0].slice(0,-1))*(matchNigth[1]=='s'?1:matchNigth[1]=='m'?60:matchNigth[1]=='h'?60*60:matchNigth[1]=='d'?60*60*24:matchNigth[1]=='w'?60*60*24*7:0);

                                        const startNigth = Date.now()/1000; 
                                        const endNigth = Date.now()/1000+timeNigth; 
                                        game.vote = {members: [], vote: {}};
                                        if (game.message.vote) game.message.vote.edit(voteMessage ()).catch(() => {});

                                        game.time = 'nigth';
                                        for (const pickMember in game.members) {

                                            if (game.members[pickMember].alive) {

                                                const fetchPickMember = await guild.members.fetch(game.members[pickMember].id).catch(() => {});

                                                if (fetchPickMember) {

                                                    eventVoiceChannel.permissionOverwrites.edit(fetchPickMember.id, { Speak: false })
                                                        .then(() => {
                                                            fetchPickMember.voice.setChannel(eventVoiceChannel.id).catch(() => {});
                                                        })
                                                        .catch(() => {});
                                                    eventRecordChannel.permissionOverwrites.edit(fetchPickMember.id, { SendMessages: false }).catch(() => {});


                                                };

                                            };

                                        };

                                        for (const pickServer in game.servers) {

                                            for (const pickChannel in game.servers[pickServer].channels) {

                                                let pickChannelOfList = game.servers[pickServer].channels[pickChannel].config;
                                                
                                                for (const pickPermission in pickChannelOfList.permission) {

                                                    if (pickPermission == game.time) {

                                                        for (const pickPermissionOfTime in pickChannelOfList.permission[pickPermission]) {

                                                            if (pickChannelOfList.permission[pickPermission][pickPermissionOfTime].Role == 'everyone') game.servers[pickServer].channels[pickChannel].channel.permissionOverwrites.edit(game.servers[pickServer].guild.id, pickChannelOfList.permission[pickPermission][pickPermissionOfTime].Permission).catch(() => {});
                                                            else {

                                                                const pickRoleFetch = game.servers[pickServer].roles.find(role => role.name == pickChannelOfList.permission[pickPermission][pickPermissionOfTime].Role).role;
                                                                game.servers[pickServer].channels[pickChannel].channel.permissionOverwrites.edit(pickRoleFetch.id, pickChannelOfList.permission[pickPermission][pickPermissionOfTime].Permission).catch(() => {});
                                                                
                                                            };

                                                        };

                                                    };

                                                };

                                            };

                                        };


                                        setTimeout(() => {
                                            
                                            eventRecordChannel.send('⠀\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n⠀').catch(() => {});
                                            
                                            eventRecordChannel.send({
                                                embeds: [
                                                    {
                                                        title: `Ночь: ${eventOfCategory.name}`,
                                                        color: appearance.embed.color,
                                                        image: { url: eventOfCategory.game.image.nigth }
                                                    }
                                                ]
                                            }).catch(() => {});

                                        }, 1200);


                                        game.actions.day++;
                                        let textPresenter = '';
                                        for (const pickMember in game.members) {

                                            if (game.members[pickMember].alive) {

                                                const memberMenus = game.members[pickMember].role.menu;
                                                for (const pickMenu in memberMenus) {

                                                    if (memberMenus[pickMenu].additionally.list == 'members') {
                                                    
                                                        if (memberMenus[pickMenu].access.coincidence) {

                                                            if (!menu[memberMenus[pickMenu].id]) menu[memberMenus[pickMenu].id] = {
                                                                config: memberMenus[pickMenu],
                                                                message: false,
                                                                members: [],
                                                                choose: false
                                                            };

                                                            menu[memberMenus[pickMenu].id].members.push(
                                                                {
                                                                    choose: false, 
                                                                    number: game.members[pickMember].number
                                                                }
                                                            );

                                                            let memberNumber = game.members[pickMember].number;
                                                            if (!menuEvery[memberMenus[pickMenu].id] && !menuEvery[memberMenus[pickMenu].id]) menuEvery[memberMenus[pickMenu].id] = {};
                                                            if (memberMenus[pickMenu].additionally.self && memberMenus[pickMenu].additionally.selfTimes && menuEvery[memberMenus[pickMenu].id].selfOnce !== 0 && !menuEvery[memberMenus[pickMenu].id].selfOnce) menuEvery[memberMenus[pickMenu].id].selfOnce = memberMenus[pickMenu].additionally.selfTimes;
                                                            if (!memberMenus[pickMenu].additionally.repetition && !menuEvery[memberMenus[pickMenu].id].repetition) menuEvery[memberMenus[pickMenu].id].repetition = [];
                                                            if (memberMenus[pickMenu].additionally.once && !menuEvery[memberMenus[pickMenu].id].once) menuEvery[memberMenus[pickMenu].id].once = [];

                                                            if (textPresenter == '') textPresenter += `${menu[memberMenus[pickMenu].id].choose ? memberMenus[pickMenu].emoji.True : memberMenus[pickMenu].emoji.False}・${memberMenus[pickMenu].name}${menu[memberMenus[pickMenu].id].choose ? `: **${menu[memberMenus[pickMenu].id].choose.number}**` : ': Не выбрано'}`;
                                                            else textPresenter += `\n ${menu[memberMenus[pickMenu].id].choose ? memberMenus[pickMenu].emoji.True : memberMenus[pickMenu].emoji.False}・${memberMenus[pickMenu].name}${menu[memberMenus[pickMenu].id].choose ? `: **${menu[memberMenus[pickMenu].id].choose.number}**` : ': Не выбрано'}`;


                                                            const fetchPickMember = await guild.members.fetch(game.members[pickMember].id).catch(() => {});
                                                            let menuMessage = await fetchPickMember.send({
                                                                content: 'Загрузка...'
                                                            }).catch(() => {});

                                                            let componentsMenu = [];
                                                            componentsMenu.push(
                                                                {
                                                                    type: 1,
                                                                    components: []
                                                                }
                                                            );
                                                            
                
                                                            for (const pickMember in game.members) {
                                                                    
                                                                if (!componentsMenu[0] || componentsMenu[componentsMenu.length-1].components.length == 5) 
                                                                componentsMenu.push(
                                                                    {
                                                                        type: 1,
                                                                        components: []
                                                                    }
                                                                );
                    
                                                                if (!game.members[pickMember].alive && memberMenus[pickMenu].additionally.onlyLive) {
                
                                                                    componentsMenu[componentsMenu.length-1].components.push(
                                                                        {
                                                                            type: 2, 
                                                                            style: 4, 
                                                                            customId: `${game.members[pickMember].number}`,
                                                                            label: `${game.members[pickMember].number}`, 
                                                                            disabled: true
                                                                        }
                                                                    );
                
                                                                }
                    
                                                                else if (memberMenus[pickMenu].excludingRoles.includes(game.members[pickMember].role.name) || !memberMenus[pickMenu].additionally.self && game.members[pickMember].id == fetchPickMember.id) {
                
                                                                    componentsMenu[componentsMenu.length-1].components.push(
                                                                        {
                                                                            type: 2, 
                                                                            style: 2, 
                                                                            customId: `${game.members[pickMember].number}`,
                                                                            label: `${game.members[pickMember].number}`, 
                                                                            disabled: true
                                                                        }
                                                                    );
                
                                                                }
                    
                                                                else if (memberMenus[pickMenu].additionally.once && menuEvery[memberMenus[pickMenu].id].once.includes({ id: game.members[pickMember].id, number: game.members[pickMember].number}) || memberMenus[pickMenu].additionally.self && menuEvery[memberMenus[pickMenu].id].selfOnce == 0 && game.members[pickMember].id == fetchPickMember.id || !memberMenus[pickMenu].additionally.repetition && menuEvery[memberMenus[pickMenu].id].repetition.length > 0 && menuEvery[memberMenus[pickMenu].id].repetition[menuEvery[memberMenus[pickMenu].id].repetition.length-1].id == game.members[pickMember].id) {
                
                                                                    componentsMenu[componentsMenu.length-1].components.push(
                                                                        {
                                                                            type: 2, 
                                                                            style: 1, 
                                                                            customId: `${game.members[pickMember].number}`,
                                                                            label: `${game.members[pickMember].number}`, 
                                                                            disabled: true
                                                                        }
                                                                    );
                
                                                                }
                
                                                                else {
                
                                                                    componentsMenu[componentsMenu.length-1].components.push(
                                                                        {
                                                                            type: 2, 
                                                                            style: 2, 
                                                                            customId: `${game.members[pickMember].number}`,
                                                                            label: `${game.members[pickMember].number}`, 
                                                                            disabled: false
                                                                        }
                                                                    );
                
                                                                };

                                                                const collectorConponentsOfMenuMessage = await menuMessage.createMessageComponentCollector();
                                                                collectorConponentsOfMenuMessage.on('collect', async newI => {

                                                                    for (let pickMenu2 in menu) {
    
                                                                        if (memberMenus[pickMenu].access.menusNotActive.includes(pickMenu2) && menu[pickMenu2].choose == false) {
    
                                                                            return newI.reply({
                                                                                embeds: [
                                                                                    {
                                                                                        title: `${client.user.username} error`,
                                                                                        color: appearance.embed.color,
                                                                                        description: `${newI.user}, сначало **провзаимодействуйте** с меню **${menu[pickMenu2].config.name}**`,
                                                                                        thumbnail: { url: await getAvatar (newI.user) }
                                                                                    }
                                                                                ]
                                                                            }).catch(() => {});
    
                                                                        };
    
                                                                    };
                                                                    
                                                                    switch (newI.customId) { 
                                                            
                                                                        case `${game.members[pickMember].number}`: { 

                                                                            if (memberMenus[pickMenu].additionally.self && memberMenus[pickMenu].additionally.selfTimes && game.members[pickMember].id == fetchPickMember.id) menuEvery[memberMenus[pickMenu].id].selfOnce--;
                                                                            if (!memberMenus[pickMenu].additionally.repetition) menuEvery[memberMenus[pickMenu].id].repetition.push({id: game.members[pickMember].id, number: game.members[pickMember].number});
                                                                            if (memberMenus[pickMenu].additionally.once) menuEvery[memberMenus[pickMenu].id].once.push({id: game.members[pickMember].id, number: game.members[pickMember].number});
                

                                                                            menuMessage.components.forEach(component => {

                                                                                let Comp = component.components;
                                                                
                                                                                for (c = 0; c < Comp.length; c++) {
                                                                
                                                                                    if (Comp[c].data.custom_id == `${game.members[pickMember].number}`) Comp[c].data.style = 3;
                                                                                    Comp[c].data.disabled = true;
                                                                
                                                                                };
                                                                                
                                                                            });

                                                                            let emojiMenuStatus = true ? menu[memberMenus[pickMenu].id].config.emoji.True : menu[memberMenus[pickMenu].id].config.emoji.False;
                                                                            const emojiId = emojiMenuStatus.match(/<:[a-zA-Z0-9_]+:(\d+)>/)[1];

                                                                            const chooseMenuConst = {id: game.members[pickMember].id, number: game.members[pickMember].number}; 
                                                                            let allChoose = {id: game.members[pickMember].id, number: game.members[pickMember].number}; 

                                                                            for (const pickChoose of menu[memberMenus[pickMenu].id].members) if (memberNumber == pickChoose.number) pickChoose.choose = {id: game.members[pickMember].id, number: game.members[pickMember].number}; 
                                                                            for (const pickChoose of menu[memberMenus[pickMenu].id].members) if (!pickChoose.choose || pickChoose.choose.number !== allChoose.number) {
                                                                                allChoose = false;
                                                                            };
                                                                            if (allChoose !== false) {
                                                                                nigth[memberMenus[pickMenu].type].push(allChoose);
                                                                                menu[memberMenus[pickMenu].id].choose = allChoose;
                                                                            };
                                                                            
                                                                            newI.update({
                                                                                embeds: [
                                                                                    {
                                                                                        color: appearance.embed.color,
                                                                                        description: chooseMenuConst ? `## **${menu[memberMenus[pickMenu].id].config.name}**\nВыбрано: **${chooseMenuConst.number}**` : `## ${menu[memberMenus[pickMenu].id].config.name}\n-# Ночь **закончиться** <t:${Math.floor(endNigth)}:R>`,
                                                                                        thumbnail: { url: `https://cdn.discordapp.com/emojis/${emojiId}.png?size=64` }
                                                                                    }
                                                                                ],
                                                                                components: [

                                                                                ]
                                                                            }).catch(() => {});
                                                                            
                                                                        }

                                                                    };

                                                                });
                    
                                                            };


                                                            if (menuMessage) {
    
                                                                let emojiMenuStatus = false ? memberMenus[pickMenu].emoji.True : memberMenus[pickMenu].emoji.False;
                                                                const emojiId = emojiMenuStatus.match(/<:[a-zA-Z0-9_]+:(\d+)>/)[1];
    
                                                                menuMessage.edit({
                                                                    content: ' ',
                                                                    embeds: [
                                                                        {
                                                                            color: appearance.embed.color,
                                                                            description: false ? `## **${memberMenus[pickMenu].name}**\nВыбрано: **${menu[pickMenu].choose.number}**` : `## ${memberMenus[pickMenu].name}\n-# Ночь **закончиться** <t:${Math.floor(endNigth)}:R>`,
                                                                            thumbnail: { url: `https://cdn.discordapp.com/emojis/${emojiId}.png?size=64` }
                                                                        }
                                                                    ],
                                                                    components: componentsMenu
                                                                }).catch(() => {});

                                                            };

                                                            menu[memberMenus[pickMenu].id] = {
                                                                members: menu[memberMenus[pickMenu].id].members,
                                                                config: memberMenus[pickMenu],
                                                                message: menuMessage,
                                                                choose: false
                                                            };

                                                        }
    
                                                        else {

                                                            if (!menu[memberMenus[pickMenu].id]) menu[memberMenus[pickMenu].id] = {
                                                                config: memberMenus[pickMenu],
                                                                message: false,
                                                                choose: false
                                                            };

                                                            if (!menuEvery[memberMenus[pickMenu].id] && !menuEvery[memberMenus[pickMenu].id]) menuEvery[memberMenus[pickMenu].id] = {};
                                                            if (memberMenus[pickMenu].additionally.self && memberMenus[pickMenu].additionally.selfTimes && menuEvery[memberMenus[pickMenu].id].selfOnce !== 0 && !menuEvery[memberMenus[pickMenu].id].selfOnce) menuEvery[memberMenus[pickMenu].id].selfOnce = memberMenus[pickMenu].additionally.selfTimes;
                                                            if (!memberMenus[pickMenu].additionally.repetition && !menuEvery[memberMenus[pickMenu].id].repetition) menuEvery[memberMenus[pickMenu].id].repetition = [];
                                                            if (memberMenus[pickMenu].additionally.once && !menuEvery[memberMenus[pickMenu].id].once) menuEvery[memberMenus[pickMenu].id].once = [];

                                                            if (textPresenter == '') textPresenter += `${menu[memberMenus[pickMenu].id].choose ? memberMenus[pickMenu].emoji.True : memberMenus[pickMenu].emoji.False}・${memberMenus[pickMenu].name}${menu[memberMenus[pickMenu].id].choose ? `: **${menu[memberMenus[pickMenu].id].choose.number}**` : ': Не выбрано'}`;
                                                            else textPresenter += `\n ${menu[memberMenus[pickMenu].id].choose ? memberMenus[pickMenu].emoji.True : memberMenus[pickMenu].emoji.False}・${memberMenus[pickMenu].name}${menu[memberMenus[pickMenu].id].choose ? `: **${menu[memberMenus[pickMenu].id].choose.number}**` : ': Не выбрано'}`;


                                                            const fetchPickMember = await guild.members.fetch(game.members[pickMember].id).catch(() => {});
                                                            let menuMessage = await fetchPickMember.send({
                                                                content: 'Загрузка...'
                                                            }).catch(() => {});

                                                            let componentsMenu = [];
                                                            componentsMenu.push(
                                                                {
                                                                    type: 1,
                                                                    components: []
                                                                }
                                                            );
                                                            
                
                                                            for (const pickMember in game.members) {
                                                                    
                                                                if (!componentsMenu[0] || componentsMenu[componentsMenu.length-1].components.length == 5) 
                                                                componentsMenu.push(
                                                                    {
                                                                        type: 1,
                                                                        components: []
                                                                    }
                                                                );
                    
                                                                if (!game.members[pickMember].alive && memberMenus[pickMenu].additionally.onlyLive) {
                
                                                                    componentsMenu[componentsMenu.length-1].components.push(
                                                                        {
                                                                            type: 2, 
                                                                            style: 4, 
                                                                            customId: `${game.members[pickMember].number}`,
                                                                            label: `${game.members[pickMember].number}`, 
                                                                            disabled: true
                                                                        }
                                                                    );
                
                                                                }
                    
                                                                else if (memberMenus[pickMenu].excludingRoles.includes(game.members[pickMember].role.name) || !memberMenus[pickMenu].additionally.self && game.members[pickMember].id == fetchPickMember.id) {
                
                                                                    componentsMenu[componentsMenu.length-1].components.push(
                                                                        {
                                                                            type: 2, 
                                                                            style: 2, 
                                                                            customId: `${game.members[pickMember].number}`,
                                                                            label: `${game.members[pickMember].number}`, 
                                                                            disabled: true
                                                                        }
                                                                    );
                
                                                                }
                    
                                                                else if (memberMenus[pickMenu].additionally.once && menuEvery[memberMenus[pickMenu].id].once.includes({ id: game.members[pickMember].id, number: game.members[pickMember].number}) || memberMenus[pickMenu].additionally.self && menuEvery[memberMenus[pickMenu].id].selfOnce == 0 && game.members[pickMember].id == fetchPickMember.id || !memberMenus[pickMenu].additionally.repetition && menuEvery[memberMenus[pickMenu].id].repetition.length > 0 && menuEvery[memberMenus[pickMenu].id].repetition[menuEvery[memberMenus[pickMenu].id].repetition.length-1].id == game.members[pickMember].id) {
                
                                                                    componentsMenu[componentsMenu.length-1].components.push(
                                                                        {
                                                                            type: 2, 
                                                                            style: 1, 
                                                                            customId: `${game.members[pickMember].number}`,
                                                                            label: `${game.members[pickMember].number}`, 
                                                                            disabled: true
                                                                        }
                                                                    );
                
                                                                }
                
                                                                else {
                
                                                                    componentsMenu[componentsMenu.length-1].components.push(
                                                                        {
                                                                            type: 2, 
                                                                            style: 2, 
                                                                            customId: `${game.members[pickMember].number}`,
                                                                            label: `${game.members[pickMember].number}`, 
                                                                            disabled: false
                                                                        }
                                                                    );
                
                                                                };

                                                                const collectorConponentsOfMenuMessage = await menuMessage.createMessageComponentCollector();
                                                                collectorConponentsOfMenuMessage.on('collect', async newI => {

                                                                    for (let pickMenu2 in menu) {
    
                                                                        if (memberMenus[pickMenu].access.menusNotActive.includes(pickMenu2) && menu[pickMenu2].choose == false) {
    
                                                                            return newI.reply({
                                                                                embeds: [
                                                                                    {
                                                                                        title: `${client.user.username} error`,
                                                                                        color: appearance.embed.color,
                                                                                        description: `${newI.user}, сначало **провзаимодействуйте** с меню **${menu[pickMenu2].config.name}**`,
                                                                                        thumbnail: { url: await getAvatar (newI.user) }
                                                                                    }
                                                                                ]
                                                                            }).catch(() => {});
    
                                                                        };
    
                                                                    };
                                                                    
                                                                    switch (newI.customId) { 
                                                            
                                                                        case `${game.members[pickMember].number}`: { 

                                                                            menu[memberMenus[pickMenu].id].choose = {id: game.members[pickMember].id, number: game.members[pickMember].number};
                                                                            if (memberMenus[pickMenu].additionally.self && memberMenus[pickMenu].additionally.selfTimes && game.members[pickMember].id == fetchPickMember.id) menuEvery[memberMenus[pickMenu].id].selfOnce--;
                                                                            if (!memberMenus[pickMenu].additionally.repetition) menuEvery[memberMenus[pickMenu].id].repetition.push({id: game.members[pickMember].id, number: game.members[pickMember].number});
                                                                            if (memberMenus[pickMenu].additionally.once) menuEvery[memberMenus[pickMenu].id].once.push({id: game.members[pickMember].id, number: game.members[pickMember].number});
                

                                                                            menuMessage.components.forEach(component => {

                                                                                let Comp = component.components;
                                                                
                                                                                for (c = 0; c < Comp.length; c++) {
                                                                
                                                                                    if (Comp[c].data.custom_id == `${game.members[pickMember].number}`) Comp[c].data.style = 3;
                                                                                    Comp[c].data.disabled = true;
                                                                
                                                                                };
                                                                                
                                                                            });
                                        
                                                                            await menuMessage.edit({ components: menuMessage.components });

                                                                            if (memberMenus[pickMenu].type == 'checking') {

                                                                                let emojiMenuStatus = menu[memberMenus[pickMenu].id].choose ? menu[memberMenus[pickMenu].id].config.emoji.True : menu[memberMenus[pickMenu].id].config.emoji.False;
                                                                                const emojiId = emojiMenuStatus.match(/<:[a-zA-Z0-9_]+:(\d+)>/)[1];

                                                                                nigth.cheack.push({roles: memberMenus[pickMenu].checkRoles, id: game.members[pickMember].id, number: game.members[pickMember].number});
                                                                                newI.update({
                                                                                    embeds: [
                                                                                        {
                                                                                            color: appearance.embed.color,
                                                                                            description: menu[memberMenus[pickMenu].id].choose ? `## **${menu[memberMenus[pickMenu].id].config.name}**\nВыбрано: **${menu[memberMenus[pickMenu].id].choose.number}**` : `## ${menu[memberMenus[pickMenu].id].config.name}\n-# Ночь **закончиться** <t:${Math.floor(endNigth)}:R>`,
                                                                                            thumbnail: { url: `https://cdn.discordapp.com/emojis/${emojiId}.png?size=64` }
                                                                                        }
                                                                                    ],
                                                                                    components: [
    
                                                                                    ]
                                                                                }).catch(() => {});

                                                                                let textTeam = '';
                                                                                let textMenuMemberReply = '';
                                                                                for (let pickTeam in eventOfCategory.game.teams) {

                                                                                    if (eventOfCategory.game.teams[pickTeam].roles.includes(game.members[pickMember].role.name)) {

                                                                                        if (textMenuMemberReply == '') textTeam += `**${pickTeam}**`;
                                                                                        else textTeam += `, **${pickTeam}**`;

                                                                                    }
                        
                                                                                };

                                                                                for (let pickRole in memberMenus[pickMenu].checkRoles) {

                                                                                    let role = eventOfCategory.game.role.list[memberMenus[pickMenu].checkRoles[pickRole]];
                                                                                    if (textMenuMemberReply == '') textMenuMemberReply += `**${role.name}**`;
                                                                                    else textMenuMemberReply += `, **${role.name}**`;
                        
                                                                                };

                                                                                menuMessage.reply({
                                                                                    embeds: [
                                                                                        {
                                                                                            color: appearance.embed.color,
                                                                                            description: `Вы проверили игрока **${game.members[pickMember].number}**${memberMenus[pickMenu].showRoles ? !memberMenus[pickMenu].checkRoles.includes(game.members[pickMember].role.name) ? `\nПромах, не имеет роль(и): ${textMenuMemberReply}` : `\nИмеет роль(и): ${textMenuMemberReply}` : ''}${memberMenus[pickMenu].showTeam ? `\nКоманда: ${textTeam}` : ''}`
                                                                                        }
                                                                                    ],
                                                                                    components: [
    
                                                                                    ]
                                                                                }).catch(() => {});
                                                                                
                                                                            }
                                                                            
                                                                            else {

                                                                                let emojiMenuStatus = menu[memberMenus[pickMenu].id].choose ? menu[memberMenus[pickMenu].id].config.emoji.True : menu[memberMenus[pickMenu].id].config.emoji.False;
                                                                                const emojiId = emojiMenuStatus.match(/<:[a-zA-Z0-9_]+:(\d+)>/)[1];

                                                                                nigth[memberMenus[pickMenu].type].push({id: game.members[pickMember].id, number: game.members[pickMember].number});
                                                                                newI.update({
                                                                                    embeds: [
                                                                                        {
                                                                                            color: appearance.embed.color,
                                                                                            description: menu[memberMenus[pickMenu].id].choose ? `## **${menu[memberMenus[pickMenu].id].config.name}**\nВыбрано: **${menu[memberMenus[pickMenu].id].choose.number}**` : `## ${menu[memberMenus[pickMenu].id].config.name}\n-# Ночь **закончиться** <t:${Math.floor(endNigth)}:R>`,
                                                                                            thumbnail: { url: `https://cdn.discordapp.com/emojis/${emojiId}.png?size=64` }
                                                                                        }
                                                                                    ],
                                                                                    components: [
    
                                                                                    ]
                                                                                }).catch(() => {});

                                                                            };  
                                                                            
                                                                        }

                                                                    };

                                                                });
                    
                                                            };


                                                            if (menuMessage) {
    
                                                                let emojiMenuStatus = false ? memberMenus[pickMenu].emoji.True : memberMenus[pickMenu].emoji.False;
                                                                const emojiId = emojiMenuStatus.match(/<:[a-zA-Z0-9_]+:(\d+)>/)[1];
    
                                                                menuMessage.edit({
                                                                    content: ' ',
                                                                    embeds: [
                                                                        {
                                                                            color: appearance.embed.color,
                                                                            description: false ? `## **${memberMenus[pickMenu].name}**\nВыбрано: **${menu[pickMenu].choose.number}**` : `## ${memberMenus[pickMenu].name}\n-# Ночь **закончиться** <t:${Math.floor(endNigth)}:R>`,
                                                                            thumbnail: { url: `https://cdn.discordapp.com/emojis/${emojiId}.png?size=64` }
                                                                        }
                                                                    ],
                                                                    components: componentsMenu
                                                                }).catch(() => {});

                                                            };

                                                            menu[memberMenus[pickMenu].id] = {
                                                                config: memberMenus[pickMenu],
                                                                message: menuMessage,
                                                                choose: false
                                                            };
    
                                                        };
                                                            
                                                    };

                                                };

                                            };

                                        };

                                        for (const pickServer in eventOfCategory.game.servers) {

                                            const serverMenus = eventOfCategory.game.servers[pickServer].parameters.menu;
                                            for (const pickMenu in serverMenus) {

                                                let access = [];
                                                let accessText = '';
                                                
                                                for (const pickRole in serverMenus[pickMenu].access.role) {
                                                    
                                                    for (const pickMember in game.members) {

                                                        if (serverMenus[pickMenu].access.role[pickRole] == game.members[pickMember].role.name && game.members[pickMember].alive) {

                                                            if (serverMenus[pickMenu].access.all) {

                                                                if (serverMenus[pickMenu].access.withLowerNumber) {
                                                                    
                                                                    let otherNumber = [];
                                                                    let memberAccess = true;
                                                                    for (const pickMember2 in game.members) if (game.members[pickMember2].alive && game.members[pickMember2].id !== game.members[pickMember].id && game.members[pickMember2].role.name == game.members[pickMember].role.name) otherNumber.push(game.members[pickMember2].number); 
                                                                    for (const a in otherNumber) if (otherNumber[a] < game.members[pickMember].number) memberAccess = false; 

                                                                    if (memberAccess) access.push(game.members[pickMember]);

                                                                }

                                                                else {

                                                                    access.push(game.members[pickMember]);

                                                                };

                                                            }
                                                            
                                                            else if (!access[0]) {

                                                                if (serverMenus[pickMenu].access.withLowerNumber) {
                                                                    
                                                                    let otherNumber = [];
                                                                    let memberAccess = true;
                                                                    for (const pickMember2 in game.members) if (game.members[pickMember2].alive && game.members[pickMember2].id !== game.members[pickMember].id && game.members[pickMember2].role.name == game.members[pickMember].role.name) otherNumber.push(game.members[pickMember2].number); 
                                                                    for (const a in otherNumber) if (otherNumber[a] < game.members[pickMember].number) memberAccess = false; 

                                                                    if (memberAccess) access.push(game.members[pickMember]);

                                                                }

                                                                else {

                                                                    access.push(game.members[pickMember]);

                                                                };

                                                            };

                                                        };

                                                    };

                                                };

                                                if (serverMenus[pickMenu].additionally.list == 'members' && access[0]) {

                                                    for (let accessMember in access) {

                                                        if (accessText == '') accessText += `<@${access[accessMember].id}>`;
                                                        else accessText += `, <@${access[accessMember].id}>`;

                                                    };

                                                    if (!menu[serverMenus[pickMenu].id]) menu[serverMenus[pickMenu].id] = {
                                                        config: serverMenus[pickMenu],
                                                        message: false,
                                                        choose: false
                                                    };

                                                    if (!menuEvery[serverMenus[pickMenu].id] && !menuEvery[serverMenus[pickMenu].id]) menuEvery[serverMenus[pickMenu].id] = {};
                                                    if (serverMenus[pickMenu].additionally.self && serverMenus[pickMenu].additionally.selfTimes && menuEvery[serverMenus[pickMenu].id].selfOnce !== 0 && !menuEvery[serverMenus[pickMenu].id].selfOnce) menuEvery[serverMenus[pickMenu].id].selfOnce = serverMenus[pickMenu].additionally.selfTimes;
                                                    if (!serverMenus[pickMenu].additionally.repetition && !menuEvery[serverMenus[pickMenu].id].repetition) menuEvery[serverMenus[pickMenu].id].repetition = [];
                                                    if (serverMenus[pickMenu].additionally.once && !menuEvery[serverMenus[pickMenu].id].once) menuEvery[serverMenus[pickMenu].id].once = [];

                                                    if (textPresenter == '') textPresenter += `${menu[serverMenus[pickMenu].id].choose ? serverMenus[pickMenu].emoji.True : serverMenus[pickMenu].emoji.False}・${serverMenus[pickMenu].name}${menu[serverMenus[pickMenu].id].choose ? `: **${menu[serverMenus[pickMenu].id].choose.number}**` : ': Не выбрано'}`;
                                                    else textPresenter += `\n ${menu[serverMenus[pickMenu].id].choose ? serverMenus[pickMenu].emoji.True : serverMenus[pickMenu].emoji.False}・${serverMenus[pickMenu].name}${menu[serverMenus[pickMenu].id].choose ? `: **${menu[serverMenus[pickMenu].id].choose.number}**` : ': Не выбрано'}`;

                                                    const channelFetch = game.servers[pickServer].channels.find(channel => channel.name == serverMenus[pickMenu].channel).channel;
                                                    let menuMessage = await channelFetch.send({
                                                        content: 'Загрузка...'
                                                    }).catch(() => {});

                                                    let componentsMenu = [];
                                                    componentsMenu.push(
                                                        {
                                                            type: 1,
                                                            components: []
                                                        }
                                                    );
                                                    
        
                                                    for (const pickMember in game.members) {
                                                            
                                                        if (!componentsMenu[0] || componentsMenu[componentsMenu.length-1].components.length == 5) 
                                                        componentsMenu.push(
                                                            {
                                                                type: 1,
                                                                components: []
                                                            }
                                                        );
            
                                                        if (!game.members[pickMember].alive && serverMenus[pickMenu].additionally.onlyLive) {
        
                                                            componentsMenu[componentsMenu.length-1].components.push(
                                                                {
                                                                    type: 2, 
                                                                    style: 4, 
                                                                    customId: `${game.members[pickMember].number}`,
                                                                    label: `${game.members[pickMember].number}`, 
                                                                    disabled: true
                                                                }
                                                            );
        
                                                        }
            
                                                        else if (serverMenus[pickMenu].excludingRoles.includes(game.members[pickMember].role.name) || !serverMenus[pickMenu].additionally.self && access.find(member => member.id == game.members[pickMember].id)) {
        
                                                            componentsMenu[componentsMenu.length-1].components.push(
                                                                {
                                                                    type: 2, 
                                                                    style: 2, 
                                                                    customId: `${game.members[pickMember].number}`,
                                                                    label: `${game.members[pickMember].number}`, 
                                                                    disabled: true
                                                                }
                                                            );
        
                                                        }
            
                                                        else if (serverMenus[pickMenu].additionally.once && menuEvery[serverMenus[pickMenu].id].once.includes({ id: game.members[pickMember].id, number: game.members[pickMember].number}) || serverMenus[pickMenu].additionally.self && menuEvery[serverMenus[pickMenu].id].selfOnce == 0 && access.find(member => member.id == game.members[pickMember].id) || !serverMenus[pickMenu].additionally.repetition && menuEvery[serverMenus[pickMenu].id].repetition[menuEvery[serverMenus[pickMenu].id].repetition.length-1] && menuEvery[serverMenus[pickMenu].id].repetition[menuEvery[serverMenus[pickMenu].id].repetition.length-1].id == game.members[pickMember].id) {
        
                                                            componentsMenu[componentsMenu.length-1].components.push(
                                                                {
                                                                    type: 2, 
                                                                    style: 1, 
                                                                    customId: `${game.members[pickMember].number}`,
                                                                    label: `${game.members[pickMember].number}`, 
                                                                    disabled: true
                                                                }
                                                            );
        
                                                        }
        
                                                        else {
        
                                                            componentsMenu[componentsMenu.length-1].components.push(
                                                                {
                                                                    type: 2, 
                                                                    style: 2, 
                                                                    customId: `${game.members[pickMember].number}`,
                                                                    label: `${game.members[pickMember].number}`, 
                                                                    disabled: false
                                                                }
                                                            );
        
                                                        };

                                                        const collectorConponentsOfMenuMessage = await menuMessage.createMessageComponentCollector();
                                                        collectorConponentsOfMenuMessage.on('collect', async newI => {
                                                            
                                                            if (!access.find(member => member.id == newI.member.id)) return;
                                                            for (let pickMenu2 in menu) {

                                                                if (serverMenus[pickMenu].access.menusNotActive.includes(pickMenu2) && menu[pickMenu2].choose == false) {

                                                                    return newI.reply({
                                                                        embeds: [
                                                                            {
                                                                                title: `${client.user.username} error`,
                                                                                color: appearance.embed.color,
                                                                                description: `${newI.member}, сначало **провзаимодействуйте** с меню **${menu[pickMenu2].config.name}**`,
                                                                                thumbnail: { url: await getAvatar (newI.member) }
                                                                            }
                                                                        ]
                                                                    }).catch(() => {});

                                                                };

                                                            };
                                                            
                                                            switch (newI.customId) { 
                                                    
                                                                case `${game.members[pickMember].number}`: { 

                                                                    menu[serverMenus[pickMenu].id].choose = {id: game.members[pickMember].id, number: game.members[pickMember].number};
                                                                    if (serverMenus[pickMenu].additionally.self && serverMenus[pickMenu].additionally.selfTimes && access.find(member => member.id == game.members[pickMember].id)) menuEvery[serverMenus[pickMenu].id].selfOnce--;
                                                                    if (!serverMenus[pickMenu].additionally.repetition) menuEvery[serverMenus[pickMenu].id].repetition.push({id: game.members[pickMember].id, number: game.members[pickMember].number});
                                                                    if (serverMenus[pickMenu].additionally.once) menuEvery[serverMenus[pickMenu].id].once.push({id: game.members[pickMember].id, number: game.members[pickMember].number});
        

                                                                    menuMessage.components.forEach(component => {

                                                                        let Comp = component.components;
                                                        
                                                                        for (c = 0; c < Comp.length; c++) {
                                                        
                                                                            if (Comp[c].data.custom_id == `${game.members[pickMember].number}`) Comp[c].data.style = 3;
                                                                            Comp[c].data.disabled = true;
                                                        
                                                                        };
                                                                        
                                                                    });
                                
                                                                    await menuMessage.edit({ components: menuMessage.components });

                                                                    if (serverMenus[pickMenu].type == 'checking') {

                                                                        let emojiMenuStatus = menu[serverMenus[pickMenu].id].choose ? menu[serverMenus[pickMenu].id].config.emoji.True : menu[serverMenus[pickMenu].id].config.emoji.False;
                                                                        const emojiId = emojiMenuStatus.match(/<:[a-zA-Z0-9_]+:(\d+)>/)[1];

                                                                        nigth.cheack.push({roles: serverMenus[pickMenu].checkRoles, id: game.members[pickMember].id, number: game.members[pickMember].number});
                                                                        newI.update({
                                                                            embeds: [
                                                                                {
                                                                                    color: appearance.embed.color,
                                                                                    description: menu[serverMenus[pickMenu].id].choose ? `## **${menu[serverMenus[pickMenu].id].config.name}**\nВыбрано: **${menu[serverMenus[pickMenu].id].choose.number}**` : `## ${menu[serverMenus[pickMenu].id].config.name}\n-# Ночь **закончиться** <t:${Math.floor(endNigth)}:R>`,
                                                                                    thumbnail: { url: `https://cdn.discordapp.com/emojis/${emojiId}.png?size=64` }
                                                                                }
                                                                            ],
                                                                            components: [

                                                                            ]
                                                                        }).catch(() => {});

                                                                        let textTeam = '';
                                                                        let textMenuMemberReply = '';
                                                                        for (let pickTeam in eventOfCategory.game.teams) {

                                                                            if (eventOfCategory.game.teams[pickTeam].roles.includes(game.members[pickMember].role.name)) {

                                                                                if (textMenuMemberReply == '') textTeam += `**${pickTeam}**`;
                                                                                else textTeam += `, **${pickTeam}**`;

                                                                            }
                
                                                                        };

                                                                        for (let pickRole in serverMenus[pickMenu].checkRoles) {

                                                                            let role = eventOfCategory.game.role.list[serverMenus[pickMenu].checkRoles[pickRole]];
                                                                            if (textMenuMemberReply == '') textMenuMemberReply += `**${role.name}**`;
                                                                            else textMenuMemberReply += `, **${role.name}**`;
                
                                                                        };

                                                                        menuMessage.reply({
                                                                            embeds: [
                                                                                {
                                                                                    color: appearance.embed.color,
                                                                                    description: `Вы проверили игрока **${game.members[pickMember].number}**${serverMenus[pickMenu].showRoles ? !serverMenus[pickMenu].checkRoles.includes(game.members[pickMember].role.name) ? `\nПромах, не имеет роль(и): ${textMenuMemberReply}` : `\nИмеет роль(и): ${textMenuMemberReply}` : ''}${serverMenus[pickMenu].showTeam ? `\nКоманда: ${textTeam}` : ''}`
                                                                                }
                                                                            ]
                                                                        }).catch(() => {});
                                                                        
                                                                    }
                                                                    
                                                                    else {

                                                                        let emojiMenuStatus = menu[serverMenus[pickMenu].id].choose ? menu[serverMenus[pickMenu].id].config.emoji.True : menu[serverMenus[pickMenu].id].config.emoji.False;
                                                                        const emojiId = emojiMenuStatus.match(/<:[a-zA-Z0-9_]+:(\d+)>/)[1];

                                                                        nigth[serverMenus[pickMenu].type].push({id: game.members[pickMember].id, number: game.members[pickMember].number});
                                                                        newI.update({
                                                                            embeds: [
                                                                                {
                                                                                    color: appearance.embed.color,
                                                                                    description: menu[serverMenus[pickMenu].id].choose ? `## **${menu[serverMenus[pickMenu].id].config.name}**\nВыбрано: **${menu[serverMenus[pickMenu].id].choose.number}**` : `## ${menu[serverMenus[pickMenu].id].config.name}\n-# Ночь **закончиться** <t:${Math.floor(endNigth)}:R>`,
                                                                                    thumbnail: { url: `https://cdn.discordapp.com/emojis/${emojiId}.png?size=64` }
                                                                                }
                                                                            ],
                                                                            components: [
                                                                                
                                                                            ]
                                                                        }).catch(() => {});

                                                                    };  
                                                                    
                                                                }

                                                            };

                                                        });
            
                                                    };


                                                    if (menuMessage) {
    
                                                        let emojiMenuStatus = false ? serverMenus[pickMenu].emoji.True : serverMenus[pickMenu].emoji.False;
                                                        const emojiId = emojiMenuStatus.match(/<:[a-zA-Z0-9_]+:(\d+)>/)[1];

                                                        menuMessage.edit({
                                                            content: accessText,
                                                            embeds: [
                                                                {
                                                                    color: appearance.embed.color,
                                                                    description: false ? `## **${serverMenus[pickMenu].name}**\nВыбрано: **${menu[pickMenu].choose.number}**` : `## ${serverMenus[pickMenu].name}\n-# Ночь **закончиться** <t:${Math.floor(endNigth)}:R>`,
                                                                    thumbnail: { url: `https://cdn.discordapp.com/emojis/${emojiId}.png?size=64` }
                                                                }
                                                            ],
                                                            components: componentsMenu
                                                        }).catch(() => {});

                                                    };

                                                    menu[serverMenus[pickMenu].id] = {
                                                        config: serverMenus[pickMenu],
                                                        message: menuMessage,
                                                        choose: false
                                                    };
                                                        
                                                }

                                                else {
                                                    
                                                };

                                            };

                                        };

                                        const memberOfEventOwner = await guild.members.fetch(guilds[EventId].Owner).catch(() => {});
                                        if (memberOfEventOwner)
                                        game.message.nigth = await memberOfEventOwner.send({
                                            embeds: [
                                                {
                                                    title: `Ночь: ${eventOfCategory.name}`,
                                                    color: appearance.embed.color,
                                                    description: `Загрузка...`
                                                }
                                            ]
                                        }).catch(() => {});

                                        let timeStart = Date.now()/1000;
                                        const nigthInterval = setInterval(async () => {

                                            let ready = true;
                                            for (const pickMenu in menu) if (menu[pickMenu].choose == false) ready = false;

                                            if (guilds[EventId].deleted) {

                                                cancelTrack ();

                                                if (game.message.nigth) game.message.nigth.edit({
                                                    embeds: [
                                                        {
                                                            title: `Ночь: ${eventOfCategory.name}`,
                                                            color: appearance.embed.color,
                                                            description: `Игра была **завершена**`
                                                        }
                                                    ]
                                                }).catch(() => {});
                                                clearInterval(nigthInterval);
    
                                            }

                                            else if (/*ready || */endNigth <= Date.now()/1000) {

                                                cancelTrack ();
                                                clearInterval(nigthInterval);


                                                manageMessage.components.forEach(component => {
        
                                                    let Comp = component.components;
                                    
                                                    for (c = 0; c < Comp.length; c++) {
                                    
                                                        if (Comp[c].data.custom_id == 'nigth') Comp[c].data.style = 2;
                                                        if (Comp[c].data.custom_id == 'pause' || Comp[c].data.custom_id == 'endGame' || Comp[c].data.custom_id == 'anticipatorily') Comp[c].data.disabled = false;
                                    
                                                    };
                                                    
                                                });
        
                                                await manageMessage.edit({ components: manageMessage.components });

                                                
                                                let nigthOfInformation = '';
                                                for (const pickMenu in menu) {

                                                    if (nigthOfInformation == '') nigthOfInformation += `**${menu[pickMenu].config.name}**・${menu[pickMenu].choose ? `${getNumber(menu[pickMenu].choose.number)}` : 'Не выбрано'}`;
                                                    else nigthOfInformation += `\n**${menu[pickMenu].config.name}**・${menu[pickMenu].choose ? `${getNumber(menu[pickMenu].choose.number)}` : 'Не выбрано'}`;
    
                                                };

                                                if (allNigth == '') allNigth += `### Результаты ночи #${game.actions.day}\n${nigthOfInformation || 'Отсутствуют'}`;
                                                else allNigth += `\n### Результаты ночи #${game.actions.day}\n${nigthOfInformation || 'Отсутствуют'}`;

                                                let kill = [];
                                                let textKill = '';
                                                for (let pickKill in nigth.killing) if (!nigth.healing.find(member => member.id == nigth.killing[pickKill].id)) kill.push(nigth.killing[pickKill]);
                                                for (let pickHeal in nigth.healing) game.history.heal.push(nigth.healing[pickHeal]);
                                                for (let pickCheack in nigth.cheack) game.history.cheack.push(nigth.cheack[pickCheack]);
                                                for (const pickKill in kill) {

                                                    game.history.kill.push(kill[pickKill]);

                                                    if (textKill == '') textKill += `**${kill[pickKill].number}**`;
                                                    else textKill += `, **${kill[pickKill].number}**`;
    
                                                };

                                                for (const pickMenu in menu) {
        
                                                    if (menu[pickMenu].choose == false) {

                                                        if (menu[pickMenu].message) {

                                                            menu[pickMenu].message.components.forEach(component => {

                                                                let Comp = component.components;
                                                
                                                                for (c = 0; c < Comp.length; c++) {
                                                
                                                                    Comp[c].data.disabled = true;
                                                
                                                                };
                                                                
                                                            });

                                                            let emojiMenuStatus = menu[pickMenu].choose ? menu[pickMenu].config.emoji.True : menu[pickMenu].config.emoji.False;
                                                            const emojiId = emojiMenuStatus.match(/<:[a-zA-Z0-9_]+:(\d+)>/)[1];

                                                            menu[pickMenu].message.edit({
                                                                content: ' ',
                                                                embeds: [
                                                                    {
                                                                        color: appearance.embed.color,
                                                                        description: `## **${menu[pickMenu].config.name}**\n-# Ночь закончилась, вы **не успели** сделать ход`,
                                                                        thumbnail: { url: `https://cdn.discordapp.com/emojis/${emojiId}.png?size=64` }
                                                                    }
                                                                ],
                                                                components: [

                                                                ]
                                                            }).catch(() => {});

                                                        };

                                                    };

                                                };

                                                async function dayKills (kills, message) {

                                                    let resultKickMembers = '';
                                                    let componentsResultKickMembers = [];
                                                    componentsResultKickMembers.push(
                                                        {
                                                            type: 1,
                                                            components: []
                                                        }
                                                    );

                                                    for (const pickMember in kills) {
                                                                    
                                                        const pickMemberKillOfGame = game.members.find(member => member.id == kills[pickMember].id);
                                                        const fetchPickMember = await guild.members.fetch(pickMemberKillOfGame.id).catch(() => {});

                                                        if (resultKickMembers == '') resultKickMembers += `**${pickMemberKillOfGame.number}**`;
                                                        else resultKickMembers += `, **${pickMemberKillOfGame.number}**`;
                
                                                        if (!componentsResultKickMembers[0] || componentsResultKickMembers[componentsResultKickMembers.length-1].components.length == 5) 
                                                        componentsResultKickMembers.push(
                                                            {
                                                                type: 1,
                                                                components: []
                                                            }
                                                        );
                
                                                        componentsResultKickMembers[componentsResultKickMembers.length-1].components.push(
                                                            {
                                                                type: 2, 
                                                                style: 4, 
                                                                customId: `kick${pickMemberKillOfGame.number}`,
                                                                label: `${pickMemberKillOfGame.number}⠀Убрать убитого игрока`
                                                            }
                                                        );

                                                        const collectorConponentsOfmMessage = await message.createMessageComponentCollector();
                                                        collectorConponentsOfmMessage.on('collect', async newI => {
                                                            
                                                            if (newI.member.id !== guilds[EventId].Owner) return;
                                
                                                            switch (newI.customId) { 

                                                                case `kick${pickMemberKillOfGame.number}`: {
                    
                                                                    game.members.find(member => member.id == fetchPickMember.id).alive = false;
                                                                    if (fetchPickMember) fetchPickMember.setNickname(pickMemberKillOfGame.nickName).catch(() => {});
                                                                    for (n=0; n < game.servers.length; n++) {
            
                                                                        game.servers[n].guild.members.fetch().catch(() => {});
                                                                        const fetchPickMemberOfPickServer = await game.servers[n].guild.members.fetch(fetchPickMember.id).catch(() => {});
            
                                                                        if (fetchPickMemberOfPickServer) fetchPickMemberOfPickServer.kick().catch(() => {});
            
                                                                    };

                                                                    message.components.forEach(component => {

                                                                        let Comp = component.components;
                                                        
                                                                        for (c = 0; c < Comp.length; c++) {
                                                        
                                                                            if (Comp[c].data.style !== 5 && Comp[c].data.custom_id == `kick${pickMemberKillOfGame.number}`) Comp[c].data.disabled = true;
                                                        
                                                                        };
                                                                        
                                                                    });
                                
                                                                    await newI.update({ components: message.components });

                                                                    const messageOfKick = await message.reply({  
                                                                        content: `||${fetchPickMember}||`,
                                                                        embeds: [
                                                                            {
                                                                                title: `Убийство: ${eventOfCategory.name}`,
                                                                                color: eventOfCategory.game.actions.nigthKill.color,
                                                                                description: `Тип: ${eventOfCategory.game.actions.nigthKill.emoji} **${eventOfCategory.game.actions.nigthKill.name}**\nПользователь: ${getNumber(pickMemberKillOfGame.number)} ${fetchPickMember}`,
                                                                                thumbnail: { url: await getAvatar(fetchPickMember) }
                                                                            }
                                                                        ],
                                                                        components: [
                                                                            {
                                                                                type: 1,
                                                                                components: [
                                                                                    {
                                                                                        type: 2, 
                                                                                        style: 4, 
                                                                                        customId: 'unKick', 
                                                                                        label: 'Вернуть в игру'
                                                                                    }
                                                                                ]
                                                                            }
                                                                        ]
                                                                    }).catch(() => {});

                                                                    const collectorConponentsOfMessageOfKick = await messageOfKick.createMessageComponentCollector();
                                                                    collectorConponentsOfMessageOfKick.on('collect', async newI => {
                                                            
                                                                        if (newI.member.id !== guilds[EventId].Owner) return;
                                            
                                                                        switch (newI.customId) { 
                                
                                                                            case 'unKick': {
            
                                                                                game.members.find(member => member.id == fetchPickMember.id).alive = true;
            
                                                                                let nick = pickMemberKillOfGame.number;
                                                                                let nickPS = '';
            
                                                                                let punishments = 0;
                                                                                for (const pickPunishment in pickMemberKillOfGame.punishment) punishments++;
                                                                                for (const pickPunishment in pickMemberKillOfGame.punishment) {
            
                                                                                    if (pickMemberKillOfGame.punishment[pickPunishment] < 0) pickMemberKillOfGame.punishment[pickPunishment] = 0;
                                                                                    while (pickMemberKillOfGame.punishment[pickPunishment] >= eventOfCategory.game.punishment.find(punishment => punishment.name == pickPunishment).max) pickMemberKillOfGame.punishment[pickPunishment]--;
            
                                                                                    if (pickMemberKillOfGame.punishment[pickPunishment] !== 0) {
            
                                                                                        if (nickPS !== '') nickPS += '; ';
                                                                                        nickPS += punishments > 1 ? eventOfCategory.game.punishment.find(punishment => punishment.name == pickPunishment).ps.mini : eventOfCategory.game.punishment.find(punishment => punishment.name == pickPunishment).ps.full;
                                                                                        nickPS += `: ${pickMemberKillOfGame.punishment[pickPunishment]}/${eventOfCategory.game.punishment.find(punishment => punishment.name == pickPunishment).max}`;
                            
                                                                                    };
            
                                                                                };
            
                                                                                if (nickPS !== '') nick += ` [${nickPS}]`;
                                                                                if (fetchPickMember) fetchPickMember.setNickname(nick).catch(() => {});
            
                                                                                newI.update({  
                                                                                    content: ` `,
                                                                                    embeds: [
                                                                                        {
                                                                                            title: `Убийтсво: ${eventOfCategory.name}`,
                                                                                            color: appearance.embed.color,
                                                                                            description: `Тип: ${eventOfCategory.game.actions.nigthKill.emoji} **${eventOfCategory.game.actions.nigthKill.name}**\nПользователь: ${getNumber(pickMemberKillOfGame.number)} ${fetchPickMember}\n-# Убийство отменено`,
                                                                                            thumbnail: { url: await getAvatar(fetchPickMember) }
                                                                                        }
                                                                                    ],
                                                                                    components: [
                                                                                        
                                                                                    ]
                                                                                }).catch(() => {});
            
                                                                                if (game.time == 'day') {
            
                                                                                    eventVoiceChannel.permissionOverwrites.edit(fetchPickMember.id, { Speak: true }).catch(() => {});
                                                                                    eventRecordChannel.permissionOverwrites.edit(fetchPickMember.id, { SendMessages: true }).catch(() => {});
                                                                                    fetchPickMember.voice.setChannel(eventVoiceChannel.id).catch(() => {});
            
                                                                                };
                                                                                
                                                                                if (game.message.punishment) game.message.punishment.edit(punishmentMessage ()).catch(() => {});
                                                                                if (game.message.vote) game.message.vote.edit(voteMessage ()).catch(() => {});
                                            
                                                                            }

                                                                        };

                                                                    });
                                                                    
                                                                    eventVoiceChannel.permissionOverwrites.edit(fetchPickMember.id, { Speak: false }).catch(() => {});
                                                                    eventRecordChannel.permissionOverwrites.edit(fetchPickMember.id, { SendMessages: false }).catch(() => {});
                                                                    fetchPickMember.voice.setChannel(eventVoiceChannel.id).catch(() => {});
                                                                    
                                                                    if (game.message.punishment) game.message.punishment.edit(punishmentMessage ()).catch(() => {});
                                                                    if (game.message.vote) game.message.vote.edit(voteMessage ()).catch(() => {});
            
                                                                    return;
            
                                                                }
                                                            
                                                            };
                                
                                                        });

                                                    };

                                                    return {
                                                        embeds: [
                                                            {
                                                                title: `День: ${eventOfCategory.name}`,
                                                                color: appearance.embed.color,
                                                                description: `${resultKickMembers !== '' ? `Погибает: ${resultKickMembers}` : 'Никто не умирает'}`,
                                                                image: { url: eventOfCategory.game.image.day }
                                                            }
                                                        ],
                                                        components: componentsResultKickMembers[0].components[0] ? componentsResultKickMembers : []
                                                    };

                                                };

                                                if (eventOfCategory.game.lx.day.includes(game.actions.day) && kill[0]) {

                                                    game.time = 'lx';
                                                    for (const pickServer in game.servers) {
        
                                                        for (const pickChannel in game.servers[pickServer].channels) {
        
                                                            let pickChannelOfList = game.servers[pickServer].channels[pickChannel].config;
                                                            
                                                            for (const pickPermission in pickChannelOfList.permission) {
            
                                                                if (pickPermission == game.time) {
            
                                                                    for (const pickPermissionOfTime in pickChannelOfList.permission[pickPermission]) {
            
                                                                        if (pickChannelOfList.permission[pickPermission][pickPermissionOfTime].Role == 'everyone') game.servers[pickServer].channels[pickChannel].channel.permissionOverwrites.edit(game.servers[pickServer].guild.id, pickChannelOfList.permission[pickPermission][pickPermissionOfTime].Permission).catch(() => {});
                                                                        else {
            
                                                                            const pickRoleFetch = game.servers[pickServer].roles.find(role => role.name == pickChannelOfList.permission[pickPermission][pickPermissionOfTime].Role).role;
                                                                            game.servers[pickServer].channels[pickChannel].channel.permissionOverwrites.edit(pickRoleFetch.id, pickChannelOfList.permission[pickPermission][pickPermissionOfTime].Permission).catch(() => {});
                                                                            
                                                                        };
            
                                                                    };
            
                                                                };
            
                                                            };
        
                                                        };
        
                                                    };

                                                                                
                                                    let componentsResultKickMembers = [];
                                                    componentsResultKickMembers.push(
                                                        {
                                                            type: 1,
                                                            components: []
                                                        }
                                                    );


                                                    const resultMsg = await eventRecordChannel.send({
                                                        content: `<@${guilds[EventId].Owner}>`,
                                                        embeds: [
                                                            {
                                                                title: `Лучший ход: ${eventOfCategory.name}`,
                                                                color: appearance.embed.color,
                                                                description: `Загружается...`,
                                                                image: { url: eventOfCategory.game.image.lx }
                                                            }
                                                        ]
                                                    }).catch(() => {});

                                                    let componentsLx = [];
                                                    componentsLx.push(
                                                        {
                                                            type: 1,
                                                            components: []
                                                        }
                                                    );

                                                        
                                                    const fetchPickMember = await guild.members.fetch(kill[0].id).catch(() => {});

                                                    if (!componentsLx[0] || componentsLx[componentsLx.length-1].components.length == 5) 
                                                    componentsLx.push(
                                                        {
                                                            type: 1,
                                                            components: []
                                                        }
                                                    );

                                                    options = [];
                                                    for (const pickMember in game.members) {
        
                                                        options.push(
                                                            {
                                                                label: `${game.members[pickMember].number}`, 
                                                                value: `${game.members[pickMember].number}`
                                                            }
                                                        );

                                                    };

                                                    componentsLx[componentsLx.length-1].components.push(
                                                        {
                                                            type: 3,
                                                            customId: `lx${kill[0].number}`, 
                                                            placeholder: `Выберите список игроков от ${kill[0].number}`, 
                                                            minValues: 1, 
                                                            maxValues: options.length <= 3 ? options.length : 3, 
                                                            options: options
                                                        }
                                                    );

                                                    eventVoiceChannel.permissionOverwrites.edit(fetchPickMember.id, { Speak: true }).catch(() => {});
                                                    fetchPickMember.voice.setChannel(eventVoiceChannel.id).catch(() => {});
            
                                                    
                                                    const collectorConponentsOfResultMsg = await resultMsg.createMessageComponentCollector();
                                                    collectorConponentsOfResultMsg.on('collect', async newI => {
                                                        
                                                        if (newI.member.id !== guilds[EventId].Owner) return;
                            
                                                        switch (newI.customId) { 

                                                            case `cancel`: {  
                                                                
                                                                newI.update({
                                                                    content: ' ',
                                                                    embeds: [
                                                                        {
                                                                            title: `Лучший ход: ${eventOfCategory.name}`,
                                                                            color: appearance.embed.color,
                                                                            description: `Лх от **${kill[0].number}** пропущено`,
                                                                            image: { url: eventOfCategory.game.image.lx }
                                                                        }
                                                                    ],
                                                                    components: [
                                                                        
                                                                    ]
                                                                }).catch(() => {});
                                                                
                                                                
                                                                game.time = 'day';
                                                                for (const pickServer in game.servers) {

                                                                    for (const pickChannel in game.servers[pickServer].channels) {

                                                                        let pickChannelOfList = game.servers[pickServer].channels[pickChannel].config;
                                                                        
                                                                        for (const pickPermission in pickChannelOfList.permission) {
                        
                                                                            if (pickPermission == game.time) {
                        
                                                                                for (const pickPermissionOfTime in pickChannelOfList.permission[pickPermission]) {
                        
                                                                                    if (pickChannelOfList.permission[pickPermission][pickPermissionOfTime].Role == 'everyone') game.servers[pickServer].channels[pickChannel].channel.permissionOverwrites.edit(game.servers[pickServer].guild.id, pickChannelOfList.permission[pickPermission][pickPermissionOfTime].Permission).catch(() => {});
                                                                                    else {
                        
                                                                                        const pickRoleFetch = game.servers[pickServer].roles.find(role => role.name == pickChannelOfList.permission[pickPermission][pickPermissionOfTime].Role).role;
                                                                                        game.servers[pickServer].channels[pickChannel].channel.permissionOverwrites.edit(pickRoleFetch.id, pickChannelOfList.permission[pickPermission][pickPermissionOfTime].Permission).catch(() => {});
                                                                                        
                                                                                    };
                        
                                                                                };
                        
                                                                            };
                        
                                                                        };

                                                                    };

                                                                };

                                                                for (const pickMember in game.members) {
                    
                                                                    if (game.members[pickMember].alive) {
                    
                                                                        const fetchPickMember = await guild.members.fetch(game.members[pickMember].id).catch(() => {});
                    
                                                                        if (fetchPickMember) {
                    
                                                                            eventVoiceChannel.permissionOverwrites.edit(fetchPickMember.id, { Speak: true })
                                                                                .then(() => {
                                                                                    fetchPickMember.voice.setChannel(eventVoiceChannel.id).catch(() => {});
                                                                                })
                                                                                .catch(() => {});
                                                                            eventRecordChannel.permissionOverwrites.edit(fetchPickMember.id, { SendMessages: true }).catch(() => {});
                    
                                                                        };
                    
                                                                    };
                    
                                                                };

                                                                const dayMsg = await eventRecordChannel.send({
                                                                    embeds: [
                                                                        {
                                                                            title: `День: ${eventOfCategory.name}`,
                                                                            color: appearance.embed.color,
                                                                            description: `Загружается...`,
                                                                            image: { url: eventOfCategory.game.image.day }
                                                                        }
                                                                    ]
                                                                }).catch(() => {});
                                                                    
                                                                dayMsg.edit(await dayKills(kill, dayMsg)).catch(() => {});

                                                                break;

                                                            }

                                                            case `lx${kill[0].number}`: {  
                                                                
                                                                let lxText = '';
                                                                for (const pickValue in newI.values) {
                                                                    
                                                                    if (lxText == '') lxText += `**${newI.values[pickValue]}**`;
                                                                    else lxText += `, **${newI.values[pickValue]}**`;

                                                                };
                    
        
                                                                game.history.lx.push({member: kill[0], lx: newI.values});
                                                                resultMsg.components.forEach(component => {

                                                                    let Comp = component.components;
                                                    
                                                                    for (c = 0; c < Comp.length; c++) {
                                                    
                                                                        Comp[c].data.disabled = true;
                                                    
                                                                    };
                                                                    
                                                                });

                                                                newI.update({
                                                                    content: ' ',
                                                                    embeds: [
                                                                        {
                                                                            title: `Лучший ход: ${eventOfCategory.name}`,
                                                                            color: appearance.embed.color,
                                                                            description: `Лх от **${kill[0].number}** — ${lxText}`,
                                                                            image: { url: eventOfCategory.game.image.lx }
                                                                        }
                                                                    ],
                                                                    components: [

                                                                    ]
                                                                }).catch(() => {});
                                                                
                                                                
                                                                game.time = 'day';

                                                                for (const pickServer in game.servers) {
                    
                                                                    for (const pickChannel in game.servers[pickServer].channels) {
                                                                    
                                                                        game.servers[pickServer].channels[pickChannel].channel.send({
                                                                            embeds: [
                                                                                {
                                                                                    title: `Уведомление: ${eventOfCategory.name}`,
                                                                                    color: appearance.embed.color,
                                                                                    description: `В городе наступил день`
                                                                                    
                                                                                }
                                                                            ]
                                                                        }).catch(() => {});
                    
                                                                    };
                    
                                                                };

                                                                for (const pickServer in game.servers) {

                                                                    for (const pickChannel in game.servers[pickServer].channels) {

                                                                        let pickChannelOfList = game.servers[pickServer].channels[pickChannel].config;
                                                                        
                                                                        for (const pickPermission in pickChannelOfList.permission) {
                        
                                                                            if (pickPermission == game.time) {
                        
                                                                                for (const pickPermissionOfTime in pickChannelOfList.permission[pickPermission]) {
                        
                                                                                    if (pickChannelOfList.permission[pickPermission][pickPermissionOfTime].Role == 'everyone') game.servers[pickServer].channels[pickChannel].channel.permissionOverwrites.edit(game.servers[pickServer].guild.id, pickChannelOfList.permission[pickPermission][pickPermissionOfTime].Permission).catch(() => {});
                                                                                    else {
                        
                                                                                        const pickRoleFetch = game.servers[pickServer].roles.find(role => role.name == pickChannelOfList.permission[pickPermission][pickPermissionOfTime].Role).role;
                                                                                        game.servers[pickServer].channels[pickChannel].channel.permissionOverwrites.edit(pickRoleFetch.id, pickChannelOfList.permission[pickPermission][pickPermissionOfTime].Permission).catch(() => {});
                                                                                        
                                                                                    };
                        
                                                                                };
                        
                                                                            };
                        
                                                                        };

                                                                    };

                                                                };

                                                                for (const pickMember in game.members) {
                    
                                                                    if (game.members[pickMember].alive) {
                    
                                                                        const fetchPickMember = await guild.members.fetch(game.members[pickMember].id).catch(() => {});
                    
                                                                        if (fetchPickMember) {
                    
                                                                            eventVoiceChannel.permissionOverwrites.edit(fetchPickMember.id, { Speak: true }).catch(() => {});
                                                                            eventRecordChannel.permissionOverwrites.edit(fetchPickMember.id, { SendMessages: true }).catch(() => {});
                                                                            fetchPickMember.voice.setChannel(eventVoiceChannel.id).catch(() => {});
                    
                                                                        };
                    
                                                                    };
                    
                                                                };

                                                                const dayMsg = await eventRecordChannel.send({
                                                                    embeds: [
                                                                        {
                                                                            title: `День: ${eventOfCategory.name}`,
                                                                            color: appearance.embed.color,
                                                                            description: `Загружается...`,
                                                                            image: { url: eventOfCategory.game.image.day }
                                                                        }
                                                                    ]
                                                                }).catch(() => {});
                                                                    
                                                                dayMsg.edit(await dayKills(kill, dayMsg)).catch(() => {});

                                                                break;

                                                            }
                                                        
                                                        };
                            
                                                    });

                                                    componentsLx.push(
                                                        {
                                                            type: 1,
                                                            components: [
                                                                {
                                                                    type: 2, 
                                                                    style: 4, 
                                                                    customId: `cancel`,
                                                                    label: `Пропустить`
                                                                }
                                                            ]
                                                        }
                                                    );

                                                    setTimeout(() => {

                                                        resultMsg.edit({
                                                            embeds: [
                                                                {
                                                                    title: `Лучший ход: ${eventOfCategory.name}`,
                                                                    color: appearance.embed.color,
                                                                    description: `Лх от **${kill[0].number}**`,
                                                                    image: { url: eventOfCategory.game.image.lx }
                                                                }
                                                            ],
                                                            components: componentsLx
                                                        }).catch(() => {});
                                                        
                                                    }, 1000);

                                                }
                                                
                                                else if (kill[0]) {
                                                                
                                                    game.time = 'day';
                                                    
                                                    for (const pickServer in game.servers) {
        
                                                        for (const pickChannel in game.servers[pickServer].channels) {
                                                        
                                                            game.servers[pickServer].channels[pickChannel].channel.send({
                                                                embeds: [
                                                                    {
                                                                        title: `Уведомление: ${eventOfCategory.name}`,
                                                                        color: appearance.embed.color,
                                                                        description: `В городе наступил день`
                                                                        
                                                                    }
                                                                ]
                                                            }).catch(() => {});
        
                                                        };
        
                                                    };

                                                    for (const pickServer in game.servers) {

                                                        for (const pickChannel in game.servers[pickServer].channels) {

                                                            let pickChannelOfList = game.servers[pickServer].channels[pickChannel].config;
                                                            
                                                            for (const pickPermission in pickChannelOfList.permission) {
            
                                                                if (pickPermission == game.time) {
            
                                                                    for (const pickPermissionOfTime in pickChannelOfList.permission[pickPermission]) {
            
                                                                        if (pickChannelOfList.permission[pickPermission][pickPermissionOfTime].Role == 'everyone') game.servers[pickServer].channels[pickChannel].channel.permissionOverwrites.edit(game.servers[pickServer].guild.id, pickChannelOfList.permission[pickPermission][pickPermissionOfTime].Permission).catch(() => {});
                                                                        else {
            
                                                                            const pickRoleFetch = game.servers[pickServer].roles.find(role => role.name == pickChannelOfList.permission[pickPermission][pickPermissionOfTime].Role).role;
                                                                            game.servers[pickServer].channels[pickChannel].channel.permissionOverwrites.edit(pickRoleFetch.id, pickChannelOfList.permission[pickPermission][pickPermissionOfTime].Permission).catch(() => {});
                                                                            
                                                                        };
            
                                                                    };
            
                                                                };
            
                                                            };

                                                        };

                                                    };

                                                    for (const pickMember in game.members) {
        
                                                        if (game.members[pickMember].alive) {
        
                                                            const fetchPickMember = await guild.members.fetch(game.members[pickMember].id).catch(() => {});
        
                                                            if (fetchPickMember) {
        
                                                                eventVoiceChannel.permissionOverwrites.edit(fetchPickMember.id, { Speak: true }).catch(() => {});
                                                                eventRecordChannel.permissionOverwrites.edit(fetchPickMember.id, { SendMessages: true }).catch(() => {});
                                                                fetchPickMember.voice.setChannel(eventVoiceChannel.id).catch(() => {});
        
                                                            };
        
                                                        };
        
                                                    };

                                                    const dayMsg = await eventRecordChannel.send({
                                                        embeds: [
                                                            {
                                                                title: `День: ${eventOfCategory.name}`,
                                                                color: appearance.embed.color,
                                                                description: `Загружается...`,
                                                                image: { url: eventOfCategory.game.image.day }
                                                            }
                                                        ]
                                                    }).catch(() => {});
                                                        
                                                    dayMsg.edit(await dayKills(kill, dayMsg)).catch(() => {});

                                                }
                                                
                                                else {   
                                                                
                                                    game.time = 'day';

                                                    for (const pickServer in game.servers) {
        
                                                        for (const pickChannel in game.servers[pickServer].channels) {
                                                        
                                                            game.servers[pickServer].channels[pickChannel].channel.send({
                                                                embeds: [
                                                                    {
                                                                        title: `Уведомление: ${eventOfCategory.name}`,
                                                                        color: appearance.embed.color,
                                                                        description: `В городе наступил день`
                                                                        
                                                                    }
                                                                ]
                                                            }).catch(() => {});
        
                                                        };
        
                                                    };

                                                    for (const pickServer in game.servers) {

                                                        for (const pickChannel in game.servers[pickServer].channels) {

                                                            let pickChannelOfList = game.servers[pickServer].channels[pickChannel].config;
                                                            
                                                            for (const pickPermission in pickChannelOfList.permission) {
            
                                                                if (pickPermission == game.time) {
            
                                                                    for (const pickPermissionOfTime in pickChannelOfList.permission[pickPermission]) {
            
                                                                        if (pickChannelOfList.permission[pickPermission][pickPermissionOfTime].Role == 'everyone') game.servers[pickServer].channels[pickChannel].channel.permissionOverwrites.edit(game.servers[pickServer].guild.id, pickChannelOfList.permission[pickPermission][pickPermissionOfTime].Permission).catch(() => {});
                                                                        else {
            
                                                                            const pickRoleFetch = game.servers[pickServer].roles.find(role => role.name == pickChannelOfList.permission[pickPermission][pickPermissionOfTime].Role).role;
                                                                            game.servers[pickServer].channels[pickChannel].channel.permissionOverwrites.edit(pickRoleFetch.id, pickChannelOfList.permission[pickPermission][pickPermissionOfTime].Permission).catch(() => {});
                                                                            
                                                                        };
            
                                                                    };
            
                                                                };
            
                                                            };

                                                        };

                                                    };

                                                    for (const pickMember in game.members) {
        
                                                        if (game.members[pickMember].alive) {
        
                                                            const fetchPickMember = await guild.members.fetch(game.members[pickMember].id).catch(() => {});
        
                                                            if (fetchPickMember) {
        
                                                                eventVoiceChannel.permissionOverwrites.edit(fetchPickMember.id, { Speak: true }).catch(() => {});
                                                                eventRecordChannel.permissionOverwrites.edit(fetchPickMember.id, { SendMessages: true }).catch(() => {});
                                                                fetchPickMember.voice.setChannel(eventVoiceChannel.id).catch(() => {});
        
                                                            };
        
                                                        };
        
                                                    };

                                                    const dayMsg = await eventRecordChannel.send({
                                                        embeds: [
                                                            {
                                                                title: `День: ${eventOfCategory.name}`,
                                                                color: appearance.embed.color,
                                                                description: `Загружается...`,
                                                                image: { url: eventOfCategory.game.image.day }
                                                            }
                                                        ]
                                                    }).catch(() => {});
                                                        
                                                    dayMsg.edit(await dayKills(kill, dayMsg)).catch(() => {});

                                                };

                                                if (game.message.nigth) {
                                                    
                                                    let embeds = [];

                                                    embeds.push(
                                                        {
                                                            title: `Ночь: ${eventOfCategory.name}`,
                                                            color: appearance.embed.color,
                                                            description: `Результаты ночи #**${game.actions.day}**\nПогибает: **${textKill || 'Никто'}**`,
                                                        }
                                                    );

                                                    for (const pickMenu in menu) {
                                                            
                                                        if (menu[pickMenu].config.access.coincidence) {

                                                            for (const pickChoose of menu[pickMenu].members) {
        
                                                                if (pickChoose.choose == false) ready = false;
            
                                                                let emojiMenuStatus = pickChoose.choose ? menu[pickMenu].config.emoji.True : menu[pickMenu].config.emoji.False;
                                                                const emojiId = emojiMenuStatus.match(/<:[a-zA-Z0-9_]+:(\d+)>/)[1];
                                                                                                                                
                                                                embeds.push(
                                                                    {
                                                                        color: appearance.embed.color,
                                                                        description: `## **${menu[pickMenu].config.name}**\nИгрок **${pickChoose.number}** выбрал ${pickChoose.choose ? `**${pickChoose.choose.number}**` : `Нет`}`,
                                                                        thumbnail: { url: `https://cdn.discordapp.com/emojis/${emojiId}.png?size=64` }
                                                                    }
                                                                );

                                                            };

                                                        }
                                                        
                                                        else {

                                                            if (menu[pickMenu].choose == false) ready = false;
            
                                                            let emojiMenuStatus = menu[pickMenu].choose ? menu[pickMenu].config.emoji.True : menu[pickMenu].config.emoji.False;
                                                            const emojiId = emojiMenuStatus.match(/<:[a-zA-Z0-9_]+:(\d+)>/)[1];

                                                            embeds.push(
                                                                {
                                                                    color: appearance.embed.color,
                                                                    description: menu[pickMenu].choose ? `## **${menu[pickMenu].config.name}**\nВыбрано: **${menu[pickMenu].choose.number}**` : `## ${menu[pickMenu].config.name}\nВыбрано: Нет`,
                                                                    thumbnail: { url: `https://cdn.discordapp.com/emojis/${emojiId}.png?size=64` }
                                                                }
                                                            );

                                                        };

                                                    };
                                                    

                                                    if (game.message.nigth) game.message.nigth.edit({
                                                        embeds: embeds
                                                    }).catch(() => {});

                                                };

                                            }

                                            else {

                                                let embeds = [];

                                                embeds.push(
                                                    {
                                                        title: `Ночь: ${eventOfCategory.name}`,
                                                        color: appearance.embed.color,
                                                        description: `Ночь #**${game.actions.day}**\nЗакончиться <t:${Math.floor(endNigth)}:R>`
                                                    }
                                                );

                                                for (const pickMenu in menu) {
                                                        
                                                    if (menu[pickMenu].config.access.coincidence) {

                                                        for (const pickChoose of menu[pickMenu].members) {
        
                                                            if (pickChoose.choose == false) ready = false;
        
                                                            let emojiMenuStatus = pickChoose.choose ? menu[pickMenu].config.emoji.True : menu[pickMenu].config.emoji.False;
                                                            const emojiId = emojiMenuStatus.match(/<:[a-zA-Z0-9_]+:(\d+)>/)[1];
                                                                                                                            
                                                            embeds.push(
                                                                {
                                                                    color: appearance.embed.color,
                                                                    description: `## **${menu[pickMenu].config.name}**\nИгрок **${pickChoose.number}** выбрал ${pickChoose.choose ? `**${pickChoose.choose.number}**` : `Нет`}`,
                                                                    thumbnail: { url: `https://cdn.discordapp.com/emojis/${emojiId}.png?size=64` }
                                                                }
                                                            );

                                                        };

                                                    }
                                                    
                                                    else {

                                                        if (menu[pickMenu].choose == false) ready = false;
            
                                                        let emojiMenuStatus = menu[pickMenu].choose ? menu[pickMenu].config.emoji.True : menu[pickMenu].config.emoji.False;
                                                        const emojiId = emojiMenuStatus.match(/<:[a-zA-Z0-9_]+:(\d+)>/)[1];

                                                        embeds.push(
                                                            {
                                                                color: appearance.embed.color,
                                                                description: menu[pickMenu].choose ? `## **${menu[pickMenu].config.name}**\nВыбрано: **${menu[pickMenu].choose.number}**` : `## ${menu[pickMenu].config.name}\nВыбрано: Нет`,
                                                                thumbnail: { url: `https://cdn.discordapp.com/emojis/${emojiId}.png?size=64` }
                                                            }
                                                        );

                                                    };
    
                                                };
                                                

                                                if (game.message.nigth) game.message.nigth.edit({
                                                    embeds: embeds
                                                }).catch(() => {});

                                            };
                                            
                                        }, 2000);

                                    });

                                    actions['nigth'] = {
                                        actions: [nigth],
                                        all: false
                                    };
                                    

                                    let options = [];
                                    for (const pickTeams in eventOfCategory.game.teams) {

                                        options.push(
                                            {
                                                label: `${pickTeams}`, 
                                                value: `${pickTeams}`, 
                                                emoji: eventOfCategory.game.teams[pickTeams].emoji
                                            }
                                        );

                                    };

                                    manageMessage.edit({
                                        embeds: [
                                            {
                                                title: `Управление: ${eventOfCategory.name}`,
                                                color: appearance.embed.color,
                                                fields: additionInformationOrCommand ?
                                                [
                                                    {
                                                        name: 'Кнопки:',
                                                        value: `${appearance.emoji.Nigth} — Запустить **ночь**\n${appearance.emoji.Pause} — Поставить/снять **паузу**\n${appearance.emoji.Timer} — Открыть **меню** таймера\n${appearance.emoji.Delete} — Досрочно **завершить** игру`,
                                                        inline: false
                                                    },
                                                    {
                                                        name: 'Команды:',
                                                        value: `${additionInformationOrCommand}`,
                                                        inline: false
                                                    }
                                                ]
                                                :
                                                [
                                                    {
                                                        name: 'Кнопки:',
                                                        value: `${appearance.emoji.Nigth} — Запустить **ночь**\n${appearance.emoji.Pause} — Поставить/снять **паузу**\n${appearance.emoji.Timer} — Открыть **меню** таймера\n${appearance.emoji.Delete} — Досрочно **завершить** игру`,
                                                        inline: false
                                                    }
                                                ]
                                            }
                                        ],
                                        components: [
                                            {
                                                type: 1,
                                                components: [
                                                    {
                                                        type: 3,
                                                        customId: 'endGame', 
                                                        placeholder: 'Выберите победившую команду', 
                                                        minValues: 1, 
                                                        maxValues: 1, 
                                                        options: options,
                                                        disabled: true
                                                    }
                                                ]
                                            },
                                            {
                                                type: 1,
                                                components: [
                                                    {
                                                        type: 2, 
                                                        style: appearance.buttons_menu.Default.style, 
                                                        customId: 'nigth', 
                                                        emoji: appearance.emoji.Nigth
                                                    },
                                                    {
                                                        type: 2, 
                                                        style: appearance.buttons_menu.Default.style, 
                                                        customId: 'pause', 
                                                        emoji: appearance.emoji.Pause
                                                    },
                                                    {
                                                        type: 2, 
                                                        style: appearance.buttons_menu.Default.style, 
                                                        customId: 'timer', 
                                                        emoji: appearance.emoji.Timer
                                                    },
                                                    {
                                                        type: 2, 
                                                        style: appearance.buttons_menu.Default.style, 
                                                        customId: 'anticipatorily', 
                                                        emoji: appearance.emoji.Delete
                                                    }
                                                ]
                                            }
                                        ]
                                    }).catch(() => {});


                                    if (eventOfCategory.game.punishment[0]) {

                                        game.punishment.list = eventOfCategory.game.punishment;
                                        game.punishment.pick = eventOfCategory.game.punishment[0];

                                    };


                                    let punishmentOldInVote = {};
                                    function voteMessage () {
                                    
                                        for (const pickMember in game.vote.members) {
                                    
                                            if (game.vote.members[pickMember]) {
                                    
                                                const memeberOfVote = game.members.find(member => member.id == game.vote.members[pickMember].id);
                                                if (memeberOfVote.alive == false) game.vote.members = game.vote.members.filter((n) => {return n != game.vote.members[pickMember]});
                                    
                                            };
                                    
                                        };
                                    
                                        let exhibitedText = '';
                                        let componentsVote = [];
                                        
                                        componentsVote.push(
                                            {
                                                type: 1,
                                                components: []
                                            }
                                        );
                                    
                                        componentsVote[componentsVote.length-1].components.push(
                                            {
                                                type: 2, 
                                                style: 1, 
                                                customId: `vote`,
                                                label: `Начать голосование`, 
                                                disabled: !game.vote.members[0] ? true : false 
                                            }
                                        );
                                    
                                        const vote = (async (newI) => {
                                    
                                            if (guilds[EventId].Owner !== newI.member.id) return newI.reply(await errorNoEventsOwnerMessage (newI.member));
                                            if (game.time == 'vote') 
                                            return newI.reply({
                                                ephemeral: true,
                                                embeds: [
                                                    {
                                                        title: `${client.user.username} error`,
                                                        color: appearance.embed.errorColor,
                                                        description: `${newI.member}, голосование **уже** запущено`,
                                                        thumbnail: { url: iMemberAvatar }
                                                    }
                                                ]
                                            }).catch(() => {});
                                    
                                            if (game.time !== 'day') 
                                            return newI.reply({
                                                ephemeral: true,
                                                embeds: [
                                                    {
                                                        title: `${client.user.username} error`,
                                                        color: appearance.embed.errorColor,
                                                        description: `${newI.member}, голосование можно проводить **только** днём`,
                                                        thumbnail: { url: iMemberAvatar }
                                                    }
                                                ]
                                            }).catch(() => {});
                                    
                                            if (!game.vote.members[0]) 
                                            return newI.reply({
                                                ephemeral: true,
                                                embeds: [
                                                    {
                                                        title: `${client.user.username} error`,
                                                        color: appearance.embed.errorColor,
                                                        description: `${newI.member}, на голосование **никто** не выставлен`,
                                                        thumbnail: { url: iMemberAvatar }
                                                    }
                                                ]
                                            }).catch(() => {});
                                            
                                    
                                            game.time = 'vote';
                                            let vote = {
                                                members: {},
                                                membersLength: 0,
                                                voteMembers: []
                                            };
                                    
                                            let exhibitedTextVote = '';
                                            for (const pickMember in game.vote.members) {
                                    
                                                if (exhibitedTextVote == '') exhibitedTextVote += `**${game.vote.members[pickMember].number}**`;
                                                else exhibitedTextVote += `, **${game.vote.members[pickMember].number}**`;
                                    
                                            };
                                    
                                            for (const pickMember in game.members) {
                                    
                                                if (game.vote.members.find(member => member.id == game.members[pickMember].id)) {
                                    
                                                    const memeberOfVote = game.vote.members.find(member => member.id == game.members[pickMember].id);
                                                    if (!memeberOfVote.alive) return game.vote.members = game.vote.members.filter((n) => {return n != memeberOfVote});
                                    
                                                };
                                    
                                            };
                                    
                                            let quantityOfStart = 0;
                                            for (const pickMember in game.members) if (game.vote.members.find(member => member.id == game.members[pickMember].id) && game.members[pickMember].alive) quantityOfStart++;

                                            if (quantityOfStart == 0) 
                                            return newI.reply({
                                                ephemeral: true,
                                                embeds: [
                                                    {
                                                        title: `${client.user.username} error`,
                                                        color: appearance.embed.errorColor,
                                                        description: `${newI.member}, на голосование **никто** не выставлен`,
                                                        thumbnail: { url: iMemberAvatar }
                                                    }
                                                ]
                                            }).catch(() => {});

                                            if (quantityOfStart == 1 && game.members.length !== 1) {
                        
                                                newI.update().catch(() => {});

                                                game.time = 'day';
                                                const memberOfGame = game.members.find(member => member.id == game.vote.members[0].id);
                                                const fetchPickMember = await guild.members.fetch(memberOfGame.id).catch(() => {});
                        
                                                game.message.votePreparation = await eventRecordChannel.send({
                                                    embeds: [
                                                        {
                                                            title: `Голосование: ${eventOfCategory.name}`,
                                                            color: appearance.embed.color,
                                                            description: `Погибает: **${memberOfGame.number}**`,
                                                            image: { url: eventOfCategory.game.image.vote }
                                                        }
                                                    ],
                                                    components: [
                                                        {
                                                            type: 1,
                                                            components: [
                                                                {
                                                                    type: 2, 
                                                                    style: 4, 
                                                                    customId: `kick`,
                                                                    label: `${memberOfGame.number}⠀Убрать убитого игрока`
                                                                }
                                                            ]
                                                        }
                                                    ]
                                                }).catch(() => {});
                        
                                                const collectorConponentsOfVotePr = await game.message.votePreparation.createMessageComponentCollector();
                                                collectorConponentsOfVotePr.on('collect', async newI => {
                                                    
                                                    if (newI.member.id !== guilds[EventId].Owner) return;
                        
                                                    switch (newI.customId) { 
                        
                                                        case 'kick': {
                        
                                                            game.members.find(member => member.id == fetchPickMember.id).alive = false;
                                                            if (fetchPickMember) fetchPickMember.setNickname(memberOfGame.nickName).catch(() => {});
                                                            for (n=0; n < game.servers.length; n++) {
                        
                                                                game.servers[n].guild.members.fetch().catch(() => {});
                                                                const fetchPickMemberOfPickServer = await game.servers[n].guild.members.fetch(fetchPickMember.id).catch(() => {});
                        
                                                                if (fetchPickMemberOfPickServer) fetchPickMemberOfPickServer.kick().catch(() => {});
                        
                                                            };
                        
                                                            newI.update({
                                                                components: [
                                                                    {
                                                                        type: 1,
                                                                        components: [
                                                                            {
                                                                                type: 2, 
                                                                                style: 4, 
                                                                                customId: `kick`,
                                                                                label: `${memberOfGame.number}⠀Убрать убитого игрока`,
                                                                                disabled: true
                                                                            }
                                                                        ]
                                                                    }
                                                                ]
                                                            }).catch(() => {});
                        
                                                            const messageOfKick = await game.message.votePreparation.reply({  
                                                                content: `||${fetchPickMember}||`,
                                                                embeds: [
                                                                    {
                                                                        title: `Убийство: ${eventOfCategory.name}`,
                                                                        color: eventOfCategory.game.actions.kill.color,
                                                                        description: `Тип: ${eventOfCategory.game.vote.emoji} **${eventOfCategory.game.vote.name}**\nПользователь: ${getNumber(memberOfGame.number)} ${fetchPickMember}`,
                                                                        thumbnail: { url: await getAvatar(fetchPickMember) }
                                                                    }
                                                                ],
                                                                components: [
                                                                    {
                                                                        type: 1,
                                                                        components: [
                                                                            {
                                                                                type: 2, 
                                                                                style: 4, 
                                                                                customId: 'unKick', 
                                                                                label: 'Вернуть в игру'
                                                                            }
                                                                        ]
                                                                    }
                                                                ]
                                                            }).catch(() => {});
                        
                                                            if (!game.history.vote.includes({ id: fetchPickMember.id, number: memberOfGame.number})) game.history.vote.push({ id: fetchPickMember.id, number: memberOfGame.number});
                        
                                                            const collectorConponentsOfMessageOfKick = await messageOfKick.createMessageComponentCollector();
                                                            collectorConponentsOfMessageOfKick.on('collect', async newI => {
                                                    
                                                                if (newI.member.id !== guilds[EventId].Owner) return;
                                    
                                                                switch (newI.customId) { 
                        
                                                                    case 'unKick': {
                        
                                                                        game.members.find(member => member.id == fetchPickMember.id).alive = true;
                        
                                                                        let nick = memberOfGame.number;
                                                                        let nickPS = '';
                        
                                                                        let punishments = 0;
                                                                        for (const pickPunishment in memberOfGame.punishment) punishments++;
                                                                        for (const pickPunishment in memberOfGame.punishment) {
                        
                                                                            if (memberOfGame.punishment[pickPunishment] < 0) memberOfGame.punishment[pickPunishment] = 0;
                                                                            while (memberOfGame.punishment[pickPunishment] >= eventOfCategory.game.punishment.find(punishment => punishment.name == pickPunishment).max) memberOfGame.punishment[pickPunishment]--;
                        
                                                                            if (memberOfGame.punishment[pickPunishment] !== 0) {
                        
                                                                                if (nickPS !== '') nickPS += '; ';
                                                                                nickPS += punishments > 1 ? eventOfCategory.game.punishment.find(punishment => punishment.name == pickPunishment).ps.mini : eventOfCategory.game.punishment.find(punishment => punishment.name == pickPunishment).ps.full;
                                                                                nickPS += `: ${memberOfGame.punishment[pickPunishment]}/${eventOfCategory.game.punishment.find(punishment => punishment.name == pickPunishment).max}`;
                        
                                                                            };
                        
                                                                        };
                        
                                                                        if (nickPS !== '') nick += ` [${nickPS}]`;
                                                                        if (fetchPickMember) fetchPickMember.setNickname(nick).catch(() => {});
                        
                                                                        newI.update({  
                                                                            content: ` `,
                                                                            embeds: [
                                                                                {
                                                                                    title: `Убийтсво: ${eventOfCategory.name}`,
                                                                                    color: appearance.embed.color,
                                                                                    description: `Тип: ${eventOfCategory.game.vote.emoji} **${eventOfCategory.game.vote.name}**\nПользователь: ${getNumber(memberOfGame.number)} ${fetchPickMember}\n-# Убийство отменено`,
                                                                                    thumbnail: { url: await getAvatar(fetchPickMember) }
                                                                                }
                                                                            ],
                                                                            components: [
                                                                                
                                                                            ]
                                                                        }).catch(() => {});
                        
                                                                        if (game.history.vote.includes({ id: fetchPickMember.id, number: memberOfGame.number})) game.history.vote = game.history.vote.filter((n) => {return n != { id: fetchPickMember.id, number: memberOfGame.number}});
                        
                                                                        if (game.time == 'day') {
                        
                                                                            eventVoiceChannel.permissionOverwrites.edit(fetchPickMember.id, { Speak: true }).catch(() => {});
                                                                            eventRecordChannel.permissionOverwrites.edit(fetchPickMember.id, { SendMessages: true }).catch(() => {});
                                                                            fetchPickMember.voice.setChannel(eventVoiceChannel.id).catch(() => {});
                        
                                                                        };
                                                                        
                                                                        if (game.message.punishment) game.message.punishment.edit(punishmentOldInVote ()).catch(() => {});
                                                                        if (game.message.vote) game.message.vote.edit(voteMessage ()).catch(() => {});
                                    
                                                                    }
                        
                                                                };
                        
                                                            });
                                                            
                                                            eventVoiceChannel.permissionOverwrites.edit(fetchPickMember.id, { Speak: false }).catch(() => {});
                                                            eventRecordChannel.permissionOverwrites.edit(fetchPickMember.id, { SendMessages: false }).catch(() => {});
                                                            fetchPickMember.voice.setChannel(eventVoiceChannel.id).catch(() => {});
                                                            
                                                            if (game.message.punishment) game.message.punishment.edit(punishmentOldInVote ()).catch(() => {});
                                                            if (game.message.vote) game.message.vote.edit(voteMessage ()).catch(() => {});
                        
                                                            return;
                        
                                                        }
                                                    
                                                    };
                        
                                                });

                                                game.vote.members = [];

                                                if (game.message.punishment) game.message.punishment.edit(punishmentOldInVote ()).catch(() => {});
                                                if (game.message.vote) game.message.vote.edit(voteMessage ()).catch(() => {});
                        
                                                return;
                        
                                            };


                                            const matchVote = eventOfCategory.game.lasts.vote.match(/^\d{1,99}(s|m|h|d|w)$/);
                                            const examinationTimeVote = (+matchVote[0].slice(0,-1))*(matchVote[1]=='s'?1:matchVote[1]=='m'?60:matchVote[1]=='h'?60*60:matchVote[1]=='d'?60*60*24:matchVote[1]=='w'?60*60*24*7:0);
                                    
                                            game.message.votePreparation = await eventRecordChannel.send({
                                                embeds: [
                                                    {
                                                        title: `Информация: ${eventOfCategory.name}`,
                                                        color: appearance.embed.color,
                                                        description: `Голосование **происходит** c помощью отправления + в ${eventRecordChannel}, в порядке выставления. По пингу бота: ${client.user}\n-# Длительность голосования за кандитатуру ${hourTranslator(Math.floor(examinationTimeVote))}`,
                                                        image: { url: appearance.custom.Mafia.default.nullImage },
                                                        footer: { text: 'Приготовте свои +(ки)' }
                                                    },
                                                    {
                                                        title: `Голосование: ${eventOfCategory.name}`,
                                                        color: appearance.embed.color,
                                                        description: `Выставлены: ${exhibitedText || 'Пусто'}`,
                                                        image: { url: eventOfCategory.game.image.vote }
                                                    }
                                                ],
                                                components: [
                                                    {
                                                        type: 1,
                                                        components: [
                                                            {
                                                                type: 2, 
                                                                style: 3, 
                                                                customId: `voteStart`,
                                                                label: `Запустить голосование`
                                                            },
                                                            {
                                                                type: 2, 
                                                                style: 4, 
                                                                customId: `voteCancel`,
                                                                label: `Отменить голосование`
                                                            }
                                                        ]
                                                    }
                                                ]
                                            }).catch(() => {});
                                    
                                            newI.update().catch(() => {});
                                    
                                            const collectorConponentsOfVotePreparation = await game.message.votePreparation.createMessageComponentCollector();
                                            collectorConponentsOfVotePreparation.on('collect', async newI => {
                                    
                                                if (newI.member.id !== guilds[EventId].Owner) return;
                                    
                                                switch (newI.customId) { 
                                    
                                                    case 'voteStart': {
                                    
                                                        if (game.message.vote) game.message.vote.edit(voteMessage ()).catch(() => {});
                                    
                                                        let quantity = 0;
                                                        let exhibitedTextVote = '';
                                                        for (const pickMember in game.members) {
                                    
                                                            if (game.vote.members.find(member => member.id == game.members[pickMember].id) && game.members[pickMember].alive) {
                                    
                                                                quantity++;
                                                                if (exhibitedTextVote == '') exhibitedTextVote += `**${game.members[pickMember].number}**`;
                                                                else exhibitedTextVote += `, **${game.members[pickMember].number}**`;
                                    
                                                            };
                                    
                                                        };
                                    
                                                        newI.update({
                                                            embeds: [
                                                                {
                                                                    title: `Информация: ${eventOfCategory.name}`,
                                                                    color: appearance.embed.color,
                                                                    description: `Голосование **происходит** c помощью отправления + в ${eventRecordChannel}, в порядке выставления. По пингу бота: ${client.user}\n-# Длительность голосования за кандитатуру ${hourTranslator(Math.floor(examinationTimeVote))}`,
                                                                    image: { url: appearance.custom.Mafia.default.nullImage },
                                                                    footer: { text: 'Приготовте свои +(ки)' }
                                                                },
                                                                {
                                                                    title: `Голосование: ${eventOfCategory.name}`,
                                                                    color: appearance.embed.color,
                                                                    description: `Кандитатуры голосования: ${exhibitedText || 'Пусто'}`,
                                                                    image: { url: eventOfCategory.game.image.vote }
                                                                }
                                                            ],
                                                            components: [
                                                                
                                                            ]
                                                        }).catch(() => {});
                                    
                                                        const timeStartVote = Date.now() / 1000;
                                    
                                                        setTimeout(async () => {
                                    
                                                            for (i in game.vote.members) vote.membersLength++;
                                    
                                                            for (const pickMember in game.vote.members) {
                                    
                                                                setTimeout(async () => {
                                                                    
                                                                    const fetchPickMember = await guild.members.fetch(game.vote.members[pickMember].id).catch(() => {});
                                                                    vote.members[game.vote.members[pickMember].id] = { voteMember: [], voteMemberLength: 0 };
                                                                    
                                                                    setTimeout(async () => {
                                    
                                                                        let voteLength = 0;
            
                                                                        let emojiMenuStatus = getNumber(game.vote.members[pickMember].number);
                                                                        let avatarPickMemberOfVote = await getAvatar (fetchPickMember);
                                                                        if (emojiMenuStatus[0] !== '`' && emojiMenuStatus.match(/<:[a-zA-Z0-9_]+:(\d+)>/)[1]) avatarPickMemberOfVote = `https://cdn.discordapp.com/emojis/${emojiMenuStatus.match(/<:[a-zA-Z0-9_]+:(\d+)>/)[1]}.png?size=512`;                

                                                                        const msgVoteOfMember = await eventRecordChannel.send({
                                                                            embeds: [
                                                                                {
                                                                                    title: `Голосование: ${eventOfCategory.name}`,
                                                                                    color: appearance.embed.color,
                                                                                    description: `Кандитатура: **${game.vote.members[pickMember].number}**\nЗакончится: <t:${Math.floor(Date.now() / 1000 + examinationTimeVote + 2)}:R>`,
                                                                                    thumbnail: { url: avatarPickMemberOfVote }
                                                                                }
                                                                            ],
                                                                            components: [
                                        
                                                                            ]
                                                                        }).catch(() => {});
                                    
                                                                        let work = true;
                                                                        let voteForMember = '';
                                                                        let time = examinationTimeVote;
                                                                        const intervalOfMemberVote = setInterval(async () => {
                                    
                                                                            if (time == 0) {

                                                                                clearInterval(intervalOfMemberVote);
                                                                                
                                                                                if (pickMember == vote.membersLength - 1 && eventOfCategory.game.vote.remainingInLast) {
                                    
                                                                                    for (const pickMemberOfGame in game.members) {
                                    
                                                                                        if (!vote.voteMembers.includes(game.members[pickMemberOfGame].id) && game.members[pickMemberOfGame].alive) {
                                    
                                                                                            if (voteForMember == '') voteForMember += `**${game.members[pickMemberOfGame].number}**`;
                                                                                            else voteForMember += `, **${game.members[pickMemberOfGame].number}**`;
                                                                                            vote.members[game.vote.members[pickMember].id].voteMember.push(game.members[pickMemberOfGame].id);
                                                                                            vote.members[game.vote.members[pickMember].id].voteMemberLength++;
                                                                                            vote.voteMembers.push(game.members[pickMemberOfGame].id);
                                                                                            voteLength++;
                                    
                                                                                        };
                                    
                                                                                    };
                                    
                                                                                };
                                    
                                                                                work = false;
                                                                                msgVoteOfMember.edit({
                                                                                    embeds: [
                                                                                        {
                                                                                            title: `Голосование: ${eventOfCategory.name}`,
                                                                                            color: appearance.embed.color,
                                                                                            description: `Кандитатура: **${game.vote.members[pickMember].number}**\nГолосов принято: **${voteLength}**`,
                                                                                            thumbnail: { url: avatarPickMemberOfVote }
                                                                                        }
                                                                                    ],
                                                                                    components: [
                                    
                                                                                    ]
                                                                                }).catch(() => {});

                                                                                if (emojiMenuStatus[0] !== '`' && emojiMenuStatus.match(/<:[a-zA-Z0-9_]+:(\d+)>/)[1]) avatarPickMemberOfVote = `https://cdn.discordapp.com/emojis/${emojiMenuStatus.match(/<:[a-zA-Z0-9_]+:(\d+)>/)[1]}.png?size=64`;                

                                                                                msgVoteOfMember.reply({
                                                                                    embeds: [
                                                                                        {
                                                                                            color: appearance.embed.color,
                                                                                            description: `## Спасибо (стоп)\n${voteForMember == '' ? 'Никто не проголосовал' : `Приняты голоса: ${voteForMember}`}`,
                                                                                            thumbnail: { url: avatarPickMemberOfVote }
                                                                                        }
                                                                                    ],
                                                                                    components: [
                                    
                                                                                    ]
                                                                                }).catch(() => {});
                                    
                                                                                if (pickMember == game.vote.members.length - 1) {
                                    
                                                                                    let kill = [];
                                                                                    let sortedVote = [];
                                                                                    Object.keys(vote.members).sort((a, b) => vote.members[b].voteMemberLength - vote.members[a].voteMemberLength).forEach(key => sortedVote.push({id: key, 'voteMemberLength': vote.members[key].voteMemberLength}));
                                                                                    for (const pickMember in sortedVote) if (sortedVote[pickMember].voteMemberLength == sortedVote[0].voteMemberLength) kill.push(sortedVote[pickMember].id);
                                        
                                                                                    if (kill.length < 2) {
                                                                                        
                                                                                        game.time = 'day';
                                                                                        const fetchPickMember = await guild.members.fetch(sortedVote[0].id).catch(() => {});
                                                                                        const memberOfGame = game.members.find(member => member.id == fetchPickMember.id);
                                        
                                                                                        const resultMsg = await eventRecordChannel.send({
                                                                                            embeds: [
                                                                                                {
                                                                                                    title: `Голосование: ${eventOfCategory.name}`,
                                                                                                    color: appearance.embed.color,
                                                                                                    description: `Погибает: **${memberOfGame.number}**`,
                                                                                                    image: { url: eventOfCategory.game.image.vote }
                                                                                                }
                                                                                            ],
                                                                                            components: [
                                                                                                {
                                                                                                    type: 1,
                                                                                                    components: [
                                                                                                        {
                                                                                                            type: 2, 
                                                                                                            style: 4, 
                                                                                                            customId: `kick`,
                                                                                                            label: `${memberOfGame.number}⠀Убрать заголосованного игрока`
                                                                                                        }
                                                                                                    ]
                                                                                                }
                                                                                            ]
                                                                                        }).catch(() => {});
                                        
                                                                                        const collectorConponentsOfResultMsg = await resultMsg.createMessageComponentCollector();
                                                                                        collectorConponentsOfResultMsg.on('collect', async newI => {
                                                                                            
                                                                                            if (newI.member.id !== guilds[EventId].Owner) return;
                                        
                                                                                            switch (newI.customId) { 
                                        
                                                                                                case 'kick': {
                                        
                                                                                                    game.members.find(member => member.id == fetchPickMember.id).alive = false;
                                                                                                    if (fetchPickMember) fetchPickMember.setNickname(memberOfGame.nickName).catch(() => {});
                                                                                                    for (n=0; n < game.servers.length; n++) {
                                        
                                                                                                        game.servers[n].guild.members.fetch().catch(() => {});
                                                                                                        const fetchPickMemberOfPickServer = await game.servers[n].guild.members.fetch(fetchPickMember.id).catch(() => {});
                                        
                                                                                                        if (fetchPickMemberOfPickServer) fetchPickMemberOfPickServer.kick().catch(() => {});
                                        
                                                                                                    };
                                        
                                                                                                    newI.update({
                                                                                                        components: [
                                                                                                            {
                                                                                                                type: 1,
                                                                                                                components: [
                                                                                                                    {
                                                                                                                        type: 2, 
                                                                                                                        style: 4, 
                                                                                                                        customId: `kick`,
                                                                                                                        label: `${memberOfGame.number}⠀Убрать заголосованного игрока`,
                                                                                                                        disabled: true
                                                                                                                    }
                                                                                                                ]
                                                                                                            }
                                                                                                        ]
                                                                                                    }).catch(() => {});
                                        
                                                                                                    const messageOfKick = await resultMsg.reply({  
                                                                                                        content: `||${fetchPickMember}||`,
                                                                                                        embeds: [
                                                                                                            {
                                                                                                                title: `Убийство: ${eventOfCategory.name}`,
                                                                                                                color: eventOfCategory.game.actions.kill.color,
                                                                                                                description: `Тип: ${eventOfCategory.game.vote.emoji} **${eventOfCategory.game.vote.name}**\nПользователь: ${getNumber(memberOfGame.number)} ${fetchPickMember}`,
                                                                                                                thumbnail: { url: await getAvatar(fetchPickMember) }
                                                                                                            }
                                                                                                        ],
                                                                                                        components: [
                                                                                                            {
                                                                                                                type: 1,
                                                                                                                components: [
                                                                                                                    {
                                                                                                                        type: 2, 
                                                                                                                        style: 4, 
                                                                                                                        customId: 'unKick', 
                                                                                                                        label: 'Вернуть в игру'
                                                                                                                    }
                                                                                                                ]
                                                                                                            }
                                                                                                        ]
                                                                                                    }).catch(() => {});
                                        
                                                                                                    if (!game.history.vote.includes({ id: fetchPickMember.id, number: memberOfGame.number})) game.history.vote.push({ id: fetchPickMember.id, number: memberOfGame.number});
                                        
                                                                                                    const collectorConponentsOfMessageOfKick = await messageOfKick.createMessageComponentCollector();
                                                                                                    collectorConponentsOfMessageOfKick.on('collect', async newI => {
                                                                                            
                                                                                                        if (newI.member.id !== guilds[EventId].Owner) return;
                                                                            
                                                                                                        switch (newI.customId) { 
                                        
                                                                                                            case 'unKick': {
                                        
                                                                                                                game.members.find(member => member.id == fetchPickMember.id).alive = true;
                                        
                                                                                                                let nick = memberOfGame.number;
                                                                                                                let nickPS = '';
                                        
                                                                                                                let punishments = 0;
                                                                                                                for (const pickPunishment in memberOfGame.punishment) punishments++;
                                                                                                                for (const pickPunishment in memberOfGame.punishment) {
                                        
                                                                                                                    if (memberOfGame.punishment[pickPunishment] < 0) memberOfGame.punishment[pickPunishment] = 0;
                                                                                                                    while (memberOfGame.punishment[pickPunishment] >= eventOfCategory.game.punishment.find(punishment => punishment.name == pickPunishment).max) memberOfGame.punishment[pickPunishment]--;
                                        
                                                                                                                    if (memberOfGame.punishment[pickPunishment] !== 0) {
                                        
                                                                                                                        if (nickPS !== '') nickPS += '; ';
                                                                                                                        nickPS += punishments > 1 ? eventOfCategory.game.punishment.find(punishment => punishment.name == pickPunishment).ps.mini : eventOfCategory.game.punishment.find(punishment => punishment.name == pickPunishment).ps.full;
                                                                                                                        nickPS += `: ${memberOfGame.punishment[pickPunishment]}/${eventOfCategory.game.punishment.find(punishment => punishment.name == pickPunishment).max}`;
                                        
                                                                                                                    };
                                        
                                                                                                                };
                                        
                                                                                                                if (nickPS !== '') nick += ` [${nickPS}]`;
                                                                                                                if (fetchPickMember) fetchPickMember.setNickname(nick).catch(() => {});
                                        
                                                                                                                newI.update({  
                                                                                                                    content: ` `,
                                                                                                                    embeds: [
                                                                                                                        {
                                                                                                                            title: `Убийтсво: ${eventOfCategory.name}`,
                                                                                                                            color: appearance.embed.color,
                                                                                                                            description: `Тип: ${eventOfCategory.game.vote.emoji} **${eventOfCategory.game.vote.name}**\nПользователь: ${getNumber(memberOfGame.number)} ${fetchPickMember}\n-# Убийство отменено`,
                                                                                                                            thumbnail: { url: await getAvatar(fetchPickMember) }
                                                                                                                        }
                                                                                                                    ],
                                                                                                                    components: [
                                                                                                                        
                                                                                                                    ]
                                                                                                                }).catch(() => {});
                                        
                                                                                                                if (game.history.vote.includes({ id: fetchPickMember.id, number: memberOfGame.number})) game.history.vote = game.history.vote.filter((n) => {return n != { id: fetchPickMember.id, number: memberOfGame.number}});
                                        
                                                                                                                if (game.time == 'day') {
                                        
                                                                                                                    eventVoiceChannel.permissionOverwrites.edit(fetchPickMember.id, { Speak: true }).catch(() => {});
                                                                                                                    eventRecordChannel.permissionOverwrites.edit(fetchPickMember.id, { SendMessages: true }).catch(() => {});
                                                                                                                    fetchPickMember.voice.setChannel(eventVoiceChannel.id).catch(() => {});
                                        
                                                                                                                };
                                                                                                                
                                                                                                                if (game.message.punishment) game.message.punishment.edit(punishmentOldInVote ()).catch(() => {});
                                                                                                                if (game.message.vote) game.message.vote.edit(voteMessage ()).catch(() => {});
                                                                            
                                                                                                            }
                                        
                                                                                                        };
                                        
                                                                                                    });
                                                                                                    
                                                                                                    eventVoiceChannel.permissionOverwrites.edit(fetchPickMember.id, { Speak: false }).catch(() => {});
                                                                                                    eventRecordChannel.permissionOverwrites.edit(fetchPickMember.id, { SendMessages: false }).catch(() => {});
                                                                                                    fetchPickMember.voice.setChannel(eventVoiceChannel.id).catch(() => {});
                                                                                                    
                                                                                                    if (game.message.punishment) game.message.punishment.edit(punishmentOldInVote ()).catch(() => {});
                                                                                                    if (game.message.vote) game.message.vote.edit(voteMessage ()).catch(() => {});
                                        
                                                                                                    return;
                                        
                                                                                                }
                                                                                            
                                                                                            };
                                        
                                                                                        });

                                                                                        game.vote.members = [];

                                                                                        if (game.message.punishment) game.message.punishment.edit(punishmentOldInVote ()).catch(() => {});
                                                                                        if (game.message.vote) game.message.vote.edit(voteMessage ()).catch(() => {});
                                        
                                                                                    }
                                        
                                                                                    else {
                                        
                                                                                        if (eventOfCategory.game.vote.collision) {
                                        
                                                                                            let killTextVote = '';
                                                                                            for (const pickMember in kill) {
                                                                                                
                                                                                                const pickMemberKillOfGame = game.members.find(member => member.id == kill[pickMember]);
                                                                                                if (killTextVote == '') killTextVote += `**${pickMemberKillOfGame.number}**`;
                                                                                                else killTextVote += `, **${pickMemberKillOfGame.number}**`;
                                        
                                                                                            };
                                        
                                                                                            game.message.votePreparation = await eventRecordChannel.send({
                                                                                                embeds: [
                                                                                                    {
                                                                                                        title: `Переголосования: ${eventOfCategory.name}`,
                                                                                                        color: appearance.embed.color,
                                                                                                        description: `Выставлены: ${killTextVote || 'Пусто'}`,
                                                                                                        image: { url: eventOfCategory.game.image.revote }
                                                                                                    }
                                                                                                ],
                                                                                                components: [
                                                                                                    {
                                                                                                        type: 1,
                                                                                                        components: [
                                                                                                            {
                                                                                                                type: 2, 
                                                                                                                style: 3, 
                                                                                                                customId: `voteStart`,
                                                                                                                label: `Запустить голосование`
                                                                                                            },
                                                                                                            {
                                                                                                                type: 2, 
                                                                                                                style: 4, 
                                                                                                                customId: `voteCancel`,
                                                                                                                label: `Отменить голосование`
                                                                                                            }
                                                                                                        ]
                                                                                                    }
                                                                                                ]
                                                                                            }).catch(() => {});
                                        
                                                                                            newI.update().catch(() => {});
                                        
                                                                                            const collectorConponentsOfVotePreparation = await game.message.votePreparation.createMessageComponentCollector();
                                                                                            collectorConponentsOfVotePreparation.on('collect', async newI => {
                                        
                                                                                                if (newI.member.id !== guilds[EventId].Owner) return;
                                                                    
                                                                                                switch (newI.customId) { 
                                                                    
                                                                                                    case 'voteStart': {
                                        
                                                                                                        if (game.message.vote) game.message.vote.edit(voteMessage ()).catch(() => {});
                                        
                                                                                                        game.time = 'vote';
                                                                                                        vote = {
                                        
                                                                                                            members: {},
                                                                                                            membersLength: 0,
                                                                                                            voteMembers: []
                                        
                                                                                                        };
                                        
                                                                                                        newI.update({
                                                                                                            embeds: [
                                                                                                                {
                                                                                                                    title: `Переголосования: ${eventOfCategory.name}`,
                                                                                                                    color: appearance.embed.color,
                                                                                                                    description: `Кандитатуры голосования: ${killTextVote || 'Пусто'}`,
                                                                                                                    image: { url: eventOfCategory.game.image.revote }
                                                                                                                }
                                                                                                            ],
                                                                                                            components: [
                                                                                                                
                                                                                                            ]
                                                                                                        }).catch(() => {});

                                                                                                        eventRecordChannel.send({
                                                                                                            content: `${eventRecordChannel}`,
                                                                                                            embeds: [
                                                                                                                {
                                                                                                                    title: `Переголосования: ${eventOfCategory.name}`,
                                                                                                                    color: appearance.embed.color,
                                                                                                                    description: `Кандитатуры: ${killTextVote || 'Пусто'}`
                                                                                                                }
                                                                                                            ],
                                                                                                            components: [
                                                                                                                
                                                                                                            ]
                                                                                                        }).catch(() => {});
                                        
                                                                                                        game.vote.members = [];
                                                                                                        for (const pickMember in kill) {
                                                                                                            
                                                                                                            const pickMemberKillOfGame = game.members.find(member => member.id == kill[pickMember]);
                                        
                                                                                                            if (pickMemberKillOfGame.alive) {
                                        
                                                                                                                game.vote.members.push(pickMemberKillOfGame);
                                        
                                                                                                            };
                                        
                                                                                                        };
                                        
                                                                                                        setTimeout(async () => {
                                        
                                                                                                            for (i in game.vote.members) vote.membersLength++;
                                        
                                                                                                            for (const pickMember in game.vote.members) {
                                        
                                                                                                                setTimeout(async () => {
                                                                                                                    
                                                                                                                    const fetchPickMember = await guild.members.fetch(game.vote.members[pickMember].id).catch(() => {});
                                                                                                                    vote.members[game.vote.members[pickMember].id] = { voteMember: [], voteMemberLength: 0 };
                                        
                                                                                                                    setTimeout(async () => {
                                        
                                                                                                                        let voteLength = 0;
            
                                                                                                                        let emojiMenuStatus = getNumber(game.vote.members[pickMember].number);
                                                                                                                        let avatarPickMemberOfVote = await getAvatar (fetchPickMember);
                                                                                                                        if (emojiMenuStatus[0] !== '`' && emojiMenuStatus.match(/<:[a-zA-Z0-9_]+:(\d+)>/)[1]) avatarPickMemberOfVote = `https://cdn.discordapp.com/emojis/${emojiMenuStatus.match(/<:[a-zA-Z0-9_]+:(\d+)>/)[1]}.png?size=512`;       

                                                                                                                        const msgVoteOfMember = await eventRecordChannel.send({
                                                                                                                            embeds: [
                                                                                                                                {
                                                                                                                                    title: `Переголосование: ${eventOfCategory.name}`,
                                                                                                                                    color: appearance.embed.color,
                                                                                                                                    description: `Кандитатура: **${game.vote.members[pickMember].number}**\nЗакончится: <t:${Math.floor(Date.now() / 1000 + examinationTimeVote + 1)}:R>`,
                                                                                                                                    thumbnail: { url: avatarPickMemberOfVote }
                                                                                                                                }
                                                                                                                            ],
                                                                                                                            components: [
                                        
                                                                                                                            ]
                                                                                                                        }).catch(() => {});
                                        
                                                                                                                        let work = true;
                                                                                                                        let voteForMember = '';
                                                                                                                        let time = examinationTimeVote;
                                                                                                                        const intervalOfMemberVote = setInterval(async () => {
                                        
                                                                                                                            if (time == 0) {

                                                                                                                                clearInterval(intervalOfMemberVote);
                                        
                                                                                                                                if (pickMember == vote.membersLength-1 && eventOfCategory.game.vote.remainingInLast) {
                                        
                                                                                                                                    for (const pickMemberOfGame in game.members) {
                                        
                                                                                                                                        if (!vote.voteMembers.includes (game.members[pickMemberOfGame].id) && game.members[pickMemberOfGame].alive) {
                                        
                                                                                                                                            if (voteForMember == '') voteForMember += `**${game.members[pickMemberOfGame].number}**`;
                                                                                                                                            else voteForMember += `, **${game.members[pickMemberOfGame].number}**`;
                                                                                                                                            vote.members[game.vote.members[pickMember].id].voteMember.push(game.members[pickMemberOfGame].id);
                                                                                                                                            vote.members[game.vote.members[pickMember].id].voteMemberLength++;
                                                                                                                                            vote.voteMembers.push(game.members[pickMemberOfGame].id);
                                                                                                                                            voteLength++;
                                        
                                                                                                                                        };
                                        
                                                                                                                                    };
                                        
                                                                                                                                };
                                        
                                                                                                                                work = false;
                                                                                                                                msgVoteOfMember.edit({
                                                                                                                                    embeds: [
                                                                                                                                        {
                                                                                                                                            title: `Переголосование: ${eventOfCategory.name}`,
                                                                                                                                            color: appearance.embed.color,
                                                                                                                                            description: `Кандитатура: **${game.vote.members[pickMember].number}**\nГолосов принято: **${voteLength}**`,
                                                                                                                                            thumbnail: { url: avatarPickMemberOfVote }
                                                                                                                                        }
                                                                                                                                    ],
                                                                                                                                    components: [
                                        
                                                                                                                                    ]
                                                                                                                                }).catch(() => {});                   

                                                                                                                                if (emojiMenuStatus[0] !== '`' && emojiMenuStatus.match(/<:[a-zA-Z0-9_]+:(\d+)>/)[1]) avatarPickMemberOfVote = `https://cdn.discordapp.com/emojis/${emojiMenuStatus.match(/<:[a-zA-Z0-9_]+:(\d+)>/)[1]}.png?size=64`;                
                                        
                                                                                                                                msgVoteOfMember.reply({
                                                                                                                                    embeds: [
                                                                                                                                        {
                                                                                                                                            color: appearance.embed.color,
                                                                                                                                            description: `## Спасибо (стоп)\n${voteForMember == '' ? 'Никто не проголосовал' : `Приняты голоса: ${voteForMember}`}`,
                                                                                                                                            thumbnail: { url: avatarPickMemberOfVote }
                                                                                                                                        }
                                                                                                                                    ],
                                                                                                                                    components: [
                                        
                                                                                                                                    ]
                                                                                                                                }).catch(() => {});
                                                                                                                                
                                                                                                                                
                                                                                                                                if (pickMember == game.vote.members.length - 1) {
                                                                                                                                    
                                                                                                                                    let kill = [];
                                                                                                                                    let sortedVote = [];
                                                                                                                                    Object.keys(vote.members).sort((a, b) => vote.members[b].voteMemberLength - vote.members[a].voteMemberLength).forEach(key => sortedVote.push({id: key, 'voteMemberLength': vote.members[key].voteMemberLength}));
                                                                                                                                    for (const pickMember in sortedVote) if (sortedVote[pickMember].voteMemberLength == sortedVote[0].voteMemberLength) kill.push(sortedVote[pickMember].id);
                                            
                                                                                                                                    let gameQuantity = 0;
                                                                                                                                    for (let pickMember in game.members) if (game.members[pickMember].alive) gameQuantity++;
                                                                                                                                    
                                                                                                                                    if (kill.length < 2) {
                                                                                                                                        
                                                                                                                                        game.time = 'day';
                                                                                                                                        game.vote.members = [];
                                                                                                                                        const fetchPickMember = await guild.members.fetch(kill[0]).catch(() => {});
                                                                                                                                        const memberOfGame = game.members.find(member => member.id == fetchPickMember.id);
                                            
                                                                                                                                        const resultMsg = await eventRecordChannel.send({
                                                                                                                                            embeds: [
                                                                                                                                                {
                                                                                                                                                    title: `Переголосование: ${eventOfCategory.name}`,
                                                                                                                                                    color: appearance.embed.color,
                                                                                                                                                    description: `Погибает: **${memberOfGame.number}**`,
                                                                                                                                                    image: { url: eventOfCategory.game.image.revote }
                                                                                                                                                }
                                                                                                                                            ],
                                                                                                                                            components: [
                                                                                                                                                {
                                                                                                                                                    type: 1,
                                                                                                                                                    components: [
                                                                                                                                                        {
                                                                                                                                                            type: 2, 
                                                                                                                                                            style: 4, 
                                                                                                                                                            customId: `kick`,
                                                                                                                                                            label: `${memberOfGame.number}⠀Убрать заголосованного игрока`
                                                                                                                                                        }
                                                                                                                                                    ]
                                                                                                                                                }
                                                                                                                                            ]
                                                                                                                                        }).catch(() => {});
                                                                                            
                                                                                                                                        const collectorConponentsOfResultMsg = await resultMsg.createMessageComponentCollector();
                                                                                                                                        collectorConponentsOfResultMsg.on('collect', async newI => {
                                                                                                                                            
                                                                                                                                            if (newI.member.id !== guilds[EventId].Owner) return;
                                                                                                                
                                                                                                                                            switch (newI.customId) { 
                                            
                                                                                                                                                case 'kick': {
                                                                                                    
                                                                                                                                                    game.members.find(member => member.id == fetchPickMember.id).alive = false;
                                                                                                                                                    if (fetchPickMember) fetchPickMember.setNickname(memberOfGame.nickName).catch(() => {});
                                                                                                                                                    for (n=0; n < game.servers.length; n++) {
                                                                                            
                                                                                                                                                        game.servers[n].guild.members.fetch().catch(() => {});
                                                                                                                                                        const fetchPickMemberOfPickServer = await game.servers[n].guild.members.fetch(fetchPickMember.id).catch(() => {});
                                                                                            
                                                                                                                                                        if (fetchPickMemberOfPickServer) fetchPickMemberOfPickServer.kick().catch(() => {});
                                                                                            
                                                                                                                                                    };
                                            
                                                                                                                                                    newI.update({
                                                                                                                                                        components: [
                                                                                                                                                            {
                                                                                                                                                                type: 1,
                                                                                                                                                                components: [
                                                                                                                                                                    {
                                                                                                                                                                        type: 2, 
                                                                                                                                                                        style: 4, 
                                                                                                                                                                        customId: `kick`,
                                                                                                                                                                        label: `${memberOfGame.number}⠀Убрать заголосованного игрока`,
                                                                                                                                                                        disabled: true
                                                                                                                                                                    }
                                                                                                                                                                ]
                                                                                                                                                            }
                                                                                                                                                        ]
                                                                                                                                                    }).catch(() => {});
                                            
                                                                                                                                                    const messageOfKick = await resultMsg.reply({  
                                                                                                                                                        content: `||${fetchPickMember}||`,
                                                                                                                                                        embeds: [
                                                                                                                                                            {
                                                                                                                                                                title: `Убийство: ${eventOfCategory.name}`,
                                                                                                                                                                color: eventOfCategory.game.actions.kill.color,
                                                                                                                                                                description: `Тип: ${eventOfCategory.game.vote.emoji} **${eventOfCategory.game.vote.name}**\nПользователь: ${getNumber(memberOfGame.number)} ${fetchPickMember}`,
                                                                                                                                                                thumbnail: { url: await getAvatar(fetchPickMember) }
                                                                                                                                                            }
                                                                                                                                                        ],
                                                                                                                                                        components: [
                                                                                                                                                            {
                                                                                                                                                                type: 1,
                                                                                                                                                                components: [
                                                                                                                                                                    {
                                                                                                                                                                        type: 2, 
                                                                                                                                                                        style: 4, 
                                                                                                                                                                        customId: 'unKick', 
                                                                                                                                                                        label: 'Вернуть в игру'
                                                                                                                                                                    }
                                                                                                                                                                ]
                                                                                                                                                            }
                                                                                                                                                        ]
                                                                                                                                                    }).catch(() => {});
                                            
                                                                                                                                                    if (!game.history.vote.includes({ id: fetchPickMember.id, number: memberOfGame.number})) game.history.vote.push({ id: fetchPickMember.id, number: memberOfGame.number});
                                            
                                                                                                                                                    const collectorConponentsOfMessageOfKick = await messageOfKick.createMessageComponentCollector();
                                                                                                                                                    collectorConponentsOfMessageOfKick.on('collect', async newI => {
                                                                                                                                            
                                                                                                                                                        if (newI.member.id !== guilds[EventId].Owner) return;
                                                                                                                            
                                                                                                                                                        switch (newI.customId) { 
                                                                                                                
                                                                                                                                                            case 'unKick': {
                                                                                            
                                                                                                                                                                game.members.find(member => member.id == fetchPickMember.id).alive = true;
                                                                                            
                                                                                                                                                                let nick = memberOfGame.number;
                                                                                                                                                                let nickPS = '';
                                                                                            
                                                                                                                                                                let punishments = 0;
                                                                                                                                                                for (const pickPunishment in memberOfGame.punishment) punishments++;
                                                                                                                                                                for (const pickPunishment in memberOfGame.punishment) {
                                                                                            
                                                                                                                                                                    if (memberOfGame.punishment[pickPunishment] < 0) memberOfGame.punishment[pickPunishment] = 0;
                                                                                                                                                                    while (memberOfGame.punishment[pickPunishment] >= eventOfCategory.game.punishment.find(punishment => punishment.name == pickPunishment).max) memberOfGame.punishment[pickPunishment]--;
                                                                                            
                                                                                                                                                                    if (memberOfGame.punishment[pickPunishment] !== 0) {
                                                                                            
                                                                                                                                                                        if (nickPS !== '') nickPS += '; ';
                                                                                                                                                                        nickPS += punishments > 1 ? eventOfCategory.game.punishment.find(punishment => punishment.name == pickPunishment).ps.mini : eventOfCategory.game.punishment.find(punishment => punishment.name == pickPunishment).ps.full;
                                                                                                                                                                        nickPS += `: ${memberOfGame.punishment[pickPunishment]}/${eventOfCategory.game.punishment.find(punishment => punishment.name == pickPunishment).max}`;
                                                                                                            
                                                                                                                                                                    };
                                                                                            
                                                                                                                                                                };
                                                                                            
                                                                                                                                                                if (nickPS !== '') nick += ` [${nickPS}]`;
                                                                                                                                                                if (fetchPickMember) fetchPickMember.setNickname(nick).catch(() => {});
                                                                                            
                                                                                                                                                                newI.update({  
                                                                                                                                                                    content: ` `,
                                                                                                                                                                    embeds: [
                                                                                                                                                                        {
                                                                                                                                                                            title: `Убийтсво: ${eventOfCategory.name}`,
                                                                                                                                                                            color: appearance.embed.color,
                                                                                                                                                                            description: `Тип: ${eventOfCategory.game.vote.emoji} **${eventOfCategory.game.vote.name}**\nПользователь: ${getNumber(memberOfGame.number)} ${fetchPickMember}\n-# Убийство отменено`,
                                                                                                                                                                            thumbnail: { url: await getAvatar(fetchPickMember) }
                                                                                                                                                                        }
                                                                                                                                                                    ],
                                                                                                                                                                    components: [
                                                                                                                                                                        
                                                                                                                                                                    ]
                                                                                                                                                                }).catch(() => {});
                                            
                                                                                                                                                                if (game.history.vote.includes({ id: fetchPickMember.id, number: memberOfGame.number})) game.history.vote = game.history.vote.filter((n) => {return n != { id: fetchPickMember.id, number: memberOfGame.number}});
                                                                                            
                                                                                                                                                                if (game.time == 'day') {
                                                                                            
                                                                                                                                                                    eventVoiceChannel.permissionOverwrites.edit(fetchPickMember.id, { Speak: true }).catch(() => {});
                                                                                                                                                                    eventRecordChannel.permissionOverwrites.edit(fetchPickMember.id, { SendMessages: true }).catch(() => {});
                                                                                                                                                                    fetchPickMember.voice.setChannel(eventVoiceChannel.id).catch(() => {});
                                                                                            
                                                                                                                                                                };
                                                                                                                                                                
                                                                                                                                                                if (game.message.punishment) game.message.punishment.edit(punishmentOldInVote ()).catch(() => {});
                                                                                                                                                                if (game.message.vote) game.message.vote.edit(voteMessage ()).catch(() => {});
                                                                                                                            
                                                                                                                                                            }
                                            
                                                                                                                                                        };
                                            
                                                                                                                                                    });
                                                                                                                                                    
                                                                                                                                                    eventVoiceChannel.permissionOverwrites.edit(fetchPickMember.id, { Speak: false }).catch(() => {});
                                                                                                                                                    eventRecordChannel.permissionOverwrites.edit(fetchPickMember.id, { SendMessages: false }).catch(() => {});
                                                                                                                                                    fetchPickMember.voice.setChannel(eventVoiceChannel.id).catch(() => {});
                                                                                                                                                    
                                                                                                                                                    if (game.message.punishment) game.message.punishment.edit(punishmentOldInVote ()).catch(() => {});
                                                                                                                                                    if (game.message.vote) game.message.vote.edit(voteMessage ()).catch(() => {});
                                                                                            
                                                                                                                                                    return;
                                                                                            
                                                                                                                                                }
                                                                                                                                            
                                                                                                                                            };
                                                                                                                
                                                                                                                                        });

                                                                                                                                        if (game.message.punishment) game.message.punishment.edit(punishmentOldInVote ()).catch(() => {});
                                                                                                                                        if (game.message.vote) game.message.vote.edit(voteMessage ()).catch(() => {});
                                            
                                                                                                                                    }
                                                                                                                                    
                                                                                                                                    else if (kill.length >= 2 && kill.length < gameQuantity*eventOfCategory.game.vote.collisionMaxPercent) {
                                            
                                                                                                                                        let killTextVote = '';

                                                                                                                                        for (const pickMember in kill) {
                                                                                                                                            
                                                                                                                                            const pickMemberKillOfGame = game.members.find(member => member.id == kill[pickMember]);
                                                                                                                                            if (killTextVote == '') killTextVote += `**${pickMemberKillOfGame.number}**`;
                                                                                                                                            else killTextVote += `, **${pickMemberKillOfGame.number}**`;

                                                                                                                                        };

                                                                                                                                        let voteLength = 0;
                                                                                                                                        let voteForMember = '';

                                                                                                                                        const timeStart = Date.now()/1000;

                                                                                                                                        const voteAllKickMessage = await eventRecordChannel.send({
                                                                                                                                            embeds: [
                                                                                                                                                {
                                                                                                                                                    title: `Голосование за поднятие: ${eventOfCategory.name}`,
                                                                                                                                                    color: appearance.embed.color,
                                                                                                                                                    description: `Кандитатуры на поднятие: ${killTextVote || 'Пусто'}`,
                                                                                                                                                    image: { url: eventOfCategory.game.image.voteAllkick }
                                                                                                                                                }
                                                                                                                                            ],
                                                                                                                                            components: [
                                                                                                                                                {
                                                                                                                                                    type: 1,
                                                                                                                                                    components: [
                                                                                                                                                        {
                                                                                                                                                            type: 2, 
                                                                                                                                                            style: 3, 
                                                                                                                                                            customId: `voteAllStart`,
                                                                                                                                                            label: `Запустить голосование`
                                                                                                                                                        },
                                                                                                                                                        {
                                                                                                                                                            type: 2, 
                                                                                                                                                            style: 4, 
                                                                                                                                                            customId: `voteAllCancel`,
                                                                                                                                                            label: `Отменить голосование`
                                                                                                                                                        }
                                                                                                                                                    ]
                                                                                                                                                }
                                                                                                                                            ]
                                                                                                                                        }).catch(() => {});

                                                                                                                                        const collectorConponentsOfVoteAllKickMessage = await voteAllKickMessage.createMessageComponentCollector();
                                                                                                                                        collectorConponentsOfVoteAllKickMessage.on('collect', async newI => {

                                                                                                                                            if (newI.member.id !== guilds[EventId].Owner) return;

                                                                                                                                            switch (newI.customId) { 

                                                                                                                                                case 'voteAllStart': {

                                                                                                                                                    newI.update({
                                                                                                                                                        embeds: [
                                                                                                                                                            {
                                                                                                                                                                title: `Голосование за поднятие: ${eventOfCategory.name}`,
                                                                                                                                                                color: appearance.embed.color,
                                                                                                                                                                description: `Кандитатуры на поднятие: ${killTextVote || 'Пусто'}`,
                                                                                                                                                                image: { url: eventOfCategory.game.image.voteAllkick }
                                                                                                                                                            }
                                                                                                                                                        ],
                                                                                                                                                        components: [
                                                                                                                                                            
                                                                                                                                                        ]
                                                                                                                                                    }).catch(() => {});
                                                                                                                                        
                                                                                                                                                    vote.voteMembers = [];
                                                                                                                                                    vote.all = { voteMember: [], voteMemberLength: 0 };
                                                                                                                                        
                                                                                                                                                    setTimeout(async () => {
                                                                                                                                        
                                                                                                                                                        let voteLength = 0;
                                                                                                                                                        
                                                                                                                                                        let gameMembers = [];
                                                                                                                                                        for (const pickMember in game.members) if (game.members[pickMember].alive) gameMembers.push(game.members[pickMember].number);
                                                                                                                                        
                                                                                                                                                        let avatarOfAllVote = null;
                                                                                                                                                        let emojiMenuStatus = appearance.emoji.VoteAll;
                                                                                                                                                        if (emojiMenuStatus[0] !== '`' && emojiMenuStatus.match(/<:[a-zA-Z0-9_]+:(\d+)>/)[1]) avatarOfAllVote = `https://cdn.discordapp.com/emojis/${emojiMenuStatus.match(/<:[a-zA-Z0-9_]+:(\d+)>/)[1]}.png?size=512`;       
                                                                                                                                        
                                                                                                                                                        const msgVoteOfMember = await eventRecordChannel.send({
                                                                                                                                                            embeds: [
                                                                                                                                                                {
                                                                                                                                                                    title: `Голосование за поднятие: ${eventOfCategory.name}`,
                                                                                                                                                                    color: appearance.embed.color,
                                                                                                                                                                    description: `Кандитатуры: ${killTextVote || 'Пусто'}\nЗакончится: <t:${Math.floor(Date.now() / 1000 + 6)}:R>`,
                                                                                                                                                                    thumbnail: { url: avatarOfAllVote }
                                                                                                                                                                }
                                                                                                                                                            ],
                                                                                                                                                            components: [
                                                                                                                                        
                                                                                                                                                            ]
                                                                                                                                                        }).catch(() => {});
                                                                                                                                        
                                                                                                                                                        let work = true;
                                                                                                                                                        let voteForMember = '';
                                                                                                                                                        let time = 6;
                                                                                                                                        
                                                                                                                                                        const intervalOfMemberAllVote = setInterval(async () => {
                                                                                                                                        
                                                                                                                                                            if (time == 0) {

                                                                                                                                                                work = false;
                                                                                                                                                                msgVoteOfMember.edit({
                                                                                                                                                                    embeds: [
                                                                                                                                                                        {
                                                                                                                                                                            title: `Голосование за поднятие: ${eventOfCategory.name}`,
                                                                                                                                                                            color: appearance.embed.color,
                                                                                                                                                                            description: `Кандитатуры: ${killTextVote || 'Пусто'}\nГолосов принято: **${voteLength}**`,
                                                                                                                                                                            thumbnail: { url: avatarOfAllVote }
                                                                                                                                                                        }
                                                                                                                                                                    ],
                                                                                                                                                                    components: [
                                                                                                                                        
                                                                                                                                                                    ]
                                                                                                                                                                }).catch(() => {});                   
                                                                                                                                        
                                                                                                                                                                let emojiMenuStatus = appearance.emoji.VoteAll;
                                                                                                                                                                if (emojiMenuStatus[0] !== '`' && emojiMenuStatus.match(/<:[a-zA-Z0-9_]+:(\d+)>/)[1]) avatarOfAllVote = `https://cdn.discordapp.com/emojis/${emojiMenuStatus.match(/<:[a-zA-Z0-9_]+:(\d+)>/)[1]}.png?size=64`;                
                                                                                                                                        
                                                                                                                                                                msgVoteOfMember.reply({
                                                                                                                                                                    embeds: [
                                                                                                                                                                        {
                                                                                                                                                                            color: appearance.embed.color,
                                                                                                                                                                            description: `## Спасибо (стоп)\n${voteForMember == '' ? 'Никто не проголосовал' : `Приняты голоса: ${voteForMember}`}`,
                                                                                                                                                                            thumbnail: { url: avatarOfAllVote }
                                                                                                                                                                        }
                                                                                                                                                                    ],
                                                                                                                                                                    components: [
                                                                                                                                        
                                                                                                                                                                    ]
                                                                                                                                                                }).catch(() => {});
                                                                                                                                        
                                                                                                                                                                if (voteLength > gameMembers.length/2) {
                                                                                                                                        
                                                                                                                                                                    if (game.message.vote) game.message.vote.edit(voteMessage ()).catch(() => {});
                                                                                                                                        
                                                                                                                                                                    game.time = 'day';
                                                                                                                                                                    game.vote.members = [];
                                                                                                                                                                    
                                                                                                                                                                    let resultKickMembers = '';
                                                                                                                                                                    let componentsResultKickMembers = [];
                                                                                                                                                                    componentsResultKickMembers.push(
                                                                                                                                                                        {
                                                                                                                                                                            type: 1,
                                                                                                                                                                            components: []
                                                                                                                                                                        }
                                                                                                                                                                    );
                                                                                                                                        
                                                                                                                                        
                                                                                                                                                                    const resultMsg = await eventRecordChannel.send({
                                                                                                                                                                        embeds: [
                                                                                                                                                                            {
                                                                                                                                                                                title: `Голосование за поднятие: ${eventOfCategory.name}`,
                                                                                                                                                                                color: appearance.embed.color,
                                                                                                                                                                                description: `Погибает: Загружается...`,
                                                                                                                                                                                image: { url: eventOfCategory.game.image.voteAllkick }
                                                                                                                                                                            }
                                                                                                                                                                        ]
                                                                                                                                                                    }).catch(() => {});
                                                                                                                                        
                                                                                                                                                                    for (const pickMember in kill) {
                                                                                                                                                                        
                                                                                                                                                                        const pickMemberKillOfGame = game.members.find(member => member.id == kill[pickMember]);
                                                                                                                                                                        const fetchPickMember = await guild.members.fetch(pickMemberKillOfGame.id).catch(() => {});
                                                                                                                                        
                                                                                                                                                                        if (resultKickMembers == '') resultKickMembers += `**${pickMemberKillOfGame.number}**`;
                                                                                                                                                                        else resultKickMembers += `, **${pickMemberKillOfGame.number}**`;
                                                                                                                                        
                                                                                                                                                                        if (!componentsResultKickMembers[0] || componentsResultKickMembers[componentsResultKickMembers.length-1].components.length == 5) 
                                                                                                                                                                        componentsResultKickMembers.push(
                                                                                                                                                                            {
                                                                                                                                                                                type: 1,
                                                                                                                                                                                components: []
                                                                                                                                                                            }
                                                                                                                                                                        );
                                                                                                                                        
                                                                                                                                                                        componentsResultKickMembers[componentsResultKickMembers.length-1].components.push(
                                                                                                                                                                            {
                                                                                                                                                                                type: 2, 
                                                                                                                                                                                style: 4, 
                                                                                                                                                                                customId: `kick${pickMemberKillOfGame.number}`,
                                                                                                                                                                                label: `${pickMemberKillOfGame.number}⠀Убрать заголосованного игрока`
                                                                                                                                                                            }
                                                                                                                                                                        );
                                                                                                                                        
                                                                                                                                                                        const collectorConponentsOfResultMsg = await resultMsg.createMessageComponentCollector();
                                                                                                                                                                        collectorConponentsOfResultMsg.on('collect', async newI => {
                                                                                                                                                                            
                                                                                                                                                                            if (newI.member.id !== guilds[EventId].Owner) return;
                                                                                                                                                
                                                                                                                                                                            switch (newI.customId) { 
                                                                                                                                        
                                                                                                                                                                                case `kick${pickMemberKillOfGame.number}`: {
                                                                                                                                        
                                                                                                                                                                                    game.members.find(member => member.id == fetchPickMember.id).alive = false;
                                                                                                                                                                                    if (fetchPickMember) fetchPickMember.setNickname(pickMemberKillOfGame.nickName).catch(() => {});
                                                                                                                                                                                    for (n=0; n < game.servers.length; n++) {
                                                                                                                                        
                                                                                                                                                                                        game.servers[n].guild.members.fetch().catch(() => {});
                                                                                                                                                                                        const fetchPickMemberOfPickServer = await game.servers[n].guild.members.fetch(fetchPickMember.id).catch(() => {});
                                                                                                                                        
                                                                                                                                                                                        if (fetchPickMemberOfPickServer) fetchPickMemberOfPickServer.kick().catch(() => {});
                                                                                                                                        
                                                                                                                                                                                    };
                                                                                                                                        
                                                                                                                                                                                    resultMsg.components.forEach(component => {
                                                                                                                                        
                                                                                                                                                                                        let Comp = component.components;
                                                                                                                                                                        
                                                                                                                                                                                        for (c = 0; c < Comp.length; c++) {
                                                                                                                                                                        
                                                                                                                                                                                            if (Comp[c].data.style !== 5 && Comp[c].data.custom_id == `kick${pickMemberKillOfGame.number}`) Comp[c].data.disabled = true;
                                                                                                                                                                        
                                                                                                                                                                                        };
                                                                                                                                                                                        
                                                                                                                                                                                    });
                                                                                                                                                
                                                                                                                                                                                    await newI.update({ components: resultMsg.components });
                                                                                                                                        
                                                                                                                                                                                    const messageOfKick = await resultMsg.reply({  
                                                                                                                                                                                        content: `||${fetchPickMember}||`,
                                                                                                                                                                                        embeds: [
                                                                                                                                                                                            {
                                                                                                                                                                                                title: `Убийство: ${eventOfCategory.name}`,
                                                                                                                                                                                                color: eventOfCategory.game.actions.kill.color,
                                                                                                                                                                                                description: `Тип: ${eventOfCategory.game.vote.emoji} **${eventOfCategory.game.vote.name}**\nПользователь: ${getNumber(pickMemberKillOfGame.number)} ${fetchPickMember}`,
                                                                                                                                                                                                thumbnail: { url: await getAvatar(fetchPickMember) }
                                                                                                                                                                                            }
                                                                                                                                                                                        ],
                                                                                                                                                                                        components: [
                                                                                                                                                                                            {
                                                                                                                                                                                                type: 1,
                                                                                                                                                                                                components: [
                                                                                                                                                                                                    {
                                                                                                                                                                                                        type: 2, 
                                                                                                                                                                                                        style: 4, 
                                                                                                                                                                                                        customId: 'unKick', 
                                                                                                                                                                                                        label: 'Вернуть в игру'
                                                                                                                                                                                                    }
                                                                                                                                                                                                ]
                                                                                                                                                                                            }
                                                                                                                                                                                        ]
                                                                                                                                                                                    }).catch(() => {});
                                                                                                                                        
                                                                                                                                                                                    if (!game.history.vote.includes({ id: fetchPickMember.id, number: pickMemberKillOfGame.number})) game.history.vote.push({ id: fetchPickMember.id, number: pickMemberKillOfGame.number});
                                                                                                                                        
                                                                                                                                                                                    const collectorConponentsOfMessageOfKick = await messageOfKick.createMessageComponentCollector();
                                                                                                                                                                                    collectorConponentsOfMessageOfKick.on('collect', async newI => {
                                                                                                                                                                            
                                                                                                                                                                                        if (newI.member.id !== guilds[EventId].Owner) return;
                                                                                                                                                            
                                                                                                                                                                                        switch (newI.customId) { 
                                                                                                                                                
                                                                                                                                                                                            case 'unKick': {
                                                                                                                                        
                                                                                                                                                                                                game.members.find(member => member.id == fetchPickMember.id).alive = true;
                                                                                                                                        
                                                                                                                                                                                                let nick = pickMemberKillOfGame.number;
                                                                                                                                                                                                let nickPS = '';
                                                                                                                                        
                                                                                                                                                                                                let punishments = 0;
                                                                                                                                                                                                for (const pickPunishment in pickMemberKillOfGame.punishment) punishments++;
                                                                                                                                                                                                for (const pickPunishment in pickMemberKillOfGame.punishment) {
                                                                                                                                        
                                                                                                                                                                                                    if (pickMemberKillOfGame.punishment[pickPunishment] < 0) pickMemberKillOfGame.punishment[pickPunishment] = 0;
                                                                                                                                                                                                    while (pickMemberKillOfGame.punishment[pickPunishment] >= eventOfCategory.game.punishment.find(punishment => punishment.name == pickPunishment).max) pickMemberKillOfGame.punishment[pickPunishment]--;
                                                                                                                                        
                                                                                                                                                                                                    if (pickMemberKillOfGame.punishment[pickPunishment] !== 0) {
                                                                                                                                        
                                                                                                                                                                                                        if (nickPS !== '') nickPS += '; ';
                                                                                                                                                                                                        nickPS += punishments > 1 ? eventOfCategory.game.punishment.find(punishment => punishment.name == pickPunishment).ps.mini : eventOfCategory.game.punishment.find(punishment => punishment.name == pickPunishment).ps.full;
                                                                                                                                                                                                        nickPS += `: ${pickMemberKillOfGame.punishment[pickPunishment]}/${eventOfCategory.game.punishment.find(punishment => punishment.name == pickPunishment).max}`;
                                                                                                                                            
                                                                                                                                                                                                    };
                                                                                                                                        
                                                                                                                                                                                                };
                                                                                                                                        
                                                                                                                                                                                                if (nickPS !== '') nick += ` [${nickPS}]`;
                                                                                                                                                                                                if (fetchPickMember) fetchPickMember.setNickname(nick).catch(() => {});
                                                                                                                                        
                                                                                                                                                                                                newI.update({  
                                                                                                                                                                                                    content: ` `,
                                                                                                                                                                                                    embeds: [
                                                                                                                                                                                                        {
                                                                                                                                                                                                            title: `Убийтсво: ${eventOfCategory.name}`,
                                                                                                                                                                                                            color: appearance.embed.color,
                                                                                                                                                                                                            description: `Тип: ${eventOfCategory.game.vote.emoji} **${eventOfCategory.game.vote.name}**\nПользователь: ${getNumber(pickMemberKillOfGame.number)} ${fetchPickMember}\n-# Убийство отменено`,
                                                                                                                                                                                                            thumbnail: { url: await getAvatar(fetchPickMember) }
                                                                                                                                                                                                        }
                                                                                                                                                                                                    ],
                                                                                                                                                                                                    components: [
                                                                                                                                                                                                        
                                                                                                                                                                                                    ]
                                                                                                                                                                                                }).catch(() => {});
                                                                                                                                        
                                                                                                                                                                                                if (game.history.vote.includes({ id: fetchPickMember.id, number: pickMemberKillOfGame.number})) game.history.vote = game.history.vote.filter((n) => {return n != { id: fetchPickMember.id, number: pickMemberKillOfGame.number}});
                                                                                                                                        
                                                                                                                                                                                                if (game.time == 'day') {
                                                                                                                                        
                                                                                                                                                                                                    eventVoiceChannel.permissionOverwrites.edit(fetchPickMember.id, { Speak: true }).catch(() => {});
                                                                                                                                                                                                    eventRecordChannel.permissionOverwrites.edit(fetchPickMember.id, { SendMessages: true }).catch(() => {});
                                                                                                                                                                                                    fetchPickMember.voice.setChannel(eventVoiceChannel.id).catch(() => {});
                                                                                                                                        
                                                                                                                                                                                                };
                                                                                                                                                                                                
                                                                                                                                                                                                if (game.message.punishment) game.message.punishment.edit(punishmentOldInVote ()).catch(() => {});
                                                                                                                                                                                                if (game.message.vote) game.message.vote.edit(voteMessage ()).catch(() => {});
                                                                                                                                                            
                                                                                                                                                                                            }
                                                                                                                                        
                                                                                                                                                                                        };
                                                                                                                                        
                                                                                                                                                                                    });
                                                                                                                                                                                    
                                                                                                                                                                                    eventVoiceChannel.permissionOverwrites.edit(fetchPickMember.id, { Speak: false }).catch(() => {});
                                                                                                                                                                                    eventRecordChannel.permissionOverwrites.edit(fetchPickMember.id, { SendMessages: false }).catch(() => {});
                                                                                                                                                                                    fetchPickMember.voice.setChannel(eventVoiceChannel.id).catch(() => {});
                                                                                                                                                                                    
                                                                                                                                                                                    if (game.message.punishment) game.message.punishment.edit(punishmentOldInVote ()).catch(() => {});
                                                                                                                                                                                    if (game.message.vote) game.message.vote.edit(voteMessage ()).catch(() => {});
                                                                                                                                        
                                                                                                                                                                                    return;
                                                                                                                                        
                                                                                                                                                                                }
                                                                                                                                                                            
                                                                                                                                                                            };
                                                                                                                                                
                                                                                                                                                                        });
                                                                                                                                                                        
                                                                                                                                        
                                                                                                                                                                    };
                                                                                                                                        
                                                                                                                                                                    if (game.message.vote) game.message.vote.edit(voteMessage ()).catch(() => {});
                                                                                                                                                                        
                                                                                                                                                                    resultMsg.edit({
                                                                                                                                                                        embeds: [
                                                                                                                                                                            {
                                                                                                                                                                                title: `Голосование за поднятие: ${eventOfCategory.name}`,
                                                                                                                                                                                color: appearance.embed.color,
                                                                                                                                                                                description: `Погибает: ${resultKickMembers}`,
                                                                                                                                                                                image: { url: eventOfCategory.game.image.voteAllkick }
                                                                                                                                                                            }
                                                                                                                                                                        ],
                                                                                                                                                                        components: componentsResultKickMembers
                                                                                                                                                                    }).catch(() => {});

                                                                                                                                                                    if (game.message.punishment) game.message.punishment.edit(punishmentOldInVote ()).catch(() => {});
                                                                                                                                                                    if (game.message.vote) game.message.vote.edit(voteMessage ()).catch(() => {});
                                                                                                                                        
                                                                                                                                                                    return clearInterval (intervalOfMemberAllVote);
                                                                                                                                        
                                                                                                                                                                }
                                                                                                                                        
                                                                                                                                                                else {
                                                                                                                                                                    
                                                                                                                                                                    if (game.message.vote) game.message.vote.edit(voteMessage ()).catch(() => {});
                                                                                                                                        
                                                                                                                                                                    game.time = 'day';
                                                                                                                                        
                                                                                                                                                                    eventRecordChannel.send({
                                                                                                                                                                        embeds: [
                                                                                                                                                                            {
                                                                                                                                                                                title: `Голосование за поднятие: ${eventOfCategory.name}`,
                                                                                                                                                                                color: appearance.embed.color,
                                                                                                                                                                                description: `Никто не погибает`,
                                                                                                                                                                                image: { url: eventOfCategory.game.image.voteAllkick }
                                                                                                                                                                            }
                                                                                                                                                                        ],
                                                                                                                                                                        components: [
                                                                                                                                                                            
                                                                                                                                                                        ]
                                                                                                                                                                    }).catch(() => {});
                                                                                                                                        
                                                                                                                                                                };

                                                                                                                                                                if (game.message.punishment) game.message.punishment.edit(punishmentOldInVote ()).catch(() => {});
                                                                                                                                                                if (game.message.vote) game.message.vote.edit(voteMessage ()).catch(() => {});
                                                                                                                                        
                                                                                                                                                                return clearInterval (intervalOfMemberAllVote);
                                                                                                                                        
                                                                                                                                                            };
                                                                                                                                        
                                                                                                                                                            time--;
                                                                                                                                        
                                                                                                                                                        }, 1000);
                                                                                                                                        
                                                                                                                                                        client.on('messageCreate', async message => {
                                                                                                                                        
                                                                                                                                                            if (!message.member || message.channel.id !== eventRecordChannel.id || work !== true || !game.members.find(member => member.id == message.member.id) || message.content !== '+' || vote.voteMembers.find(i => i == message.member.id)) return;
                                                                                                                                                            
                                                                                                                                                            if (!vote.voteMembers.find(i => i == message.member.id)) {
                                                                                                                                        
                                                                                                                                                                vote.voteMembers.push(message.member.id);
                                                                                                                                        
                                                                                                                                                                if (voteForMember == '') voteForMember += `**${game.members.find(member => member.id == message.member.id).number}**`;
                                                                                                                                                                else voteForMember += `, **${game.members.find(member => member.id == message.member.id).number}**`;
                                                                                                                                                                vote.all.voteMember.push(message.member.id);
                                                                                                                                                                vote.all.voteMemberLength++;
                                                                                                                                                                
                                                                                                                                                                voteLength++;
                                                                                                                                        
                                                                                                                                                                message.react(appearance.emoji.Vote).catch(() => {});
                                                                                                                                        
                                                                                                                                                            };
                                                                                                                                        
                                                                                                                                                        });
                                                                                                                                                        
                                                                                                                                                    }, 1500);
                                                                                                                                        
                                                                                                                                                    break;
                                                                                                                                        
                                                                                                                                                }
                                                                                                                                        
                                                                                                                                                case 'voteAllCancel': {
                                                                                                                                                                                                    
                                                                                                                                                    if (game.message.vote) game.message.vote.edit(voteMessage ()).catch(() => {});
                                                                                                                                        
                                                                                                                                                    game.time = 'day';
                                                                                                                                                    game.vote.members = [];
                                                                                                                                                    for (const pickMember in game.members) {
                                                                                                                                        
                                                                                                                                                        if (game.members[pickMember].alive) {
                                                                                                                                        
                                                                                                                                                            const fetchPickMember = await guild.members.fetch(game.members[pickMember].id).catch(() => {});
                                                                                                                                        
                                                                                                                                                            if (fetchPickMember) {
                                                                                                                                        
                                                                                                                                                                eventRecordChannel.permissionOverwrites.edit(fetchPickMember.id, { SendMessages: true }).catch(() => {});
                                                                                                                                        
                                                                                                                                                            };
                                                                                                                                        
                                                                                                                                                        };
                                                                                                                                        
                                                                                                                                                    };
                                                                                                                                        
                                                                                                                                                    newI.update({
                                                                                                                                                        embeds: [
                                                                                                                                                            {
                                                                                                                                                                title: `Отмена голосования за поднятие: ${eventOfCategory.name}`,
                                                                                                                                                                color: appearance.embed.color,
                                                                                                                                                                description: `Кандитатуры на поднятие: ${killTextVote || 'Пусто'}`,
                                                                                                                                                                image: { url: eventOfCategory.game.image.voteAllkick }
                                                                                                                                                            }
                                                                                                                                                        ],
                                                                                                                                                        components: [
                                                                                                                                                            
                                                                                                                                                        ]
                                                                                                                                                    }).catch(() => {});
                                                                                                                                        
                                                                                                                                                    if (game.message.punishment) game.message.punishment.edit(punishmentOldInVote ()).catch(() => {});
                                                                                                                                                    if (game.message.vote) game.message.vote.edit(voteMessage ()).catch(() => {});
                                                                                                                                        
                                                                                                                                                    break;
                                                                                                                                        
                                                                                                                                                }

                                                                                                                                            };

                                                                                                                                        });
                                            
                                                                                                                                    }
                                            
                                                                                                                                    else {
                                                                                                                                                        
                                                                                                                                        if (game.message.vote) game.message.vote.edit(voteMessage ()).catch(() => {});
                                            
                                                                                                                                        game.time = 'day';
                                                                                                                                        game.vote.members = [];
                                                                                                                                        eventRecordChannel.send({
                                                                                                                                            embeds: [
                                                                                                                                                {
                                                                                                                                                    title: `Переголосование: ${eventOfCategory.name}`,
                                                                                                                                                    color: appearance.embed.color,
                                                                                                                                                    description: `Никто не погибает`,
                                                                                                                                                    image: { url: eventOfCategory.game.image.revote }
                                                                                                                                                }
                                                                                                                                            ],
                                                                                                                                            components: [
                                                                                                                                                
                                                                                                                                            ]
                                                                                                                                        }).catch(() => {});
                                                        
                                                                                                                                        if (game.message.punishment) game.message.punishment.edit(punishmentOldInVote ()).catch(() => {});
                                                                                                                                        if (game.message.vote) game.message.vote.edit(voteMessage ()).catch(() => {});
                                            
                                                                                                                                    };
                                    
                                                                                                                                };
                                        
                                                                                                                                return clearInterval (intervalOfMemberVote);
                                        
                                                                                                                            };

                                                                                                                            time--;
                                        
                                                                                                                        }, 1000);
                                        
                                                                                                                        client.on('messageCreate', async message => {
                                        
                                                                                                                            if (!message.member || message.channel.id !== eventRecordChannel.id || work !== true || !game.members.find(member => member.id == message.member.id) || message.content !== '+' || vote.voteMembers.find(i => i == message.member.id)) return;
                                                                                                                            
                                                                                                                            if (!vote.voteMembers.find(i => i == message.member.id)) {
                                        
                                                                                                                                vote.voteMembers.push(message.member.id);
                                        
                                                                                                                                if (voteForMember == '') voteForMember += `**${game.members.find(member => member.id == message.member.id).number}**`;
                                                                                                                                else voteForMember += `, **${game.members.find(member => member.id == message.member.id).number}**`;
                                                                                                                                vote.members[game.vote.members[pickMember].id].voteMember.push(message.member.id);
                                                                                                                                vote.members[game.vote.members[pickMember].id].voteMemberLength++;
                                                                                                                                
                                                                                                                                voteLength++;

                                                                                                                                message.react(appearance.emoji.Vote).catch(() => {});
                                        
                                                                                                                            };
                                        
                                                                                                                        });
                                                                                                                        
                                                                                                                    }, 1);
                                                                                                                    
                                                                                                                }, pickMember*(examinationTimeVote+5.5)*1000);
                                        
                                                                                                            };
                                        
                                                                                                        }, 3000);
                                        
                                                                                                        break;
                                        
                                                                                                    }
                                                                    
                                                                                                    case 'voteCancel': {
                                                                                                                                                        
                                                                                                        if (game.message.vote) game.message.vote.edit(voteMessage ()).catch(() => {});
                                        
                                                                                                        game.time = 'day';
                                                                                                        game.vote.members = [];
                                                                                                        for (const pickMember in game.members) {
                                        
                                                                                                            if (game.members[pickMember].alive) {
                                        
                                                                                                                const fetchPickMember = await guild.members.fetch(game.members[pickMember].id).catch(() => {});
                                        
                                                                                                                if (fetchPickMember) {
                                        
                                                                                                                    eventRecordChannel.permissionOverwrites.edit(fetchPickMember.id, { SendMessages: true }).catch(() => {});
                                        
                                                                                                                };
                                        
                                                                                                            };
                                        
                                                                                                        };
                                        
                                                                                                        newI.update({
                                                                                                            embeds: [
                                                                                                                {
                                                                                                                    title: `Отмена переголосования: ${eventOfCategory.name}`,
                                                                                                                    color: appearance.embed.color,
                                                                                                                    description: `Были выставлены: ${killTextVote || 'Пусто'}`,
                                                                                                                    image: { url: eventOfCategory.game.image.revote }
                                                                                                                }
                                                                                                            ],
                                                                                                            components: [
                                                                                                                
                                                                                                            ]
                                                                                                        }).catch(() => {});
                                                        
                                                                                                        if (game.message.punishment) game.message.punishment.edit(punishmentOldInVote ()).catch(() => {});
                                                                                                        if (game.message.vote) game.message.vote.edit(voteMessage ()).catch(() => {});
                                        
                                                                                                        break;
                                        
                                                                                                    }
                                        
                                                                                                };
                                        
                                                                                            });
                                        
                                                                                        }
                                        
                                                                                        else {
                                                                                                                                                        
                                                                                            if (game.message.vote) game.message.vote.edit(voteMessage ()).catch(() => {});
                                                                                            
                                                                                            game.time = 'day';
                                                                                            game.vote.members = [];
                                                                                            eventRecordChannel.send({
                                                                                                embeds: [
                                                                                                    {
                                                                                                        title: `Голосование: ${eventOfCategory.name}`,
                                                                                                        color: appearance.embed.color,
                                                                                                        description: `Никто не погибает`,
                                                                                                        image: { url: eventOfCategory.game.image.vote }
                                                                                                    }
                                                                                                ],
                                                                                                components: [
                                                                                                    
                                                                                                ]
                                                                                            }).catch(() => {});

                                                                                            if (game.message.punishment) game.message.punishment.edit(punishmentOldInVote ()).catch(() => {});
                                                                                            if (game.message.vote) game.message.vote.edit(voteMessage ()).catch(() => {});
                                        
                                                                                        };
                                        
                                                                                    };
                                                                                    
                                    
                                                                                };
                                                                                
                                                                                return clearInterval (intervalOfMemberVote);
                                    
                                                                            };
                                                                            
                                                                            time--;
                                    
                                                                        }, 1000);
                                    
                                                                        client.on('messageCreate', async message => {
                                    
                                                                            if (!message.member || message.channel.id !== eventRecordChannel.id || work !== true || !game.members.find(member => member.id == message.member.id) || message.content !== '+' || vote.voteMembers.find(i => i == message.member.id)) return;
                                                                            
                                                                            if (!vote.voteMembers.find(i => i == message.member.id)) {
                                    
                                                                                vote.voteMembers.push(message.member.id);
                                                                                if (voteForMember == '') voteForMember += `**${game.members.find(member => member.id == message.member.id).number}**`;
                                                                                else voteForMember += `, **${game.members.find(member => member.id == message.member.id).number}**`;
                                                                                vote.members[game.vote.members[pickMember].id].voteMember.push(message.member.id);
                                                                                vote.members[game.vote.members[pickMember].id].voteMemberLength++;
                                                                                
                                                                                voteLength++;

                                                                                message.react(appearance.emoji.Vote).catch(() => {});
                                    
                                                                            };
                                    
                                                                        });
                                                                        
                                                                    }, 1);
                                                                    
                                                                }, pickMember*(examinationTimeVote+5.5)*1000);
                                    
                                                            };
                                    
                                                        }, 4000);
                                    
                                                        break;
                                    
                                                    }
                                    
                                                    case 'voteCancel': {
                                                                                                                                                        
                                                        if (game.message.vote) game.message.vote.edit(voteMessage ()).catch(() => {});
                                    
                                                        game.time = 'day';
                                                        for (const pickMember in game.members) {
                                    
                                                            if (game.members[pickMember].alive) {
                                    
                                                                const fetchPickMember = await guild.members.fetch(game.members[pickMember].id).catch(() => {});
                                    
                                                                if (fetchPickMember) {
                                    
                                                                    eventRecordChannel.permissionOverwrites.edit(fetchPickMember.id, { SendMessages: true }).catch(() => {});
                                    
                                                                };
                                    
                                                            };
                                    
                                                        };
                                    
                                                        game.vote.members = [];
                                                        let exhibitedTextVote = '';
                                                        for (const pickMember in game.members) {
                                    
                                                            if (game.vote.members.find(member => member.id == game.members[pickMember].id)) {
                                    
                                                                if (exhibitedTextVote == '') exhibitedTextVote += `**${game.members[pickMember].number}**`;
                                                                else exhibitedTextVote += `, **${game.members[pickMember].number}**`;
                                    
                                                            };
                                    
                                                        };

                                                        if (game.message.punishment) game.message.punishment.edit(punishmentOldInVote ()).catch(() => {});
                                                        if (game.message.vote) game.message.vote.edit(voteMessage ()).catch(() => {});
                                    
                                                        newI.update({
                                                            embeds: [
                                                                {
                                                                    title: `Отмена голосования: ${eventOfCategory.name}`,
                                                                    color: appearance.embed.color,
                                                                    description: `Были выставлены: ${exhibitedText || 'Пусто'}`,
                                                                    image: { url: eventOfCategory.game.image.vote }
                                                                }
                                                            ],
                                                            components: [
                                                                
                                                            ]
                                                        }).catch(() => {});
                                    
                                                        break;
                                    
                                                    }
                                    
                                                };
                                    
                                            });
                                    
                                        });
                                    
                                        actions['vote'] = {
                                            actions: [vote],
                                            all: false
                                        };
                                    
                                        componentsVote.push(
                                            {
                                                type: 1,
                                                components: []
                                            }
                                        );
                                    
                                    
                                        for (const pickMember in game.vote.members) {
                                    
                                            if (exhibitedText == '') exhibitedText += `**${game.vote.members[pickMember].number}**`;
                                            else exhibitedText += `, **${game.vote.members[pickMember].number}**`;
                                    
                                        };
                                    
                                        for (const pickMember in game.members) {
                                                
                                            if (!componentsVote[0] || componentsVote[componentsVote.length-1].components.length == 5) 
                                            componentsVote.push(
                                                {
                                                    type: 1,
                                                    components: []
                                                }
                                            );
                                    
                                            if (game.members[pickMember].alive) {
                                    
                                                componentsVote[componentsVote.length-1].components.push(
                                                    {
                                                        type: 2, 
                                                        style: game.vote.members.find(member => member.id == game.members[pickMember].id) ? 3 : appearance.buttons_menu.Default.style, 
                                                        customId: `vote${game.members[pickMember].number}`,
                                                        label: `${game.members[pickMember].number}`, 
                                                        disabled: false
                                                    }
                                                );
                                    
                                            }
                                    
                                            else {
                                    
                                                componentsVote[componentsVote.length-1].components.push(
                                                    {
                                                        type: 2, 
                                                        style: 4, 
                                                        customId: `vote${game.members[pickMember].number}`,
                                                        label: `${game.members[pickMember].number}`, 
                                                        disabled: true
                                                    }
                                                );
                                    
                                            };
                                            
                                            const pickVoteutton = (async (newI) => {
                                    
                                                if(guilds[EventId].Owner !== newI.member.id) return newI.reply(await errorNoEventsOwnerMessage (newI.member));
                                                if (game.time == 'vote') 
                                                return newI.reply({
                                                    ephemeral: true,
                                                    embeds: [
                                                        {
                                                            title: `${client.user.username} error`,
                                                            color: appearance.embed.errorColor,
                                                            description: `${newI.member}, голосование **уже** запущено`,
                                                            thumbnail: { url: iMemberAvatar }
                                                        }
                                                    ]
                                                }).catch(() => {});
                                    
                                                if (game.time !== 'day') 
                                                return newI.reply({
                                                    ephemeral: true,
                                                    embeds: [
                                                        {
                                                            title: `${client.user.username} error`,
                                                            color: appearance.embed.errorColor,
                                                            description: `${newI.member}, голосование можно проводить **только** днём`,
                                                            thumbnail: { url: iMemberAvatar }
                                                        }
                                                    ]
                                                }).catch(() => {});
                                    
                                                if (!game.vote.members.find(member => member.id == game.members[pickMember].id)) {
                                    
                                                    game.vote.members.push(game.members[pickMember])
                                    
                                                }
                                    
                                                else {
                                    
                                                    for (const pickMemberVote in game.vote.members) {
                                    
                                                        if (game.vote.members[pickMemberVote] && game.vote.members[pickMemberVote].id == game.members[pickMember].id) {
                                    
                                                            game.vote.members = game.vote.members.filter((n) => {return n != game.vote.members[pickMemberVote]});
                                    
                                                        };
                                    
                                                    };
                                    
                                                };
                                    
                                                newI.update(voteMessage ()).catch(() => {});
                                    
                                            });
                                    
                                            actions[`vote${game.members[pickMember].number}`] = {
                                                actions: [pickVoteutton],
                                                all: false
                                            };
                                    
                                        };
                                    
                                        return {
                                            embeds: [
                                                {
                                                    color: appearance.embed.color,
                                                    description: `# ${eventOfCategory.game.vote.emoji} ${eventOfCategory.game.vote.name}\n${exhibitedText ? `Выставлены: ${exhibitedText || 'Пусто'}` : '-# Никто не выставлен'}`,
                                                    // footer: { text: 'Выставляйте с помощью кнопок' }
                                                }
                                            ],
                                            components: componentsVote
                                        };
                                    
                                    };

                                    function punishmentMessage () {

                                        let componentsPunishment = [];
                                        componentsPunishment.push(
                                            {
                                                type: 1,
                                                components: []
                                            }
                                        );

                                        for (const pickPunishment in eventOfCategory.game.punishment) {
                                                
                                            if (!componentsPunishment[0] || componentsPunishment[componentsPunishment.length-1].components.length == 5) 
                                            componentsPunishment.push(
                                                {
                                                    type: 1,
                                                    components: []
                                                }
                                            );

                                            componentsPunishment[componentsPunishment.length-1].components.push(
                                                {
                                                    type: 2, 
                                                    style: game.punishment.pick.name == eventOfCategory.game.punishment[pickPunishment].name ? 3 : 2, 
                                                    customId: `${eventOfCategory.game.punishment[pickPunishment].name}`,
                                                    label: `${eventOfCategory.game.punishment[pickPunishment].name}`,
                                                    emoji: `${eventOfCategory.game.punishment[pickPunishment].emoji}`,
                                                    disabled: game.punishment.pick.name == eventOfCategory.game.punishment[pickPunishment].name ? true : false
                                                }
                                            );
                                            
                                            const pickPunishmentButton = (async (newI) => {
                                                
                                                if (guilds[EventId].Owner !== newI.member.id) return newI.reply(await errorNoEventsOwnerMessage (newI.member));

                                                game.punishment.pick = eventOfCategory.game.punishment[pickPunishment];
                                                newI.update(punishmentMessage ()).catch(() => {});

                                            });
        
                                            actions[`${eventOfCategory.game.punishment[pickPunishment].name}`] = {
                                                actions: [pickPunishmentButton],
                                                all: false
                                            };

                                        };
                                        
                                        componentsPunishment.push(
                                            {
                                                type: 1,
                                                components: []
                                            }
                                        );

                                        for (const pickMember in game.members) {
                                                
                                            if (!componentsPunishment[0] || componentsPunishment[componentsPunishment.length-1].components.length == 5) 
                                            componentsPunishment.push(
                                                {
                                                    type: 1,
                                                    components: []
                                                }
                                            );

                                            componentsPunishment[componentsPunishment.length-1].components.push(
                                                {
                                                    type: 2, 
                                                    style: game.members[pickMember].alive ? appearance.buttons_menu.Default.style : 4, 
                                                    customId: `punishment${game.members[pickMember].number}`,
                                                    label: `${game.members[pickMember].number}`, 
                                                    disabled: game.members[pickMember].alive ? false : true
                                                }
                                            );
                                            
                                            const pickPunishmentButton = (async (newI) => {                                                
                                                
                                                if (guilds[EventId].Owner !== newI.member.id) return newI.reply(await errorNoEventsOwnerMessage (newI.member));
                                                if (game.punishment.pick.type == 'fouls') {

                                                    const fetchPickMember = await guild.members.fetch(game.members[pickMember].id).catch(() => {});

                                                    const timePunishment = game.punishment.pick;
                                                    if (!game.members[pickMember].punishment[game.punishment.pick.name]) game.members[pickMember].punishment[game.punishment.pick.name] = 0;
                                                    game.members[pickMember].punishment[game.punishment.pick.name]++;

                                                    const memberPickPunishment = game.members[pickMember].punishment[game.punishment.pick.name];

                                                    const messageOfKick = await eventRecordChannel.send({  
                                                        content: `||${fetchPickMember}||`,
                                                        embeds: [
                                                            {
                                                                title: `Наказания: ${eventOfCategory.name}`,
                                                                color: game.punishment.pick.color,
                                                                description: `Тип: ${game.punishment.pick.emoji} **${game.punishment.pick.name}** Всего: **${memberPickPunishment}**/**${eventOfCategory.game.punishment.find(punishment => punishment.name == timePunishment.name).max}**\nПользователь: ${getNumber(game.members[pickMember].number)} ${fetchPickMember}`,
                                                                thumbnail: { url: await getAvatar(fetchPickMember) }
                                                            }
                                                        ],
                                                        components: [
                                                            {
                                                                type: 1,
                                                                components: [
                                                                    {
                                                                        type: 2, 
                                                                        style: appearance.buttons_menu.Default.style, 
                                                                        customId: 'unFouls', 
                                                                        label: 'Отменить фол'
                                                                    }
                                                                ]
                                                            }
                                                        ]
                                                    }).catch(() => {});
                                                    

                                                    if (textPunishment == '') textPunishment += `[Выданнные/отмененные наказания]\n\n[Игрок: ${game.members[pickMember].number}] Наказание: ${game.punishment.pick.name} [${memberPickPunishment} из ${eventOfCategory.game.punishment.find(punishment => punishment.name == timePunishment.name).max}]`;
                                                    else textPunishment += `\n[Игрок: ${game.members[pickMember].number}] Наказание: ${game.punishment.pick.name} [${memberPickPunishment} из ${eventOfCategory.game.punishment.find(punishment => punishment.name == timePunishment.name).max}]`;
    
                                                    const collectorConponentsOfMessageOfKick = await messageOfKick.createMessageComponentCollector();
                                                    collectorConponentsOfMessageOfKick.on('collect', async newI => {

                                                        if (newI.member.id !== guilds[EventId].Owner) return;
                            
                                                        switch (newI.customId) { 
                            
                                                            case 'unFouls': {

                                                                if (game.members[pickMember].alive !== true) 
                                                                return newI.reply({  
                                                                    ephemeral: true,
                                                                    embeds: [
                                                                        {
                                                                            title: `${client.user.username + ' error'}`,
                                                                            color: appearance.embed.errorColor,
                                                                            description: `${newI.member}, ${fetchPickMember} **отсутствует** за столом`,
                                                                            thumbnail: { url: await getAvatar(fetchPickMember) }
                                                                        }
                                                                    ],
                                                                    components: [
                                                                        
                                                                    ]
                                                                }).catch(() => {});

                                                                game.members[pickMember].punishment[timePunishment.name]--;

                                                                let nick = game.members[pickMember].number;
                                                                let nickPS = '';

                                                                let punishments = 0;
                                                                for (const pickPunishment in game.members[pickMember].punishment) if (game.members[pickMember].punishment[pickPunishment] !== 0) punishments++;
                                                                for (const pickPunishment in game.members[pickMember].punishment) {

                                                                    if (game.members[pickMember].punishment[pickPunishment] < 0) game.members[pickMember].punishment[pickPunishment] = 0;
                                                                    while (game.members[pickMember].punishment[pickPunishment] >= eventOfCategory.game.punishment.find(punishment => punishment.name == pickPunishment).max) game.members[pickMember].punishment[pickPunishment]--;

                                                                    if (game.members[pickMember].punishment[pickPunishment] !== 0) {

                                                                        if (nickPS !== '') nickPS += '; ';
                                                                        nickPS += punishments > 1 ? eventOfCategory.game.punishment.find(punishment => punishment.name == pickPunishment).ps.mini : eventOfCategory.game.punishment.find(punishment => punishment.name == pickPunishment).ps.full;
                                                                        nickPS += `: ${game.members[pickMember].punishment[pickPunishment]}/${eventOfCategory.game.punishment.find(punishment => punishment.name == pickPunishment).max}`;
            
                                                                    };

                                                                };

                                                                if (nickPS !== '') nick += ` [${nickPS}]`;
                                                                if (fetchPickMember) fetchPickMember.setNickname(nick).catch(() => {});

                                                                newI.update({  
                                                                    content: ` `,
                                                                    embeds: [
                                                                        {
                                                                            title: `Наказания: ${eventOfCategory.name}`,
                                                                            color: appearance.embed.color,
                                                                            description: `Тип: ${timePunishment.emoji} **${timePunishment.name}** Всего: **${memberPickPunishment}**/**${eventOfCategory.game.punishment.find(punishment => punishment.name == timePunishment.name).max}**\nПользователь: ${getNumber(game.members[pickMember].number)} ${fetchPickMember}\n-# Наказание отменено`,
                                                                            thumbnail: { url: await getAvatar(fetchPickMember) }
                                                                        }
                                                                    ],
                                                                    components: [
                                                                        
                                                                    ]
                                                                }).catch(() => {});
                                                                
                                                                if (textPunishment == '') textPunishment += `[Выданнные/отмененные наказания]\n\n[Игрок: ${game.members[pickMember].number}] [ОТМЕНЕННОЕ] Наказание: ${timePunishment.name}`;
                                                                else textPunishment += `\n[Игрок: ${game.members[pickMember].number}] [ОТМЕНЕННОЕ] Наказание: ${timePunishment.name}`;
    
                                                                    
                                                                game.message.punishment.edit(punishmentMessage ()).catch(() => {});
                            
                                                            }
                                                        
                                                        };
                            
                                                    });

                                                }

                                                else if (game.punishment.pick.type == 'warning') {

                                                    const fetchPickMember = await guild.members.fetch(game.members[pickMember].id).catch(() => {});

                                                    const timePunishment = game.punishment.pick;
                                                    if (!game.members[pickMember].punishment[game.punishment.pick.name]) game.members[pickMember].punishment[game.punishment.pick.name] = 0;
                                                    game.members[pickMember].punishment[game.punishment.pick.name]++;

                                                    const memberPickPunishment = game.members[pickMember].punishment[game.punishment.pick.name];

                                                    const messageOfKick = await eventRecordChannel.send({  
                                                        content: `||${fetchPickMember}||`,
                                                        embeds: [
                                                            {
                                                                title: `Наказания: ${eventOfCategory.name}`,
                                                                color: game.punishment.pick.color,
                                                                description: `Тип: ${game.punishment.pick.emoji} **${game.punishment.pick.name}** Всего: **${memberPickPunishment}**/**${eventOfCategory.game.punishment.find(punishment => punishment.name == timePunishment.name).max}**\nПользователь: ${getNumber(game.members[pickMember].number)} ${fetchPickMember}`,
                                                                thumbnail: { url: await getAvatar(fetchPickMember) }
                                                            }
                                                        ],
                                                        components: [
                                                            {
                                                                type: 1,
                                                                components: [
                                                                    {
                                                                        type: 2, 
                                                                        style: 2, 
                                                                        customId: 'unWarn', 
                                                                        label: 'Отменить предупреждение'
                                                                    }
                                                                ]
                                                            }
                                                        ]
                                                    }).catch(() => {});

                                                    if (textPunishment == '') textPunishment += `[Выданнные/отмененные наказания]\n\n[Игрок: ${game.members[pickMember].number}] Наказание: ${game.punishment.pick.name} [${memberPickPunishment }из ${eventOfCategory.game.punishment.find(punishment => punishment.name == timePunishment.name).max}]`;
                                                    else textPunishment += `\n[Игрок: ${game.members[pickMember].number}] Наказание: ${game.punishment.pick.name} [${memberPickPunishment }из ${eventOfCategory.game.punishment.find(punishment => punishment.name == timePunishment.name).max}]`;
    
                                                    const collectorConponentsOfMessageOfKick = await messageOfKick.createMessageComponentCollector();
                                                    collectorConponentsOfMessageOfKick.on('collect', async newI => {
                                                        
                                                        if (newI.member.id !== guilds[EventId].Owner) return;
                            
                                                        switch (newI.customId) { 
                            
                                                            case 'unWarn': {

                                                                if (game.members[pickMember].alive !== true) 
                                                                return newI.reply({  
                                                                    ephemeral: true,
                                                                    embeds: [
                                                                        {
                                                                            title: `${client.user.username + ' error'}`,
                                                                            color: appearance.embed.errorColor,
                                                                            description: `${newI.member}, ${fetchPickMember} **отсутствует** за столом`,
                                                                            thumbnail: { url: await getAvatar(fetchPickMember) }
                                                                        }
                                                                    ],
                                                                    components: [
                                                                        
                                                                    ]
                                                                }).catch(() => {});

                                                                game.members[pickMember].punishment[timePunishment.name]--;

                                                                let nick = game.members[pickMember].number;
                                                                let nickPS = '';

                                                                let punishments = 0;
                                                                for (const pickPunishment in game.members[pickMember].punishment) if (game.members[pickMember].punishment[pickPunishment] !== 0) punishments++;
                                                                for (const pickPunishment in game.members[pickMember].punishment) {

                                                                    if (game.members[pickMember].punishment[pickPunishment] < 0) game.members[pickMember].punishment[pickPunishment] = 0;
                                                                    while (game.members[pickMember].punishment[pickPunishment] >= eventOfCategory.game.punishment.find(punishment => punishment.name == pickPunishment).max) game.members[pickMember].punishment[pickPunishment]--;

                                                                    if (game.members[pickMember].punishment[pickPunishment] !== 0) {

                                                                        if (nickPS !== '') nickPS += '; ';
                                                                        nickPS += punishments > 1 ? eventOfCategory.game.punishment.find(punishment => punishment.name == pickPunishment).ps.mini : eventOfCategory.game.punishment.find(punishment => punishment.name == pickPunishment).ps.full;
                                                                        nickPS += `: ${game.members[pickMember].punishment[pickPunishment]}/${eventOfCategory.game.punishment.find(punishment => punishment.name == pickPunishment).max}`;
            
                                                                    };

                                                                };

                                                                if (nickPS !== '') nick += ` [${nickPS}]`;
                                                                if (fetchPickMember) fetchPickMember.setNickname(nick).catch(() => {});

                                                                newI.update({  
                                                                    content: ` `,
                                                                    embeds: [
                                                                        {
                                                                            title: `Наказания: ${eventOfCategory.name}`,
                                                                            color: appearance.embed.color,
                                                                            description: `Тип: ${timePunishment.emoji} **${timePunishment.name}** Всего: **${memberPickPunishment}**/**${eventOfCategory.game.punishment.find(punishment => punishment.name == timePunishment.name).max}**\nПользователь: ${getNumber(game.members[pickMember].number)} ${fetchPickMember}\n-# Наказание отменено`,
                                                                            thumbnail: { url: await getAvatar(fetchPickMember) }
                                                                        }
                                                                    ],
                                                                    components: [
                                                                        
                                                                    ]
                                                                }).catch(() => {});
                                                                
                                                                if (textPunishment == '') textPunishment += `[Выданнные/отмененные наказания]\n\n[Игрок: ${game.members[pickMember].number}] [ОТМЕНЕННОЕ] Наказание: ${timePunishment.name}`;
                                                                else textPunishment += `\n[Игрок: ${game.members[pickMember].number}] [ОТМЕНЕННОЕ] Наказание: ${timePunishment.name}`;
                                                                    
                                                                game.message.punishment.edit(punishmentMessage ()).catch(() => {});
                            
                                                            }
                                                        
                                                        };
                            
                                                    });

                                                }

                                                else if (game.punishment.pick.type == 'kick') {

                                                    const fetchPickMember = await guild.members.fetch(game.members[pickMember].id).catch(() => {});
    
                                                    game.members[pickMember].alive = false;
                                                    const timePunishment = game.punishment.pick;
                                                    if (fetchPickMember) fetchPickMember.setNickname(game.members[pickMember].nickName).catch(() => {});
                                                    for (n=0; n < game.servers.length; n++) {

                                                        game.servers[n].guild.members.fetch().catch(() => {});
                                                        const fetchPickMemberOfPickServer = await game.servers[n].guild.members.fetch(fetchPickMember.id).catch(() => {});

                                                        if (fetchPickMemberOfPickServer) fetchPickMemberOfPickServer.kick().catch(() => {});

                                                    };

                                                    const messageOfKick = await eventRecordChannel.send({  
                                                        content: `||${fetchPickMember}||`,
                                                        embeds: [
                                                            {
                                                                title: `Наказания: ${eventOfCategory.name}`,
                                                                color: game.punishment.pick.color,
                                                                description: `Тип: ${game.punishment.pick.emoji} **${game.punishment.pick.name}**\nПользователь: ${getNumber(game.members[pickMember].number)} ${fetchPickMember}`,
                                                                thumbnail: { url: await getAvatar(fetchPickMember) }
                                                            }
                                                        ],
                                                        components: [
                                                            {
                                                                type: 1,
                                                                components: [
                                                                    {
                                                                        type: 2, 
                                                                        style: 4, 
                                                                        customId: 'unKick', 
                                                                        label: 'Вернуть в игру'
                                                                    }
                                                                ]
                                                            }
                                                        ]
                                                    }).catch(() => {});
                                                    
                                                    if (textPunishment == '') textPunishment += `[Выданнные/отмененные наказания]\n\n[Игрок: ${game.members[pickMember].number}] Наказание: ${game.punishment.pick.name}`;
                                                    else textPunishment += `\n[Игрок: ${game.members[pickMember].number}] Наказание: ${game.punishment.pick.name}`;

                                                    
                                                    eventVoiceChannel.permissionOverwrites.edit(fetchPickMember.id, { Speak: false }).catch(() => {});
                                                    eventRecordChannel.permissionOverwrites.edit(fetchPickMember.id, { SendMessages: false }).catch(() => {});
                                                    fetchPickMember.voice.setChannel(eventVoiceChannel.id).catch(() => {});
    
                                                    const collectorConponentsOfMessageOfKick = await messageOfKick.createMessageComponentCollector();
                                                    collectorConponentsOfMessageOfKick.on('collect', async newI => {
                                                        
                                                        if (newI.member.id !== guilds[EventId].Owner) return;
                            
                                                        switch (newI.customId) { 
                            
                                                            case 'unKick': {

                                                                game.members[pickMember].alive = true;

                                                                let nick = game.members[pickMember].number;
                                                                let nickPS = '';

                                                                let punishments = 0;
                                                                for (const pickPunishment in game.members[pickMember].punishment) if (game.members[pickMember].punishment[pickPunishment] !== 0) punishments++;
                                                                for (const pickPunishment in game.members[pickMember].punishment) {

                                                                    if (game.members[pickMember].punishment[pickPunishment] < 0) game.members[pickMember].punishment[pickPunishment] = 0;
                                                                    while (game.members[pickMember].punishment[pickPunishment] >= eventOfCategory.game.punishment.find(punishment => punishment.name == pickPunishment).max) game.members[pickMember].punishment[pickPunishment]--;

                                                                    if (game.members[pickMember].punishment[pickPunishment] !== 0) {

                                                                        if (nickPS !== '') nickPS += '; ';
                                                                        nickPS += punishments > 1 ? eventOfCategory.game.punishment.find(punishment => punishment.name == pickPunishment).ps.mini : eventOfCategory.game.punishment.find(punishment => punishment.name == pickPunishment).ps.full;
                                                                        nickPS += `: ${game.members[pickMember].punishment[pickPunishment]}/${eventOfCategory.game.punishment.find(punishment => punishment.name == pickPunishment).max}`;
            
                                                                    };

                                                                };

                                                                if (nickPS !== '') nick += ` [${nickPS}]`;
                                                                if (fetchPickMember) fetchPickMember.setNickname(nick).catch(() => {});

                                                                newI.update({  
                                                                    content: ` `,
                                                                    embeds: [
                                                                        {
                                                                            title: `Наказания: ${eventOfCategory.name}`,
                                                                            color: appearance.embed.color,
                                                                            description: `Тип: ${timePunishment.emoji} **${timePunishment.name}**\nПользователь: ${getNumber(game.members[pickMember].number)} ${fetchPickMember}\n-# Наказание отменено`,
                                                                            thumbnail: { url: await getAvatar(fetchPickMember) }
                                                                        }
                                                                    ],
                                                                    components: [
                                                                        
                                                                    ]
                                                                }).catch(() => {});

                                                                if (game.time == 'day') {

                                                                    eventVoiceChannel.permissionOverwrites.edit(fetchPickMember.id, { Speak: true }).catch(() => {});
                                                                    eventRecordChannel.permissionOverwrites.edit(fetchPickMember.id, { SendMessages: true }).catch(() => {});
                                                                    fetchPickMember.voice.setChannel(eventVoiceChannel.id).catch(() => {});

                                                                };
                                                                
                                                                if (textPunishment == '') textPunishment += `[Выданнные/отмененные наказания]\n\n[Игрок: ${game.members[pickMember].number}] [ОТМЕНЕННОЕ] Наказание: ${timePunishment.name}`;
                                                                else textPunishment += `\n[Игрок: ${game.members[pickMember].number}] [ОТМЕНЕННОЕ] Наказание: ${timePunishment.name}`;
                                                                    
                                                                game.message.punishment.edit(punishmentMessage ()).catch(() => {});
                                                                if (game.message.vote) game.message.vote.edit(voteMessage ()).catch(() => {});
                            
                                                            }
                                                        
                                                        };
                            
                                                    });

                                                    newI.update(punishmentMessage ()).catch(() => {});
                                                    if (game.message.vote) game.message.vote.edit(voteMessage ()).catch(() => {});

                                                    return;

                                                };

                                                for (const pickPunishment in game.members[pickMember].punishment) {

                                                    if (game.members[pickMember].punishment[pickPunishment] >= eventOfCategory.game.punishment.find(punishment => punishment.name == pickPunishment).max) {

                                                        const fetchPickMember = await guild.members.fetch(game.members[pickMember].id).catch(() => {});
        
                                                        game.members[pickMember].alive = false;
                                                        const timePunishment = game.punishment.pick.name;
                                                        if (fetchPickMember) fetchPickMember.setNickname(game.members[pickMember].nickName).catch(() => {});
                                                        for (n=0; n < game.servers.length; n++) {

                                                            game.servers[n].guild.members.fetch().catch(() => {});
                                                            const fetchPickMemberOfPickServer = await game.servers[n].guild.members.fetch(fetchPickMember.id).catch(() => {});

                                                            if (fetchPickMemberOfPickServer) fetchPickMemberOfPickServer.kick().catch(() => {});

                                                        };

                                                        const messageOfKick = await eventRecordChannel.send({  
                                                            content: `||${fetchPickMember}||`,
                                                            embeds: [
                                                                {
                                                                    title: `Наказания: ${eventOfCategory.name}`,
                                                                    color: eventOfCategory.game.actions['kill'].color,
                                                                    description: `Тип: Максимальное кол-во ${eventOfCategory.game.punishment.find(punishment => punishment.name == pickPunishment).emoji} **${eventOfCategory.game.punishment.find(punishment => punishment.name == pickPunishment).name}**\nПользователь: ${getNumber(game.members[pickMember].number)} ${fetchPickMember}`,
                                                                    thumbnail: { url: await getAvatar(fetchPickMember) }
                                                                }
                                                            ],
                                                            components: [
                                                                {
                                                                    type: 1,
                                                                    components: [
                                                                        {
                                                                            type: 2, 
                                                                            style: 4, 
                                                                            customId: 'unKick', 
                                                                            label: 'Вернуть в игру'
                                                                        }
                                                                    ]
                                                                }
                                                            ]
                                                        }).catch(() => {});

                                                        if (textPunishment == '') textPunishment += `[Выданнные/отмененные наказания]\n\n[Игрок: ${game.members[pickMember].number}] [АВТОМАТИЧЕСКИ] Наказание: ${game.punishment.pick.name} -> Поднятие (Максимальное количество)`;
                                                        else textPunishment += `\n[Игрок: ${game.members[pickMember].number}] [АВТОМАТИЧЕСКИ] Наказание: ${game.punishment.pick.name} -> Поднятие (Максимальное количество)`;

                                                        eventVoiceChannel.permissionOverwrites.edit(fetchPickMember.id, { Speak: false }).catch(() => {});
                                                        eventRecordChannel.permissionOverwrites.edit(fetchPickMember.id, { SendMessages: false }).catch(() => {});
                                                        fetchPickMember.voice.setChannel(eventVoiceChannel.id).catch(() => {});
    
                                                        const collectorConponentsOfMessageOfKick = await messageOfKick.createMessageComponentCollector();
                                                        collectorConponentsOfMessageOfKick.on('collect', async newI => {
                                                        
                                                            if (newI.member.id !== guilds[EventId].Owner) return;
                                
                                                            switch (newI.customId) { 
                                
                                                                case 'unKick': {

                                                                    game.members[pickMember].alive = true;

                                                                    let nick = game.members[pickMember].number;
                                                                    let nickPS = '';

                                                                    let punishments = 0;
                                                                    for (const pickPunishment in game.members[pickMember].punishment) if (game.members[pickMember].punishment[pickPunishment] !== 0) punishments++;
                                                                    for (const pickPunishment in game.members[pickMember].punishment) {

                                                                        if (game.members[pickMember].punishment[pickPunishment] < 0) game.members[pickMember].punishment[pickPunishment] = 0;
                                                                        while (game.members[pickMember].punishment[pickPunishment] >= eventOfCategory.game.punishment.find(punishment => punishment.name == pickPunishment).max) game.members[pickMember].punishment[pickPunishment]--;

                                                                        if (game.members[pickMember].punishment[pickPunishment] !== 0) {

                                                                            if (nickPS !== '') nickPS += '; ';
                                                                            nickPS += punishments > 1 ? eventOfCategory.game.punishment.find(punishment => punishment.name == pickPunishment).ps.mini : eventOfCategory.game.punishment.find(punishment => punishment.name == pickPunishment).ps.full;
                                                                            nickPS += `: ${game.members[pickMember].punishment[pickPunishment]}/${eventOfCategory.game.punishment.find(punishment => punishment.name == pickPunishment).max}`;
                
                                                                        };

                                                                    };

                                                                    if (nickPS !== '') nick += ` [${nickPS}]`;
                                                                    if (fetchPickMember) fetchPickMember.setNickname(nick).catch(() => {});

                                                                    newI.update({  
                                                                        content: ` `,
                                                                        embeds: [
                                                                            {
                                                                                title: `Наказания: ${eventOfCategory.name}`,
                                                                                color: appearance.embed.color,
                                                                                description: `Тип: Максимальное кол-во ${eventOfCategory.game.punishment.find(punishment => punishment.name == pickPunishment).emoji} **${eventOfCategory.game.punishment.find(punishment => punishment.name == pickPunishment).name}**\nПользователь: ${getNumber(game.members[pickMember].number)} ${fetchPickMember}\n-# Наказание отменено`,
                                                                                thumbnail: { url: await getAvatar(fetchPickMember) }
                                                                            }
                                                                        ],
                                                                        components: [
                                                                            
                                                                        ]
                                                                    }).catch(() => {});

                                                                    if (game.time == 'day') {

                                                                        eventVoiceChannel.permissionOverwrites.edit(fetchPickMember.id, { Speak: true }).catch(() => {});
                                                                        eventRecordChannel.permissionOverwrites.edit(fetchPickMember.id, { SendMessages: true }).catch(() => {});
                                                                        fetchPickMember.voice.setChannel(eventVoiceChannel.id).catch(() => {});

                                                                    };
                                                                
                                                                    if (textPunishment == '') textPunishment += `[Выданнные/отмененные наказания]\n\n[Игрок: ${game.members[pickMember].number}] [ОТМЕНЕННОЕ] Наказание: ${timePunishment.name} -> Поднятие (Максимальное количество)`;
                                                                    else textPunishment += `\n[Игрок: ${game.members[pickMember].number}] [ОТМЕНЕННОЕ] Наказание: ${timePunishment.name} -> Поднятие (Максимальное количество)`;
                                                                    
                                                                    game.message.punishment.edit(punishmentMessage ()).catch(() => {});
                                                                    if (game.message.vote) game.message.vote.edit(voteMessage ()).catch(() => {});
                                
                                                                }
                                                            
                                                            };
                                
                                                        });

                                                        newI.update(punishmentMessage ()).catch(() => {});
                                                        if (game.message.vote) game.message.vote.edit(voteMessage ()).catch(() => {});
                                                        
                                                        return;

                                                    };

                                                };

                                                const fetchPickMember = await guild.members.fetch(game.members[pickMember].id).catch(() => {});

                                                let nick = game.members[pickMember].number;
                                                let nickPS = '';

                                                let punishments = 0;
                                                for (const pickPunishment in game.members[pickMember].punishment) if (game.members[pickMember].punishment[pickPunishment] !== 0) punishments++;
                                                for (const pickPunishment in game.members[pickMember].punishment) {

                                                    if (game.members[pickMember].punishment[pickPunishment] < 0) game.members[pickMember].punishment[pickPunishment] = 0;
                                                    while (game.members[pickMember].punishment[pickPunishment] >= eventOfCategory.game.punishment.find(punishment => punishment.name == pickPunishment).max) game.members[pickMember].punishment[pickPunishment]--;

                                                    if (game.members[pickMember].punishment[pickPunishment] !== 0) {

                                                        if (nickPS !== '') nickPS += '; ';
                                                        nickPS += punishments > 1 ? eventOfCategory.game.punishment.find(punishment => punishment.name == pickPunishment).ps.mini : eventOfCategory.game.punishment.find(punishment => punishment.name == pickPunishment).ps.full;
                                                        nickPS += `: ${game.members[pickMember].punishment[pickPunishment]}/${eventOfCategory.game.punishment.find(punishment => punishment.name == pickPunishment).max}`;

                                                    };

                                                };

                                                if (nickPS !== '') nick += ` [${nickPS}]`;
                                                if (fetchPickMember) fetchPickMember.setNickname(nick).catch(() => {});
                                                
                                                newI.update(punishmentMessage ()).catch(() => {});

                                            });
        
                                            actions[`punishment${game.members[pickMember].number}`] = {
                                                actions: [pickPunishmentButton],
                                                all: false
                                            };

                                        };

                                        return {
                                            embeds: [
                                                {
                                                    color: appearance.embed.color,
                                                    description: `# ${game.punishment.pick.emoji} ${game.punishment.pick.name}\n-# Переключайте меню с помощью кнопок`
                                                }
                                            ],
                                            components: componentsPunishment
                                        };

                                    };
                                    
                                    
                                    async function getTimers () {

                                        const timer = (async (newI) => {
                                            newI.reply({
                                                ephemeral: true,
                                                embeds: [
                                                    {
                                                        color: appearance.embed.color,
                                                        description: `# ⏱️ Таймер речей\n-# Выберите время в меню ниже`
                                                    }
                                                ],
                                                components: [
                                                    {
                                                        type: 1,
                                                        components: [
                                                            {
                                                                type: 2, 
                                                                style: 2, 
                                                                label: '30 секунд',
                                                                customId: 'timer30sec'
                                                            },
                                                            {
                                                                type: 2, 
                                                                style: 2, 
                                                                label: '60 секунд',
                                                                customId: 'timer60sec'
                                                            },
                                                            {
                                                                type: 2, 
                                                                style: 2, 
                                                                label: '1 минута 30 секунд',
                                                                customId: 'timer90sec'
                                                            }
                                                        ]
                                                    }
                                                ]
                                            }).catch(() => {});
                                        });
                                    
                                        actions['timer'] = {
                                            actions: [timer],
                                            all: false
                                        };
    
    
                                        const timer30sec = (async (newI) => {
                                            newI.reply({
                                                ephemeral: true,
                                                content: `# <t:${Math.floor(Date.now()/1000 + 30)}:R>\n-# Таймер на **30** секунд от <t:${Math.floor(Date.now()/1000)}:f>`
                                            }).catch(() => {});
                                        });
                                    
                                        actions['timer30sec'] = {
                                            actions: [timer30sec],
                                            all: false
                                        };
                                        
    
                                        const timer60sec = (async (newI) => {
                                            newI.reply({
                                                ephemeral: true,
                                                content: `# <t:${Math.floor(Date.now()/1000 + 60)}:R>\n-# Таймер на **60** секунд от <t:${Math.floor(Date.now()/1000)}:f>`
                                            }).catch(() => {});
                                        });
                                    
                                        actions['timer60sec'] = {
                                            actions: [timer60sec],
                                            all: false
                                        };
                                        
    
                                        const timer90sec = (async (newI) => {
                                            newI.reply({
                                                ephemeral: true,
                                                content: `# <t:${Math.floor(Date.now()/1000 + 90)}:R>\n-# Таймер на **90** секунд от <t:${Math.floor(Date.now()/1000)}:f>`
                                            }).catch(() => {});
                                        });
                                    
                                        actions['timer90sec'] = {
                                            actions: [timer90sec],
                                            all: false
                                        };
                                    
                                    };

                                    await getTimers ();


                                    guilds[EventId].started = true;
                                    guilds[EventId].game = game;

                                    for (const pickMember in game.members) {

                                        if (game.members[pickMember].alive) {

                                            const fetchPickMember = await guild.members.fetch(game.members[pickMember].id).catch(() => {});

                                            if (fetchPickMember) {

                                                eventVoiceChannel.permissionOverwrites.edit(fetchPickMember.id, { Speak: false })
                                                    .then(() => {
                                                        fetchPickMember.voice.setChannel(eventVoiceChannel.id).catch(() => {});
                                                    })
                                                    .catch(() => {});
                                                eventRecordChannel.permissionOverwrites.edit(fetchPickMember.id, { SendMessages: false }).catch(() => {});

                                            };

                                        };

                                    };

                                    const startGameInterval = setInterval(async () => {     

                                        game.ready = true;
                                        let rolesNoConfirmation = [];
                                        let membersNoConfirmation = [];
                                        

                                        let contentOfMessageLeading = '';
                                        for (const pickMember in game.members) {

                                            let confirmation = false;
                                            let confirmationOfRole = false;
                                            const pickMemberOfGameMembers = game.members[pickMember];
                                            const fetchPickMember = await guild.members.fetch(pickMemberOfGameMembers.id).catch(() => {});

                                            if (pickMemberOfGameMembers.role.confirmation) {

                                                confirmationOfRole = true;

                                                if (pickMemberOfGameMembers.confirmation) contentOfMessageLeading += appearance.emoji.Confirmation + ' ';

                                                else {

                                                    game.ready = false;
                                                    confirmation = true;

                                                    if (!membersNoConfirmation.includes(fetchPickMember.id)) membersNoConfirmation.push(fetchPickMember.id);
                                                    contentOfMessageLeading += appearance.emoji.NoConfirmation + ' ';

                                                };

    
                                            };
    
                                            if (pickMemberOfGameMembers.role.servers[0]) {

                                                confirmationOfRole = true;
    
                                                for (i=0; i < pickMemberOfGameMembers.role.servers.length; i++) {

                                                    if (pickMemberOfGameMembers.role.servers[i].join) {
        
                                                        for (n=0; n < game.servers.length; n++) {

                                                            game.servers[n].guild.members.fetch().catch(() => {});
                                                            const fetchPickMemberOfPickServer = await game.servers[n].guild.members.fetch(fetchPickMember.id).catch(() => {});

                                                            if (fetchPickMemberOfPickServer) contentOfMessageLeading += appearance.emoji.Confirmation + ' ';

                                                            else {
            
                                                                game.ready = false;
                                                                confirmation = true;

                                                                if (!membersNoConfirmation.includes(fetchPickMember.id)) membersNoConfirmation.push(fetchPickMember.id);
                                                                contentOfMessageLeading += appearance.emoji.NoConfirmation + ' ';
            
                                                            };

                                                        };
            
                                                    };
    
                                                };
    
                                            };

                                            if (confirmation && !rolesNoConfirmation.includes(`${pickMemberOfGameMembers.role.emoji} **${pickMemberOfGameMembers.role.name}**`)) rolesNoConfirmation.push(`${pickMemberOfGameMembers.role.emoji} **${pickMemberOfGameMembers.role.name}**`);

                                            if (!confirmationOfRole) contentOfMessageLeading += appearance.emoji.Null + ' ';
                                            contentOfMessageLeading += `${getNumber (pickMemberOfGameMembers.number)} ${pickMemberOfGameMembers.role.emoji} ${fetchPickMember}\n`;
                                            
                                        };


                                        if (guilds[EventId].deleted) {

                                            if (game.message.roles.id) game.message.roles.edit({  
                                                embeds: [   
                                                    {
                                                        title: `Роли: ${eventOfCategory.name}`,
                                                        color: appearance.embed.color,
                                                        description: `${contentOfMessageLeading}`
                                                    }
                                                ]
                                            }).catch(() => {});
                                            
                                            return clearInterval(startGameInterval);

                                        };

                                        if (Date.now() / 1000 - timeStart > examinationTimeConfirmation && !game.ready) {

                                            guilds[EventId].deleted = true;
                                            eventOwner = await guild.members.fetch(guilds[EventId].Owner).catch(() => {});

                                            
                                            let textMembersNoConfirmation = '';
                                            for (let i = 0; i < membersNoConfirmation.length; i++) {

                                                const fetchPickMember = await guild.members.fetch(membersNoConfirmation[i]).catch(() => {});
                                                fetchPickMember.roles.add(appearance.roles.Mafia.ban).catch(() => {});

                                                if (textMembersNoConfirmation !== '') textMembersNoConfirmation += `, ${fetchPickMember}`;
                                                    else textMembersNoConfirmation += `${fetchPickMember}`;


                                                fetchPickMember.send({
                                                    content: `<t:${Math.floor(Date.now()/1000)}:f>`,
                                                    embeds: [
                                                        {
                                                            author: { name: 'Выдача наказания' },
                                                            title: `${client.user.username} logs`,
                                                            color: appearance.embed.color,
                                                            fields: [
                                                                {
                                                                    name: `${appearance.embed.dot || appearance.emoji.Dot}Отстранение:`,
                                                                    value: `・**${appearance.custom.Events.punishment[appearance.roles.Mafia.ban].name}**\n・ID: ${appearance.roles.Mafia.ban}`,  
                                                                    inline: true
                                                                },
                                                                {
                                                                    name: `${appearance.embed.dot || appearance.emoji.Dot}Модератор:`,
                                                                    value: `・${client.user}\n・${client.user.id}`,  
                                                                    inline: true
                                                                },
                                                                {
                                                                    name: `${appearance.embed.dot || appearance.emoji.Dot}Причина:`,
                                                                    value: `\`\`\`Неподтверждение активной роли\`\`\``,  
                                                                    inline: false
                                                                },
                                                                {
                                                                    name: `${appearance.embed.dot || appearance.emoji.Dot}Длительность:`,
                                                                    value: `\`\`\`${hourTranslator(12*60*60)}\`\`\``,  
                                                                    inline: true
                                                                },
                                                                {
                                                                    name: `${appearance.embed.dot || appearance.emoji.Dot}Истекает:`,
                                                                    value: `・<t:${Math.floor(Date.now()/1000 + 12*60*60)}:F>`,  
                                                                    inline: true
                                                                }
                                                            ]
                                                        }
                                                    ], 
                                                    components: [
                                                        
                                                    ]
                                                }).catch(() => {});
                            
                                                const logPunishmentsEvents = await guild.channels.fetch(appearance.channels.Events.punishments);
                                                const msgLog = await logPunishmentsEvents.send({
                                                    content: `<t:${Math.floor(Date.now()/1000)}:f>`,
                                                    embeds: [
                                                        {
                                                            author: { name: 'Выдача наказания' },
                                                            title: `${client.user.username} logs`,
                                                            color: appearance.embed.color,
                                                            fields: [
                                                                {
                                                                    name: `${appearance.embed.dot || appearance.emoji.Dot}Отстранение:`,
                                                                    value: `・**${appearance.custom.Events.punishment[appearance.roles.Mafia.ban].name}**\n・ID: ${appearance.roles.Mafia.ban}`,  
                                                                    inline: false
                                                                },
                                                                {
                                                                    name: `${appearance.embed.dot || appearance.emoji.Dot}Пользователь:`,
                                                                    value: `・${fetchPickMember}\n・${fetchPickMember.id}`,  
                                                                    inline: true
                                                                },
                                                                {
                                                                    name: `${appearance.embed.dot || appearance.emoji.Dot}Модератор:`,
                                                                    value: `・${client.user}\n・${client.user.id}`,  
                                                                    inline: true
                                                                },
                                                                {
                                                                    name: `${appearance.embed.dot || appearance.emoji.Dot}Причина:`,
                                                                    value: `\`\`\`Неподтверждение активной роли\`\`\``,  
                                                                    inline: false
                                                                },
                                                                {
                                                                    name: `${appearance.embed.dot || appearance.emoji.Dot}Длительность:`,
                                                                    value: `\`\`\`${hourTranslator(12*60*60)}\`\`\``,  
                                                                    inline: true
                                                                },
                                                                {
                                                                    name: `${appearance.embed.dot || appearance.emoji.Dot}Истекает:`,
                                                                    value: `・<t:${Math.floor(Date.now()/1000 + 12*60*60)}:F>`,  
                                                                    inline: true
                                                                }
                                                            ]
                                                        }
                                                    ], 
                                                    components: [
                                                        
                                                    ]
                                                }).catch(() => {});
                                                
                            
                                                const punishmentsId = makeid(10);
                                                if (!guilds[guild.id].Punishments) guilds[guild.id].Punishments = [];

                                                guilds[guild.id].Punishments.push(
                                                    {
                                                        punishmentsId: punishmentsId,
                                                        id: fetchPickMember.id,
                                                        moderator: client.user.id,
                                                        dateRemove: Math.floor(Date.now()/1000 + 12*60*60),
                                                        duration: Math.floor(12*60*60),
                                                        date: Math.floor(Date.now()/1000),
                                                        reson: 'Неподтверждение активной роли',
                                                        punishment: appearance.roles.Mafia.ban,
                                                        logsMessage: {
                                                            channel: msgLog ? msgLog.channel.id : false,
                                                            message: msgLog ? msgLog.id : false
                                                        }
                                                    }
                                                );

                                                stats[fetchPickMember.id].Punishments.push(
                                                    {
                                                        punishmentsId: punishmentsId,
                                                        moderator: client.user.id,
                                                        dateRemove: Math.floor(Date.now()/1000 + 12*60*60),
                                                        duration: Math.floor(12*60*60),
                                                        date: Math.floor(Date.now()/1000),
                                                        reson: 'Неподтверждение активной роли',
                                                        punishment: appearance.roles.Mafia.ban,
                                                    }
                                                );

                                            };


                                            clearInterval(startGameInterval);
                                            manageMessage.delete().catch(() => {});

                                            eventOwner.setNickname('').catch(() => {});
                                            for (const pickMember in game.members) {

                                                const fetchPickMember = await guild.members.fetch(game.members[pickMember].id).catch(() => {});
                                                if (fetchPickMember) fetchPickMember.setNickname(game.members[pickMember].nickName).catch(() => {});

                                            };
    
                                            eventVoiceChannel.members.forEach(member => {

                                                member.voice.setChannel(appearance.channels.Mafia.Discussion).catch(() => {});
    
                                            });

                                            let pick = 0;
                                            let channelsEvent = [eventVoiceChannel, eventRecordChannel, eventManageChannel, eventCategory];
                                            let ti1 = setInterval(async () => {

                                                if (eventVoiceChannel && !eventVoiceChannel.members || eventVoiceChannel && !eventVoiceChannel.members.size) {

                                                    if (pick == channelsEvent.length) return clearInterval(ti1);
                                                    channelsEvent[pick].delete().catch(() => {});
                                                    pick++;

                                                };
    
                                            }, 1000);
    
                                            for (n=0; n < game.servers.length; n++) game.servers[n].guild.delete().catch(() => {});
    
                                            logMessage.edit({  
                                                content: `<t:${Math.floor(Date.now()/1000)}:f>`,
                                                embeds: [
                                                    {
                                                        author: { name: 'Мероприятие отменено' },
                                                        title: `${client.user.username + ' logs'}`,
                                                        color: appearance.embed.color,
                                                        description: `Создано: <t:${Math.floor(guilds[EventId].Created)}:f>\nЗавершено: <t:${Math.floor(Date.now()/1000)}:f>`,
                                                        fields: [
                                                            {
                                                                name: `${appearance.embed.dot || appearance.emoji.Dot}Создавал:`,
                                                                value: `・${member}\n・${member.id}`,  
                                                                inline: true
                                                            },
                                                            {
                                                                name: `${appearance.embed.dot || appearance.emoji.Dot}Мероприятие:`,
                                                                value: `\`\`\`${eventOfCategory.name}\`\`\``,
                                                                inline: true
                                                            },
                                                            {
                                                                name: `${appearance.embed.dot || appearance.emoji.Dot}Причина:`,
                                                                value: `\`\`\`Игра не принята\`\`\``,
                                                                inline: false
                                                            }
                                                        ],
                                                        footer: { text: `・Ведущий: ${member.displayName}` },
                                                        thumbnail: { url: memberAvatar },
                                                    }
                                                ],
                                                components: [

                                                ]
                                            }).catch(() => {});
    
                                            if (game.message.roles.id) game.message.roles.edit({  
                                                embeds: [   
                                                    {
                                                        title: `Роли: ${eventOfCategory.name}`,
                                                        color: appearance.embed.color,
                                                        description: `${contentOfMessageLeading}`
                                                    },
                                                    {
                                                        color: appearance.embed.color,
                                                        description: `## ${appearance.emoji.NoConfirmation} Активный роли не были подтвержены\nИгра **отменена**, пользователи (**${membersNoConfirmation.length}**): ${textMembersNoConfirmation || 'Отсутствуют'} получили наказания`
                                                    }
                                                ]
                                            }).catch(() => {});

                                            guilds[EventId].game = game;
                                            guilds[EventId].status = 'Игра не принята';
                                            users[guilds[EventId].Owner].Events.unshift(
                                                {
                        
                                                    EventId: EventId,
                                                    Ended: Date.now () / 1000,
                                                    Created: guilds[EventId].Created,
                        
                                                    message: {
    
                                                        log: logMessage,
                                                        announcement: guilds[EventId].message.announcement
                        
                                                    }
                                                    
                                                }
                                            );
    
                                            guilds[guild.id].Events.Active = guilds[guild.id].Events.Active.filter((n) => { return n != EventId });
                                            users[member.id].ActiveEvent = false;
    
                                            if (guilds[EventId].message.announcement) 
                                            guilds[EventId].message.announcement.edit({
                                                content: ' ',
                                                components: [
                                                    {
                                                        type: 1,
                                                        components: [
                                                            {
                                                                type: 2, 
                                                                style: 5, 
                                                                label: 'Мероприятие окончено', 
                                                                url: `https://discord.gg/BneyWRqe`,
                                                                disabled: true 
                                                            }
                                                        ]
                                                    }
                                                ]
                                            }).catch(() => {});

                                        }

                                        else if (game.ready) {

                                            eventOwner = await guild.members.fetch(guilds[EventId].Owner).catch(() => {});
                                            clearInterval(startGameInterval);

                                            
                                            for (const pickServer in game.servers) {

                                                for (const pickChannel in game.servers[pickServer].channels) {

                                                    let textAccess = '';
                                                    for (const pickMember in game.members) {

                                                        for (const pickServer in game.members[pickMember].role.servers) if (game.members[pickMember].role.servers[pickServer].name == game.servers[pickServer].guild.name) textAccess += `\n${getNumber (game.members[pickMember].number)} ${game.members[pickMember].role.emoji} <@${game.members[pickMember].id}>`;
                                                    
                                                    };

                                                    const channelMessage = game.servers[pickServer].channels[pickChannel].config.message;
                                                    let pickServerAvatar = game.servers[pickServer].guild.iconURL({ dynamic: true, size: 512, format: 'png' });

                                                    if (channelMessage) game.servers[pickServer].channels[pickChannel].channel.send({
                                                        embeds: [
                                                            {
                                                                title: `Информация: ${eventOfCategory.name}`,
                                                                color: appearance.embed.color,
                                                                description: `${textAccess ? textAccess + '\n\n' : ''}${channelMessage.description}`,
                                                                thumbnail: { url: pickServerAvatar }
                                                            }
                                                        ]
                                                    }).catch(() => {});

                                                };

                                            };


                                            let wRoles = '';
                                            if (eventOfCategory.game.actions.w.access) {

                                                for (const pickRole in eventOfCategory.game.role.list) {

                                                    if (eventOfCategory.game.actions.w.roleAccess.includes(pickRole)) {

                                                        const pickRoleFetch = eventOfCategory.game.role.list[pickRole];

                                                        if (wRoles == '') wRoles += `${pickRoleFetch.emoji} **${pickRoleFetch.name}**`;
                                                        else wRoles += `, ${pickRoleFetch.emoji} **${pickRoleFetch.name}**`;

                                                    };

                                                };

                                            };


                                            let idCommandW = 0;
                                            let idCommandK = 0;
                                            const commands = await client.application.commands.fetch().catch(() => {});

                                            commands.forEach(command => {
                                                if (command.name == 'w') idCommandW = command.id;
                                                if (command.name == 'k') idCommandK = command.id;
                                            });


                                            const matchAgreement = eventOfCategory.game.lasts.agreement.match(/^\d{1,99}(s|m|h|d|w)$/);
                                            const timeAgreement = (+matchAgreement[0].slice(0,-1))*(matchAgreement[1]=='s'?1:matchAgreement[1]=='m'?60:matchAgreement[1]=='h'?60*60:matchAgreement[1]=='d'?60*60*24:matchAgreement[1]=='w'?60*60*24*7:0);
                                            
                                            
                                            if (game.message.info.id) game.message.info.edit({  
                                                embeds: [
                                                    {
                                                        title: `Мероприятие: ${eventOfCategory.name}`,
                                                        color: appearance.embed.color,
                                                        description: `Игроков: **${membersOfT}** из **${eventOfCategory.record.maxMembers}**\nВедущий: ${eventOwner}`,
                                                        footer: { text: `Вам в личные сообщения была отправлена карточка с рандомной ролью` },
                                                        image: { url: appearance.custom.Events.default.nullImage },
                                                        fields: infoEmbedsFields
                                                    },
                                                    {
                                                        title: `Роли: ${eventOfCategory.name}`,
                                                        color: appearance.embed.color,
                                                        image: { url: appearance.custom.Events.default.nullImage },
                                                        fields: fieldsRole
                                                    }
                                                ]
                                            }).catch(() => {});

                                            eventRecordChannel.send({  
                                                embeds: [
                                                    {
                                                        title: `Неигровые: ${eventOfCategory.name}`,
                                                        color: appearance.embed.color,
                                                        image: { url: appearance.custom.Events.default.nullImage },
                                                        description: `## ${eventOfCategory.game.actions.w.name}\n${eventOfCategory.game.actions.w.access ? `У ролей ${wRoles} есть возможность **1** раз за игру **подмигнуть** любому живому игроку с помощью **команды** </w:${idCommandW}> в личных сообщенияx с ${client.user}\n-# Работает только **днем**` : `Отключены`}\n## ${eventOfCategory.game.actions.k.name}\n${eventOfCategory.game.actions.k.access ? `Любой **живой** игрок за столом может постучать **живому** игроку с помощью **команды** </k:${idCommandK}> в личных сообщенияx с ${client.user}\n-# Работает только **днем**` : `Отключены`}`
                                                    }
                                                ]
                                            }).catch(() => {});

                                            if (game.message.roles.id) game.message.roles.edit({  
                                                embeds: [   
                                                    {
                                                        title: `Роли: ${eventOfCategory.name}`,
                                                        color: appearance.embed.color,
                                                        description: `${contentOfMessageLeading}`
                                                    },
                                                    {
                                                        color: appearance.embed.color,
                                                        description: `## ${appearance.emoji.Confirmation} Активный роли подтвержены\nИгра **запущена**, договорка продлится ${hourTranslatorBold(Math.floor(timeAgreement))}`
                                                    }
                                                ]
                                            }).catch(() => {});


                                            const gameLogMessage = await eventManageChannel.send({
                                                content: `${eventOwner}`
                                            }).catch(() => {});

                                            const gameLog = await gameLogMessage.startThread({ name: 'Логи' }).catch(() => {});

                                            gameLogMessage.edit({
                                                content: `${gameLog}\n-# Логируются действия:\n-# ・Покидание голосового канала・Покидание сервера\n-# ・Неигровое изменение никнеймов игроков・Удаление/изменение сообщений`
                                            }).catch(() => {});
                                            

                                            if (manageMessage.id) manageMessage.edit({
                                                embeds: [
                                                    {
                                                        title: `Управление: ${eventOfCategory.name}`,
                                                        color: appearance.embed.color,
                                                        fields: additionInformationOrCommand ?
                                                        [
                                                            {
                                                                name: 'Кнопки:',
                                                                value: `${appearance.emoji.Nigth} — Запустить **ночь**\n${appearance.emoji.Pause} — Поставить/снять **паузу**\n${appearance.emoji.Timer} — Открыть **меню** таймера\n${appearance.emoji.Delete} — Досрочно **завершить** игру`,
                                                                inline: false
                                                            }, 
                                                            {
                                                                name: 'Ветки:',
                                                                value: `${gameLog} — Логирование **действий** игроков`,
                                                                inline: false
                                                            },
                                                            {
                                                                name: 'Команды:',
                                                                value: `${additionInformationOrCommand}`,
                                                                inline: false
                                                            }
                                                        ]
                                                        :
                                                        [
                                                            {
                                                                name: 'Кнопки:',
                                                                value: `${appearance.emoji.Nigth} — Запустить **ночь**\n${appearance.emoji.Pause} — Поставить/снять **паузу**\n${appearance.emoji.Timer} — Открыть **меню** таймера\n${appearance.emoji.Delete} — Досрочно **завершить** игру`,
                                                                inline: false
                                                            }, 
                                                            {
                                                                name: 'Ветки:',
                                                                value: `${gameLog} — Логирование действий игроков`,
                                                                inline: false
                                                            }
                                                        ]
                                                    }
                                                ],
                                                components: [
                                                    {
                                                        type: 1,
                                                        components: [
                                                            {
                                                                type: 3,
                                                                customId: 'endGame', 
                                                                placeholder: 'Выберите победившую команду', 
                                                                minValues: 1, 
                                                                maxValues: 1, 
                                                                options: options
                                                            }
                                                        ]
                                                    },
                                                    {
                                                        type: 1,
                                                        components: [
                                                            {
                                                                type: 2, 
                                                                style: appearance.buttons_menu.Default.style, 
                                                                customId: 'nigth', 
                                                                emoji: appearance.emoji.Nigth
                                                            },
                                                            {
                                                                type: 2, 
                                                                style: appearance.buttons_menu.Default.style, 
                                                                customId: 'pause', 
                                                                emoji: appearance.emoji.Pause
                                                            },
                                                            {
                                                                type: 2, 
                                                                style: appearance.buttons_menu.Default.style, 
                                                                customId: 'timer', 
                                                                emoji: appearance.emoji.Timer
                                                            },
                                                            {
                                                                type: 2, 
                                                                style: appearance.buttons_menu.Default.style, 
                                                                customId: 'anticipatorily', 
                                                                emoji: appearance.emoji.Delete
                                                            }
                                                        ]
                                                    }
                                                ]
                                            }).catch(() => {});

                                            parameters.gameLog = gameLog;
                                            

                                            punishmentOldInVote = punishmentMessage;
                                            
                                            if (eventOfCategory.game.punishment[0]) game.message.punishment = await eventManageChannel.send(punishmentMessage ()).catch(() => {});
                                            if (eventOfCategory.game.vote.access) game.message.vote = await eventManageChannel.send(voteMessage ()).catch(() => {});


                                            if (eventOfCategory.game.actions.w.access) {

                                                for (const pickMember in game.members) {
    
                                                    if (eventOfCategory.game.actions.w.roleAccess.includes(game.members[pickMember].role.name)) {

                                                        const fetchPickMember = await guild.members.fetch(game.members[pickMember].id).catch(() => {});
                                                        fetchPickMember.send({
                                                            embeds: [
                                                                {
                                                                    color: appearance.embed.color,
                                                                    description: `### ${eventOfCategory.game.actions.w.emoji} ${eventOfCategory.game.actions.w.name}\n${fetchPickMember}, у Вас есть возможность **1** раз за игру **подмигнуть** любому живому игроку за столом с помощью **команды** </w:${idCommandW}>\n-# Подмигнуть можно только днем`,
                                                                }
                                                            ]                                                                
                                                        }).catch(() => {});

                                                    };

                                                };

                                                let useW = [];
                                                client.on('interactionCreate', async interaction => {

                                                    if (interaction.isCommand()) {

                                                        if (interaction.commandName == 'w' && !guilds[EventId].deleted && !useW.includes(interaction.user.id) && !interaction.guild && game.members.find(memberGame => memberGame.id == interaction.user.id) && game.members.find(memberGame => memberGame.id == interaction.user.id).alive && eventOfCategory.game.actions.w.roleAccess.includes(game.members.find(memberGame => memberGame.id == interaction.user.id).role.name)) {

                                                            if (game.time !== 'day') 
                                                            return interaction.reply({
                                                                ephemeral: true,
                                                                embeds: [
                                                                    {
                                                                        title: `${client.user.username} error`,
                                                                        color: appearance.embed.errorColor,
                                                                        description: `${interaction.user}, мигать можно **только** днем`,
                                                                        thumbnail: { url: await getAvatar(interaction.user) }
                                                                    }
                                                                ]
                                                            }).catch(() => {});

                                                            components = [];
                                                            components.push(
                                                                {
                                                                    type: 1,
                                                                    components: []
                                                                }
                                                            );

                                                            const channelMember = await client.channels.fetch(interaction.channelId).catch(() => {});
                                                            interaction.deferReply().catch(() => {});

                                                            for (const pickMember in game.members) {
                                                
                                                                if (!components[0] || components[components.length-1].components.length == 5) 
                                                                components.push(
                                                                    {
                                                                        type: 1,
                                                                        components: []
                                                                    }
                                                                );
                    
                                                                components[components.length-1].components.push(
                                                                    {
                                                                        type: 2, 
                                                                        style: game.members[pickMember].alive ? appearance.buttons_menu.Default.style : 4, 
                                                                        customId: `w${game.members[pickMember].number}`,
                                                                        label: `${game.members[pickMember].number}`, 
                                                                        disabled: game.members[pickMember].id !== interaction.user.id && game.members[pickMember].alive ? false : true
                                                                    }
                                                                );

                                                                const collectors = await channelMember.createMessageComponentCollector();
                                                                collectors.on('collect', async i => {
                                                                
                                                                    if (!i.user || i.user.id !== interaction.user.id) return;
                                                                    if (!i.message.interaction || i.message.interaction.id !== interaction.id) return;
                                                            
                                                                    switch (i.customId) { 
                                                                        
                                                                        case `w${game.members[pickMember].number}`: {

                                                                            if (useW.includes(i.user.id)) 
                                                                            return i.update({
                                                                                embeds: [
                                                                                    {
                                                                                        color: appearance.embed.color,
                                                                                        description: `### ${eventOfCategory.game.actions.w.emoji} ${eventOfCategory.game.actions.w.name}\nВы **изросходовали** все подмигивания`,
                                                                                    }
                                                                                ],
                                                                                components: [

                                                                                ]
                                                                            }).catch(() => {});

                                                                            if (guilds[EventId].deleted || !game.members[pickMember].alive || !game.members.find(memberGame => memberGame.id == i.user.id).alive) 
                                                                            return i.update({
                                                                                embeds: [
                                                                                    {
                                                                                        color: appearance.embed.color,
                                                                                        description: `### ${eventOfCategory.game.actions.w.emoji} ${eventOfCategory.game.actions.w.name}\n**Невозможно** подмигнуть игроку **${game.members[pickMember].number}**`,
                                                                                    }
                                                                                ],
                                                                                components: [

                                                                                ]
                                                                            }).catch(() => {});

                                                                            useW.push(interaction.user.id);
                                                                            i.update({
                                                                                embeds: [
                                                                                    {
                                                                                        color: appearance.embed.color,
                                                                                        description: `### ${eventOfCategory.game.actions.w.emoji} ${eventOfCategory.game.actions.w.name}\nВы **успешно** подмигнули игроку **${game.members[pickMember].number}**`,
                                                                                    }
                                                                                ],
                                                                                components: [

                                                                                ]
                                                                            }).catch(() => {});

                                                                            const fetchPickMember = await guild.members.fetch(game.members[pickMember].id).catch(() => {});
                                                                            fetchPickMember.send({
                                                                                embeds: [
                                                                                    {
                                                                                        color: appearance.embed.color,
                                                                                        description: `### ${eventOfCategory.game.actions.w.emoji} ${eventOfCategory.game.actions.w.name}\nВам подмигнул игрок **${game.members.find(memberGame => memberGame.id == interaction.user.id).number}**`,
                                                                                    }
                                                                                ],
                                                                                components: [

                                                                                ]
                                                                            }).catch(() => {});

                                                                            const fetchEventOwner = await guild.members.fetch(guilds[EventId].Owner).catch(() => {});
                                                                            fetchEventOwner.send({
                                                                                embeds: [
                                                                                    {
                                                                                        color: appearance.embed.color,
                                                                                        description: `### ${eventOfCategory.game.actions.w.emoji} ${eventOfCategory.game.actions.w.name}\nИгрок **${game.members.find(memberGame => memberGame.id == interaction.user.id).number}** подмигнул игроку **${game.members[pickMember].number}**`,
                                                                                    }
                                                                                ],
                                                                                components: [

                                                                                ]
                                                                            }).catch(() => {});

                                                                            break;

                                                                        }

                                                                    };

                                                                });
                                                                
                    
                                                            };

                                                            setTimeout(() => {

                                                                interaction.editReply({
                                                                    embeds: [
                                                                        {
                                                                            color: appearance.embed.color,
                                                                            description: `# ${eventOfCategory.game.actions.w.emoji} ${eventOfCategory.game.actions.w.name}\nВыберите **номер** игрока`
                                                                        }
                                                                    ],
                                                                    components: components
                                                                }).catch(() => {});
                                                                
                                                            }, 2500);

                                                        };

                                                    };

                                                });

                                            };

                                            if (eventOfCategory.game.actions.k.access) {

                                                for (const pickMember in game.members) {

                                                    const fetchPickMember = await guild.members.fetch(game.members[pickMember].id).catch(() => {});
                                                    fetchPickMember.send({
                                                        embeds: [
                                                            {
                                                                color: appearance.embed.color,
                                                                description: `### ${eventOfCategory.game.actions.k.emoji} ${eventOfCategory.game.actions.k.name}\n${fetchPickMember}, Вы можете **отстучать** живому игроку с помощью </k:${idCommandK}>\n-# Стучать можно только днем`,
                                                            }
                                                        ]                                                                
                                                    }).catch(() => {});

                                                };

                                                client.on('interactionCreate', async interaction => {

                                                    if (interaction.isCommand()) {

                                                        if (interaction.commandName == 'k' && !guilds[EventId].deleted && !interaction.guild && game.members.find(memberGame => memberGame.id == interaction.user.id) && game.members.find(memberGame => memberGame.id == interaction.user.id).alive) {

                                                            if (game.time !== 'day') 
                                                            return interaction.reply({
                                                                ephemeral: true,
                                                                embeds: [
                                                                    {
                                                                        title: `${client.user.username} error`,
                                                                        color: appearance.embed.errorColor,
                                                                        description: `${interaction.user}, стучать можно **только** днем`,
                                                                        thumbnail: { url: await getAvatar(interaction.user) }
                                                                    }
                                                                ]
                                                            }).catch(() => {});

                                                            let pickMemberNumber = Number(game.members.find(memberGame => memberGame.id == interaction.user.id).number);
                                                            let pickMemberOfGame = false;
                                                            
                                                            if (interaction.options._hoistedOptions[0].value == 'right') pickMemberNumber--;
                                                            else if (interaction.options._hoistedOptions[0].value == 'left') pickMemberNumber++;

                                                            for (const pickMember in game.members) if (game.members[pickMember].number == pickMemberNumber && game.members[pickMember].alive) pickMemberOfGame = game.members[pickMember];


                                                            if (!pickMemberOfGame) 
                                                            return interaction.reply({
                                                                ephemeral: true,
                                                                embeds: [
                                                                    {
                                                                        title: `${client.user.username} error`,
                                                                        color: appearance.embed.errorColor,
                                                                        description: `${interaction.user}, игрок **не найден** или был убит`,
                                                                        thumbnail: { url: await getAvatar(interaction.user) }
                                                                    }
                                                                ]
                                                            }).catch(() => {});

                                                            const fetchPickMember = await guild.members.fetch(pickMemberOfGame.id).catch(() => {});
                                                            fetchPickMember.send({
                                                                embeds: [
                                                                    {
                                                                        color: appearance.embed.color,
                                                                        description: `### ${eventOfCategory.game.actions.k.emoji} ${eventOfCategory.game.actions.k.name}\nИгрок **${game.members.find(memberGame => memberGame.id == interaction.user.id).number}** постучал вам — **${interaction.options._hoistedOptions[1].value}** раз(а)`,
                                                                    }
                                                                ],
                                                                components: [

                                                                ]
                                                            }).catch(() => {});

                                                            const fetchEventOwner = await guild.members.fetch(guilds[EventId].Owner).catch(() => {});
                                                            fetchEventOwner.send({
                                                                embeds: [
                                                                    {
                                                                        color: appearance.embed.color,
                                                                        description: `### ${eventOfCategory.game.actions.k.emoji} ${eventOfCategory.game.actions.k.name}\nИгрок **${game.members.find(memberGame => memberGame.id == interaction.user.id).number}** постучал игроку **${pickMemberOfGame.number}** — **${interaction.options._hoistedOptions[1].value}** раз(а)`,
                                                                    }
                                                                ],
                                                                components: [

                                                                ]
                                                            }).catch(() => {});

                                                            interaction.reply({
                                                                ephemeral: true,
                                                                embeds: [
                                                                    {
                                                                        color: appearance.embed.color,
                                                                        description: `### ${eventOfCategory.game.actions.k.emoji} ${eventOfCategory.game.actions.k.name}\nВы постучали игроку **${pickMemberOfGame.number}** — **${interaction.options._hoistedOptions[1].value}** раз(а)`,
                                                                    }
                                                                ],
                                                                components: [

                                                                ]
                                                            }).catch(() => {});

                                                        };

                                                    };

                                                });

                                            };


                                            client.on('guildMemberRemove', async member => {

                                                if (!guilds[EventId].deleted && member.guild.id == guild.id && game.members.find(memberGame => memberGame.id == member.id) && game.members.find(memberGame => memberGame.id == member.id).alive) {
    
                                                    game.members.find(memberGame => memberGame.id == member.id).alive = false;

                                                    if (game.message.vote) game.message.vote.edit(voteMessage ()).catch(() => {});
                                                    if (game.message.punishment) game.message.punishment.edit(punishmentMessage ()).catch(() => {});

                                                    gameLog.send({
                                                        content: `||<@${guilds[EventId].Owner}>||`,
                                                        embeds: [   
                                                            {
                                                                title: `Логи: ${eventOfCategory.name}`,
                                                                color: appearance.embed.color,
                                                                fields: [
                                                                    {
                                                                        name: `> Пользователь:`,
                                                                        value: `・${member}\n・${member.id}`,
                                                                        inline: true
                                                                    },
                                                                    {
                                                                        name: `> Действие:`,
                                                                        value: `\`\`\`Лив с сервера\`\`\``,
                                                                        inline: true
                                                                    },
                                                                    {
                                                                        name: `> Сервер:`,
                                                                        value: `\`\`\`${guild.name}\`\`\``,
                                                                        inline: false
                                                                    }
                                                                ]
                                                            }
                                                        ]

                                                    }).catch(() => {});

                                                };

                                            });

                                            client.on('guildMemberUpdate', async (oldMember, newMember) => {

                                                if (!guilds[EventId].deleted && oldMember.nickname !== newMember.nickname && game.members.find(memberGame => memberGame.id == newMember.id) && game.members.find(memberGame => memberGame.id == newMember.id).alive) {


                                                    const fetchedLogs = await guild.fetchAuditLogs({
                                                        limit: 5,
                                                        type: AuditLogEvent
                                                    });

                                                    let member = {};
                                                    for (const pickEntries of fetchedLogs.entries) if (pickEntries[1].action == 24 && pickEntries[1].changes && pickEntries[1].changes[0].new == newMember.nickname && pickEntries[1].target.id == newMember.id) member = await guild.members.fetch(pickEntries[1].executor.id);
                                                    if (!member || !member.user ||member.user.bot || member.user.id == guilds[EventId].Owner) return;

                                                    if (member) {

                                                        gameLog.send({
                                                            content: `||<@${guilds[EventId].Owner}>||`,
                                                            embeds: [   
                                                                {
                                                                    title: `Логи: ${eventOfCategory.name}`,
                                                                    color: appearance.embed.color,
                                                                    fields: [
                                                                        {
                                                                            name: `> Пользователь:`,
                                                                            value: `・${newMember}\n・${newMember.id}`,
                                                                            inline: true
                                                                        },
                                                                        {
                                                                            name: `> Изменил:`,
                                                                            value: `・${member}\n・${member.id}`,
                                                                            inline: true
                                                                        },
                                                                        {
                                                                            name: `> Действие:`,
                                                                            value: `\`\`\`Изменение никнейма\`\`\``,
                                                                            inline: false
                                                                        },
                                                                        {
                                                                            name: `> Никнейм:`,
                                                                            value: `\`\`\`${oldMember.nickname} ▶️ ${newMember.nickname}\`\`\``,
                                                                            inline: false
                                                                        }
                                                                    ]
                                                                }
                                                            ]

                                                        }).catch(() => {});
                                                        
                                                    }

                                                    else {
                                                        
                                                        gameLog.send({
                                                            content: `||<@${guilds[EventId].Owner}>||`,
                                                            embeds: [   
                                                                {
                                                                    title: `Логи: ${eventOfCategory.name}`,
                                                                    color: appearance.embed.color,
                                                                    fields: [
                                                                        {
                                                                            name: `> Пользователь:`,
                                                                            value: `・${newMember}\n・${newMember.id}`,
                                                                            inline: true
                                                                        },
                                                                        {
                                                                            name: `> Действие:`,
                                                                            value: `\`\`\`Изменение никнейма\`\`\``,
                                                                            inline: true
                                                                        },
                                                                        {
                                                                            name: `> Ник До ▶️ После:`,
                                                                            value: `\`\`\`${oldMember.nickname} ▶️ ${newMember.nickname}\`\`\``,
                                                                            inline: false
                                                                        }
                                                                    ]
                                                                }
                                                            ]

                                                        }).catch(() => {});

                                                    }

                                                };
                                        
                                            });

                                            client.on('messageDelete', async message => {

                                                if (!guilds[EventId].deleted && message.content && message.channel.id == eventRecordChannel.id && game.members.find(memberGame => memberGame.id == message.member.id)) {

                                                    gameLog.send({
                                                        content: `||<@${guilds[EventId].Owner}>||`,
                                                        embeds: [   
                                                            {
                                                                title: `Логи: ${eventOfCategory.name}`,
                                                                color: appearance.embed.color,
                                                                fields: [
                                                                    {
                                                                        name: `> Пользователь:`,
                                                                        value: `・${message.member}\n・${message.id}`,
                                                                        inline: true
                                                                    },
                                                                    {
                                                                        name: `> Действие:`,
                                                                        value: `\`\`\`Удаление сообщения\`\`\``,
                                                                        inline: true
                                                                    },
                                                                    {
                                                                        name: `> Сообщение:`,
                                                                        value: `\`\`\`${message.content}\`\`\``,
                                                                        inline: false
                                                                    }
                                                                ]
                                                            }
                                                        ]

                                                    }).catch(() => {});

                                                };
                                        
                                            });

                                            client.on('messageUpdate', async (oldMessage, newMessage) => {

                                                if (!guilds[EventId].deleted && oldMessage.content !== newMessage.content && newMessage.channel.id == eventRecordChannel.id && game.members.find(memberGame => memberGame.id == newMessage.member.id)) {

                                                    gameLog.send({
                                                        content: `||<@${guilds[EventId].Owner}>||`,
                                                        embeds: [   
                                                            {
                                                                title: `Логи: ${eventOfCategory.name}`,
                                                                color: appearance.embed.color,
                                                                fields: [
                                                                    {
                                                                        name: `> Пользователь:`,
                                                                        value: `・${newMessage.member}\n・${newMessage.id}`,
                                                                        inline: true
                                                                    },
                                                                    {
                                                                        name: `> Действие:`,
                                                                        value: `[\`Изменение сообщения\`](https://discord.com/channels/${newMessage.guild.id}/${newMessage.channel.id}/${newMessage.id})`,
                                                                        inline: true
                                                                    },
                                                                    {
                                                                        name: `> Старое сообщение:`,
                                                                        value: `\`\`\`${oldMessage.content}\`\`\``,
                                                                        inline: false
                                                                    },
                                                                    {
                                                                        name: `> Новое сообщение:`,
                                                                        value: `\`\`\`${newMessage.content}\`\`\``,
                                                                        inline: false
                                                                    }
                                                                ]
                                                            }
                                                        ]

                                                    }).catch(() => {});

                                                };
                                        
                                            });

                                            client.on('voiceStateUpdate', async (oldState, newState) => {

                                                if (!guilds[EventId].deleted && oldState.channelId !== newState.channelId && newState.channelId !== eventVoiceChannel.id && game.members.find(memberGame => memberGame.id == newState.member.id) && game.members.find(memberGame => memberGame.id == newState.member.id).alive) {

                                                    gameLog.send({
                                                        content: `||<@${guilds[EventId].Owner}>||`,
                                                        embeds: [   
                                                            {
                                                                title: `Логи: ${eventOfCategory.name}`,
                                                                color: appearance.embed.color,
                                                                fields: [
                                                                    {
                                                                        name: `> Пользователь:`,
                                                                        value: `・<@${newState.id}>\n・${newState.id}`,
                                                                        inline: true
                                                                    },
                                                                    {
                                                                        name: `> Действие:`,
                                                                        value: `\`\`\`Лив из канала\`\`\``,
                                                                        inline: true
                                                                    },
                                                                    {
                                                                        name: `> Канал:`,
                                                                        value: `・${eventVoiceChannel}\n・${eventVoiceChannel.id}`,
                                                                        inline: false
                                                                    }
                                                                ]
                                                            }
                                                        ]

                                                    }).catch(() => {});

                                                };
                                        
                                            });


                                            game.time = 'agreement';
                                            let dayTime = timeAgreement+Date.now()/1000;

                                            await startTrack (eventRecordChannel, eventVoiceChannel);

                                            eventRecordChannel.send({
                                                embeds: [
                                                    {
                                                        title: `Договорка: ${eventOfCategory.name}`,
                                                        color: appearance.embed.color,
                                                        image: { url: eventOfCategory.game.image.agreement },
                                                        footer: { text: `Длительность ${hourTranslator(Math.floor(timeAgreement))}` },
                                                    }
                                                ]
                                            }).catch(() => {});

                                            for (const pickServer in game.servers) {

                                                for (const pickChannel in game.servers[pickServer].channels) {

                                                    let pickChannelOfList = game.servers[pickServer].channels[pickChannel].config;
                                                    
                                                    for (const pickPermission in pickChannelOfList.permission) {
    
                                                        if (pickPermission == game.time) {
    
                                                            for (const pickPermissionOfTime in pickChannelOfList.permission[pickPermission]) {
    
                                                                if (pickChannelOfList.permission[pickPermission][pickPermissionOfTime].Role == 'everyone') game.servers[pickServer].channels[pickChannel].channel.permissionOverwrites.edit(game.servers[pickServer].guild.id, pickChannelOfList.permission[pickPermission][pickPermissionOfTime].Permission).catch(() => {});
                                                                else {
    
                                                                    const pickRoleFetch = game.servers[pickServer].roles.find(role => role.name == pickChannelOfList.permission[pickPermission][pickPermissionOfTime].Role).role;
                                                                    game.servers[pickServer].channels[pickChannel].channel.permissionOverwrites.edit(pickRoleFetch.id, pickChannelOfList.permission[pickPermission][pickPermissionOfTime].Permission).catch(() => {});
                                                                    
                                                                };
    
                                                            };
    
                                                        };
    
                                                    };

                                                };

                                            };

                                            for (const pickServer in game.servers) {

                                                for (const pickChannel in game.servers[pickServer].channels) {

                                                    setTimeout(() => {

                                                        game.servers[pickServer].channels[pickChannel].channel.send({
                                                            embeds: [
                                                                {
                                                                    title: `Уведомление: ${eventOfCategory.name}`,
                                                                    color: appearance.embed.color,
                                                                    description: `День <t:${Math.floor(dayTime)}:R>`
                                                                    
                                                                }
                                                            ]
                                                        }).catch(() => {});
                                                        
                                                    }, Math.floor(timeAgreement*1000/2));

                                                };

                                            };

                                            setTimeout(async () => {

                                                cancelTrack ();

                                                if (guilds[EventId].deleted) return;

                                                game.time = 'day';
                                                eventRecordChannel.send({
                                                    embeds: [
                                                        {
                                                            title: `День: ${eventOfCategory.name}`,
                                                            color: appearance.embed.color,
                                                            image: { url: eventOfCategory.game.image.day }
                                                        }
                                                    ]
                                                }).catch(() => {});

                                                for (const pickServer in game.servers) {
    
                                                    for (const pickChannel in game.servers[pickServer].channels) {
                                                    
                                                        game.servers[pickServer].channels[pickChannel].channel.send({
                                                            embeds: [
                                                                {
                                                                    title: `Уведомление: ${eventOfCategory.name}`,
                                                                    color: appearance.embed.color,
                                                                    description: `В городе наступил день`
                                                                    
                                                                }
                                                            ]
                                                        }).catch(() => {});
    
                                                    };
    
                                                };

                                                for (const pickServer in game.servers) {

                                                    if (game.servers[pickServer].server.oneAgreement) for (const pickMember of game.servers[pickServer].guild.members.cache) pickMember[1].kick().catch(() => {});

                                                    for (const pickChannel in game.servers[pickServer].channels) {

                                                        let pickChannelOfList = game.servers[pickServer].channels[pickChannel].config;
                                                        
                                                        for (const pickPermission in pickChannelOfList.permission) {
        
                                                            if (pickPermission == game.time) {
        
                                                                for (const pickPermissionOfTime in pickChannelOfList.permission[pickPermission]) {
        
                                                                    if (pickChannelOfList.permission[pickPermission][pickPermissionOfTime].Role == 'everyone') game.servers[pickServer].channels[pickChannel].channel.permissionOverwrites.edit(game.servers[pickServer].guild.id, pickChannelOfList.permission[pickPermission][pickPermissionOfTime].Permission).catch(() => {});
                                                                    else {
        
                                                                        const pickRoleFetch = game.servers[pickServer].roles.find(role => role.name == pickChannelOfList.permission[pickPermission][pickPermissionOfTime].Role).role;
                                                                        game.servers[pickServer].channels[pickChannel].channel.permissionOverwrites.edit(pickRoleFetch.id, pickChannelOfList.permission[pickPermission][pickPermissionOfTime].Permission).catch(() => {});
                                                                        
                                                                    };
        
                                                                };
        
                                                            };
        
                                                        };

                                                    };

                                                };

                                                for (const pickMember in game.members) {

                                                    if (game.members[pickMember].alive) {

                                                        const fetchPickMember = await guild.members.fetch(game.members[pickMember].id).catch(() => {});
                                                        if (fetchPickMember) {

                                                            eventVoiceChannel.permissionOverwrites.edit(fetchPickMember.id, { Speak: true }).catch(() => {});

                                                            setTimeout(() => {
                                                                
                                                                eventRecordChannel.permissionOverwrites.edit(fetchPickMember.id, { SendMessages: true }).catch(() => {});
                                                                fetchPickMember.voice.setChannel(eventVoiceChannel.id).catch(() => {});

                                                            }, 1200);

                                                        };

                                                    };

                                                };
                                                
                                            }, timeAgreement*1000 == 0 ? 1000 : timeAgreement*1000);

                                        }
                                        
                                        else {
                                            
                                            // if (game.message.info.id) game.message.info.edit({  
                                            //     embeds: [
                                            //         {
                                            //             title: `Мероприятие: ${eventOfCategory.name}`,
                                            //             color: appearance.embed.color,
                                            //             description: `Игроков: **${membersOfT}** из **${eventOfCategory.record.maxMembers}**\nВедущий: ${eventOwner}`,
                                            //             footer: { text: `Вам в личные сообщения была отправлена карточка с рандомной ролью` },
                                            //             image: { url: appearance.custom.Events.default.nullImage },
                                            //             fields: infoEmbedsFields
                                            //         },
                                            //         {
                                            //             title: `Роли: ${eventOfCategory.name}`,
                                            //             color: appearance.embed.color,
                                            //             fields: fieldsRole,
                                            //             image: { url: appearance.custom.Events.default.nullImage }
                                            //         },
                                            //         {
                                            //             title: `Готовность: ${eventOfCategory.name}`,
                                            //             color: appearance.embed.color,
                                            //             description: !textRoleNoConfirmation ? `Все роли **на столе** были приняты\n-# Игра запускается` : `Время **на подтверждение** закончится <t:${Math.floor(timeStart+examinationTimeConfirmation)}:R>\n-# Активные роли подтвердите свою готовность\n-# или зайдите на необходимый сервер`, //${textRoleNoConfirmation}`,
                                            //             image: { url: appearance.custom.Events.default.nullImage }
                                            //         }
                                            //     ]
                                            // }).catch(() => {});

                                            if (game.message.roles.id) game.message.roles.edit({  
                                                embeds: [   
                                                    {
                                                        title: `Роли: ${eventOfCategory.name}`,
                                                        color: appearance.embed.color,
                                                        description: `${contentOfMessageLeading}`
                                                    }
                                                ]
                                            }).catch(() => {});

                                        };

                                    }, 2000);

                                };

                                setTimeout(async () => {
                                    await startGame ();
                                }, 3000);

                            };


                            let membersInVoice = [];
                            let membersNoVoice = [];
                            let examinationMessage = {};

                            recordMessage.components.forEach(component => {

                                let Comp = component.components;
                
                                for (c = 0; c < Comp.length; c++) {
                
                                    if (Comp[c].data.style !== 5 && Comp[c].data.custom_id !== 'info') Comp[c].data.disabled = true;
                
                                };
                                
                            });

                            await recordMessage.edit({ components: recordMessage.components });

                            manageMessage.components.forEach(component => {

                                let Comp = component.components;
                
                                for (c = 0; c < Comp.length; c++) {
                
                                    if (Comp[c].data.style !== 5) Comp[c].data.disabled = true;
                
                                };
                                
                            });

                            await i.update({ components: manageMessage.components });


                            parameters.examination = true;
                            guilds[EventId].examination = true;

                            setTimeout(async () => {

                                membersInVoice = [];
                                membersNoVoice = [];

                                for (const pickMember in parameters.memberInEvent) {
                                
                                    if (pickMember < eventOfCategory.record.maxMembers) {
    
                                        const fetchPickMember = await guild.members.fetch(parameters.memberInEvent[pickMember]).catch(() => {});
                                        if (fetchPickMember.voice.channelId == eventVoiceChannel.id && !fetchPickMember.voice.selfDeaf) membersInVoice.push(fetchPickMember.id);
                                        
                                        else membersNoVoice.push(fetchPickMember.id);
    
                                    };
    
                                };
                                
                                examinationTime -= examinationTimeRepeat;
                                if (guilds[EventId].deleted) {
                                
                                    parameters.examination = false;
                                    guilds[EventId].examination = false;
                                    return;

                                }
                                
                                else if (!membersNoVoice[0]) {

                                    await mafiaStart ();

                                    parameters.examination = false;
                                    guilds[EventId].examination = false;
                                    return;

                                }
                                
                                else if (examinationTime >= 0 && membersNoVoice[0]) {

                                    let examinationMessageContent = '';
                                    for (let a = 0; a < membersNoVoice.length; a++) examinationMessageContent += `<@${membersNoVoice[a]}> `;

                                    let examinationMemberTab = '';
                                    for (let a = 0; a < membersNoVoice.length; a++) examinationMemberTab += `\n・<@${membersNoVoice[a]}>`;

                                    let timeoutOfSendNotif = 0;

                                    for (let a = 0; a < membersNoVoice.length; a++) {

                                        const fetchPickMember = await guild.members.fetch(membersNoVoice[a]).catch(() => {});

                                        setTimeout(async () => {

                                            const messageOfMemberDM = await fetchPickMember.send({
                                                embeds: [
                                                    {
                                                        title: `Уведомление: ${eventOfCategory.name}`,
                                                        color: appearance.embed.color,
                                                        description: `Начался сбор на [**${eventOfCategory.emoji}・${eventOfCategory.name}**](https://discord.com/channels/${eventVoiceChannel.guild.id}/${eventVoiceChannel.id}), он закончиться **<t:${Math.floor(Date.now() / 1000 + examinationTime)}:R>**\n-# Вам необходимо зайти в канал ${eventVoiceChannel}`,
                                                        // thumbnail: { url: await getAvatar(fetchPickMember) }
                                                    }
                                                ], 
                                                components: [ 
                                                    {
                                                        type: 1,
                                                        components: [
                                                            {
                                                                type: 2, 
                                                                style: 5, 
                                                                url: `https://discord.com/channels/${eventVoiceChannel.guild.id}/${eventVoiceChannel.id}`,
                                                                label: `Перейти в #${eventVoiceChannel.name}` 
                                                            }
                                                        ]
                                                    }
                                                ]
                                            }).catch(() => {});

                                            setTimeout(() => {

                                                messageOfMemberDM.edit({
                                                    embeds: [
                                                        {
                                                            title: `Уведомление: ${eventOfCategory.name}`,
                                                            color: appearance.embed.color,
                                                            description: `Сбор на [**${eventOfCategory.emoji}・${eventOfCategory.name}**](https://discord.com/channels/${eventVoiceChannel.guild.id}/${eventVoiceChannel.id}), закончился **<t:${Math.floor(Date.now() / 1000 + examinationTime)}:R>**\n-# ~~Вам необходимо зайти в канал ${eventVoiceChannel}~~`,
                                                            // thumbnail: { url: await getAvatar(fetchPickMember) }
                                                        }
                                                    ], 
                                                    components: [ 
                                                        {
                                                            type: 1,
                                                            components: [
                                                                {
                                                                    type: 2, 
                                                                    style: 5, 
                                                                    url: `https://discord.com/channels/${eventVoiceChannel.guild.id}/${eventVoiceChannel.id}`,
                                                                    label: `Перейти в #${eventVoiceChannel.name}`,
                                                                    disabled: true
                                                                }
                                                            ]
                                                        }
                                                    ]
                                                }).catch(() => {});

                                            }, examinationTime*1000);
                                            
                                        }, timeoutOfSendNotif);
                                        timeoutOfSendNotif += 500;

                                    };

                                    examinationMessage = await recordMessage.reply({ 
                                        content: `||${examinationMessageContent}||`,
                                        embeds: [
                                            {
                                                title: `Мероприятие: ${eventOfCategory.name}`,
                                                color: appearance.embed.color,
                                                description: `### Записавшиеся игрок(и):${examinationMemberTab}\n\nВам **необходимо** зайти в канал ${eventVoiceChannel} и включить наушники\nПроверка **закончится** <t:${Math.floor(Date.now() / 1000 + examinationTime)}:R>`,
                                                footer: { text: `・Ведущий: ${eventOwner.displayName}`, icon_url: await getAvatar(eventOwner) }
                                            }
                                        ],
                                        components: [
        
                                        ]
                                    }).catch(() => {});


                                    const examination = setInterval(async () => {

                                        if (guilds[EventId].deleted) clearInterval(examination);

                                        membersInVoice = [];
                                        membersNoVoice = [];

                                        for (const pickMember in parameters.memberInEvent) {
                                        
                                            if (pickMember < eventOfCategory.record.maxMembers) {
            
                                                const fetchPickMember = await guild.members.fetch(parameters.memberInEvent[pickMember]).catch(() => {});
                                                if (fetchPickMember.voice.channelId == eventVoiceChannel.id && !fetchPickMember.voice.selfDeaf) membersInVoice.push(fetchPickMember.id);
                                                
                                                else membersNoVoice.push(fetchPickMember.id);
            
                                            };
            
                                        };
                                        
                                        
                                        examinationTime -= examinationTimeRepeat;
                                        if (guilds[EventId].deleted) {
                                
                                            clearInterval(examination);

                                            parameters.examination = false;
                                            guilds[EventId].examination = false;
                                            return;

                                        }
                                        
                                        else if (examinationTime <= 0 && membersNoVoice[0]) {

                                            clearInterval(examination);
                                            
                                            parameters.savePriority = membersInVoice;
                                            parameters.memberInEvent = membersInVoice;
                                            await recordMessage.edit(await updateRecordMessage ());

                                            examinationMessage.delete().catch(() => {});

                                            recordMessage.components.forEach(component => {

                                                let Comp = component.components;
                                
                                                for (c = 0; c < Comp.length; c++) {
                                
                                                    if (Comp[c].data.style !== 5 && Comp[c].data.custom_id !== 'info') Comp[c].data.disabled = false;
                                
                                                };
                                                
                                            });

                                            await recordMessage.edit({ components: recordMessage.components });

                                            manageMessage.components.forEach(component => {
        
                                                let Comp = component.components;
                                
                                                for (c = 0; c < Comp.length; c++) {
                                
                                                    if (Comp[c].data.custom_id !== 'announcement') Comp[c].data.disabled = !parameters.announcementMessage ? false : true;
                                                    else if (Comp[c].data.style !== 5) Comp[c].data.disabled = false;
                                
                                                };
                                                
                                            });
        
                                            await manageMessage.edit({ components: manageMessage.components });


                                            parameters.examination = false;
                                            guilds[EventId].examination = false;
                                            return;

                                        }
                                        
                                        else if (!membersNoVoice[0]) {

                                            await mafiaStart ();
                                            examinationMessage.delete().catch(() => {});
                                            clearInterval(examination);

                                            parameters.examination = false;
                                            guilds[EventId].examination = false;
                                            return;

                                        }
                                        
                                        else if (examinationTime >= 0 && membersNoVoice[0]) {

                                            let examinationMessageContent = '';
                                            examinationMessage.delete().catch(() => {});
                                            for (let a = 0; a < membersNoVoice.length; a++) examinationMessageContent += `<@${membersNoVoice[a]}> `;

                                            let examinationMemberTab = '';
                                            for (let a = 0; a < membersNoVoice.length; a++) examinationMemberTab += `\n・<@${membersNoVoice[a]}>`;

                                            examinationMessage = await recordMessage.reply({ 
                                                content: `||${examinationMessageContent}||`,
                                                embeds: [
                                                    {
                                                        title: `Мероприятие: ${eventOfCategory.name}`,
                                                        color: appearance.embed.color,
                                                        description: `### Записавшиеся игрок(и):${examinationMemberTab}\n\nВам **необходимо** зайти в канал ${eventVoiceChannel} и включить наушники\nПроверка **закончится** <t:${Math.floor(Date.now() / 1000 + examinationTime)}:R>`,
                                                        footer: { text: `・Ведущий: ${eventOwner.displayName}`, icon_url: await getAvatar(eventOwner) }
                                                    }
                                                ],
                                                components: [
                
                                                ]
                                            }).catch(() => {});
                                            return;

                                        };

                                        return;

                                    }, examinationTimeRepeat * 1000);
                                    
                                };

                            }, 1);


                            break;

                        }

                        default: {
            
                            if (actions[i.customId] && actions[i.customId].all == false) await actions[i.customId].actions[0](i);
            
                            break;
            
                        }
                    
                    };

                });

            };

        };

        if (await checkingForRoles (interaction, appearance.roles.Events.access) !== true) return;
        
        let path = [];
        let options = [];
        let firstOptions = [];
        let eventsListMass = [];
        const categoresEvents = appearance.custom.Events.list;
        parameters.eventsCategory = categoresEvents;

        for (const event in categoresEvents) {
                
            if (categoresEvents[event].type == 'category') {

                options.push(
                    {
                        label: `${categoresEvents[event].name}`, 
                        value: `${categoresEvents[event].name}`, 
                        emoji: categoresEvents[event].emoji
                    }
                );

            }

            else {

                options.push(
                    {
                        label: `${categoresEvents[event].name}`, 
                        value: `${categoresEvents[event].name}`, 
                        description: `${categoresEvents[event].miniDescription.slice(0, 99) || 'Отсутствует'}`,
                        emoji: categoresEvents[event].emoji
                    }
                );

            };

        };

        if (!options[0]) 
        return interaction.reply({
            ephemeral: true,
            embeds: [
                {
                    title: `${client.user.username} error`,
                    color: appearance.embed.errorColor,
                    description: `${member}, на **данный момент**, список **мероприятий** в ${client.user} пуст, повторите **попытку** позже`,
                    thumbnail: { url: memberAvatar } 
                }
            ], 
            components: [ 
    
            ]
        }).catch(() => {});


        if (users[member.id].ActiveEvent)
        return interaction.reply({
            ephemeral: true,
            embeds: [
                {
                    title: `${client.user.username} error`,
                    color: appearance.embed.errorColor,
                    description: `${member}, у Вас уже **создано** мероприятие **${guilds[users[member.id].ActiveEvent].Event.name}** [__(перейти)__](${guilds[users[member.id].ActiveEvent].ManageLink}), Вы **не можете** создать новое`,
                    thumbnail: { url: memberAvatar } 
                }
            ], 
            components: [ 
    
            ]
        }).catch(() => {});


        if (args.название) {

            for (const pickCategory in appearance.custom.Events.list) for (const pickEvent in appearance.custom.Events.list[pickCategory].list) eventsListMass.push({ name: appearance.custom.Events.list[pickCategory].list[pickEvent].name, event: appearance.custom.Events.list[pickCategory].list[pickEvent] });

            eventsListMass = eventsListMass.filter(event => event.name.toLowerCase().includes(args.название.toLowerCase()));
            eventsListMass = eventsListMass.slice(0, 10);

            interaction.deferReply().catch(() => {});

            if (!eventsListMass[0]) {
                
                setTimeout(() => {

                    interaction.editReply({
                        embeds: [
                            {
                                title: `${client.user.username} error`,
                                color: appearance.embed.errorColor,
                                description: `${member}, мероприятие (${args.название.toLowerCase()}) **не было найдено**, проверьте название и **повторите** попытку`,
                                thumbnail: { url: memberAvatar } 
                            }
                        ], 
                        components: [ 
                
                        ]
                    }).catch(() => {});

                }, 1300);

                return;

            };

            await createEvent (eventsListMass[0].event, interaction, true);

        }

        else {

            firstOptions = options;

            interaction.reply({
                embeds: [
                    {
                        title: `${client.user.username} create`,
                        color: appearance.embed.color,
                        description: `${member}, выберите категорию из **${firstOptions.length}** доступных\nМероприятия данного сервера — **${guild.name}**`,
                        thumbnail: { url: memberAvatar } 
                    }
                ], 
                components: [ 
                    {
                        type: 1,
                        components: [
                            {
                                type: 3,
                                customId: 'eventSelect', 
                                placeholder: 'Выберите категорию мероприятий', 
                                minValues: 1, 
                                maxValues: 1, 
                                options: options
                            }
                        ]
                    }
                ]
            }).catch(() => {});

        };

        let lastInt = Date.now() / 1000;
        const cheackLastInt = setInterval(async () => {
    
            if (lastInt + 100 - Date.now() / 1000 < 0) {
              
                await targetMessageEditComponents(interaction);
                return clearInterval(cheackLastInt);
    
            };
    
        }, 2000); 
    
        const collectorConponents = await channel.createMessageComponentCollector();
        collectorConponents.on('collect', async i => {
    
            if (!i.message.interaction || i.message.interaction.id !== interaction.id) return;
    
            lastInt = Date.now() / 1000;
            if (actions[i.customId] && actions[i.customId].all == true) return await actions[i.customId].actions[0](i);
    
            if (!i.member || i.member.id !== member.id) return;
    
            switch (i.customId) { 

                case 'back': {

                    options = [];
                    const categoresEvents = appearance.custom.Events.list;
                    parameters.eventsCategory = categoresEvents;
            
                    if (users[member.id].ActiveEvent)
                    return i.update({
                        ephemeral: true,
                        embeds: [
                            {
                                title: `${client.user.username} error`,
                                color: appearance.embed.errorColor,
                                description: `${member}, у Вас уже **создано** мероприятие, \nВы **не можете** создать новое`,
                                thumbnail: { url: memberAvatar } 
                            }
                        ], 
                        components: [ 
                
                        ]
                    }).catch(() => {});
            
                    i.update({
                        embeds: [
                            {
                                title: `${client.user.username} create`,
                                color: appearance.embed.color,
                                description: `${member}, выберите категорию из **${firstOptions.length}** доступных\nМероприятия данного сервера — **${guild.name}**`,
                                thumbnail: { url: memberAvatar } 
                            }
                        ], 
                        components: [ 
                            {
                                type: 1,
                                components: [
                                    {
                                        type: 3,
                                        customId: 'eventSelect', 
                                        placeholder: 'Выберите категорию мероприятий', 
                                        minValues: 1, 
                                        maxValues: 1, 
                                        options: firstOptions
                                    }
                                ]
                            }
                        ]
                    }).catch(() => {});

                    break;

                }

                case 'eventSelect': { 

                    if (parameters.eventsCategory[i.values[0]] && parameters.eventsCategory[i.values[0]].type == 'category') {

                        options = [];
                        let lastCategory = parameters.eventsCategory;
                        parameters.eventsCategory = parameters.eventsCategory[i.values[0]].list;
                
                        for (const event in parameters.eventsCategory) {
                
                            if (parameters.eventsCategory[event].type == 'category') {

                                options.push(
                                    {
                                        label: `${parameters.eventsCategory[event].name}`, 
                                        value: `${parameters.eventsCategory[event].name}`, 
                                        emoji: parameters.eventsCategory[event].emoji
                                    }
                                );

                            }

                            else {

                                options.push(
                                    {
                                        label: `${parameters.eventsCategory[event].name}`, 
                                        value: `${parameters.eventsCategory[event].name}`, 
                                        description: `${parameters.eventsCategory[event].miniDescription.slice(0, 99) || 'Отсутствует'}`,
                                        emoji: parameters.eventsCategory[event].emoji
                                    }
                                );

                            };
                
                        };
                
                        
                        if (!options[0]) 
                        return i.update({
                            embeds: [
                                {
                                    title: `${client.user.username} error`,
                                    color: appearance.embed.errorColor,
                                    description: `${member}, на **данный момент**, список **мероприятий** в кетегории **${pickCategory}** пуст`,
                                    thumbnail: { url: memberAvatar } 
                                }
                            ]
                        }).catch(() => {});


                        if (users[member.id].ActiveEvent)
                        return i.update({
                            ephemeral: true,
                            embeds: [
                                {
                                    title: `${client.user.username} error`,
                                    color: appearance.embed.errorColor,
                                    description: `${member}, у Вас уже **создано** мероприятие, \nВы **не можете** создать новое`,
                                    thumbnail: { url: memberAvatar } 
                                }
                            ], 
                            components: [ 
                    
                            ]
                        }).catch(() => {});

                        i.update({
                            embeds: [
                                {
                                    title: `${client.user.username} create`,
                                    color: appearance.embed.color,
                                    description: `${member}, Выберите **нужное** мероприятия для запуска\nВы находитесь в категории — ${lastCategory[i.values[0]].emoji} **${lastCategory[i.values[0]].name}**`,
                                    thumbnail: { url: memberAvatar } 
                                }
                            ], 
                            components: [ 
                                {
                                    type: 1,
                                    components: [
                                        {
                                            type: 3,
                                            customId: 'eventSelect', 
                                            placeholder: `${lastCategory[i.values[0]].emoji ? `${lastCategory[i.values[0]].emoji}・${lastCategory[i.values[0]].name} — Выберите мероприятие (${options.length})` : `${lastCategory[i.values[0]].name} — Выберите мероприятие (${options.length})`}`, 
                                            minValues: 1, 
                                            maxValues: 1, 
                                            options: options
                                        }
                                    ]
                                },
                                {
                                    type: 1,
                                    components: [
                                        {
                                            type: 2, 
                                            style: appearance.buttons_menu.Default.style,
                                            label: 'Назад', 
                                            customId: 'back'
                                        }
                                    ]
                                }
                            ]
                        }).catch(() => {});
                        
                        return;

                    };
                    
                    const pickEvents = i.values[0];

                    const eventsCategory = parameters.eventsCategory[pickEvents] ? parameters.eventsCategory : eventsListMass.find(event => event.name == pickEvents)[0];
                    const eventOfCategory = eventsCategory[pickEvents] ? eventsCategory[pickEvents] : eventsCategory;

                    parameters.eventOfCategory = eventOfCategory;
                    
                    if (!eventOfCategory.access) 
                    return i.update({
                        embeds: [
                            {
                                title: `${client.user.username} error`,
                                color: appearance.embed.errorColor,
                                description: `${member}, выбранное Вами мероприятие **недоступно**`,
                                thumbnail: { url: memberAvatar } 
                            }
                        ]
                    }).catch(() => {});
                    

                    if (users[member.id].ActiveEvent)
                    return i.update({
                        ephemeral: true,
                        embeds: [
                            {
                                title: `${client.user.username} error`,
                                color: appearance.embed.errorColor,
                                description: `${member}, у Вас уже **создано** мероприятие, Вы **не можете** создать новое`,
                                thumbnail: { url: memberAvatar } 
                            }
                        ], 
                        components: [ 
                
                        ]
                    }).catch(() => {});

                    await createEvent (eventOfCategory, i);

                    break;
                    
                }

            };
    
        });

    };

    if (argsF.subcommand == 'delete') {

        async function errorNoEventsOwnerMessage (One) {

            const memberAvater = await getAvatar(One);

            return {
                ephemeral: true,
                embeds: [
                    {
                        title: `${client.user.username} error`,
                        color: appearance.embed.errorColor,
                        description: `${One}, для того, чтобы **использовать** данную команду Вам **необходимо** быть ведущим** данного** мероприятия`,
                        thumbnail: { url: memberAvater }
                    }
                ], 
                components: [
                    
                ]
            };

        };

        if (await checkingForRoles (interaction, appearance.roles.Events.access) !== true) return;
        if (args.мероприятие) {
                
            if (!guilds[args.мероприятие] || guilds[args.мероприятие].deleted)
            return interaction.reply({
                ephemeral: true,
                embeds: [
                    {
                        title: `${client.user.username} error`,
                        color: appearance.embed.errorColor,
                        description: `${member}, Вы выбрали **несуществуещее** мероприятие \`${args.мероприятие}\`, **повторите** попытку еще раз`,
                        thumbnail: { url: memberAvatar } 
                    }
                ], 
                components: [ 
        
                ]
            }).catch(() => {});

            if (guilds[args.мероприятие].Owner !== member.id) await checkingForRoles (interaction, appearance.roles.Events.fullAccess);
    
            const EventId = args.мероприятие;
            const eventOfCategory = guilds[EventId].Event;
    
            interaction.reply({
                content: `${member}`,
                embeds: [
                    {
                        title: `${client.user.username} delete`,
                        color: appearance.embed.color,
                        description: `${member}, Вы **уверены**, что хотите завершить мероприятие **${guilds[EventId].Event.name}** [__(перейти)__](${guilds[EventId].ManageLink}), ведущий мероприятия <@${guilds[EventId].Owner}>`,
                        thumbnail: { url: memberAvatar } 
                    }
                ], 
                components: [ 
                    {
                        type: 1,
                        components: [
                            {
                                type: 2, 
                                style: 3, 
                                customId: 'yesDeleteEvent', 
                                label: 'Завершить мероприятие', 
                                emoji: appearance.emoji.True
                            }
                        ]
                    }
                ]
            }).catch(() => {});
    
    
            let lastInt = Date.now() / 1000;
            const cheackLastInt = setInterval(async () => {
        
                if (lastInt + 100 - Date.now() / 1000 < 0) {
                  
                    await targetMessageEditComponents(interaction);
                    return clearInterval(cheackLastInt);
        
                };
        
            }, 2000); 
        
            const collectorConponents = await channel.createMessageComponentCollector();
            collectorConponents.on('collect', async i => {
        
                if (!i.message.interaction || i.message.interaction.id !== interaction.id) return;
        
                lastInt = Date.now() / 1000;
                if (actions[i.customId] && actions[i.customId].all == true) return await actions[i.customId].actions[0](i);
        
                if (!i.member|| i.member.id !== member.id) return;
        
                switch (i.customId) { 
    
                    case 'yesDeleteEvent': { 
    
                        if (guilds[EventId].deleted)
                        return i.update({
                            content: ' ',
                            embeds: [
                                {
                                    title: `${client.user.username} error`,
                                    color: appearance.embed.errorColor,
                                    description: `${member}, данное мероприятие **уже** завершено`,
                                    thumbnail: { url: memberAvatar } 
                                }
                            ], 
                            components: [ 
                    
                            ]
                        }).catch(() => {});
        
                        if (guilds[EventId].Event.type == 'event') {
    
                            guilds[EventId].deleted = true;
                            
                            let pick = 0;
                            let channelsEvent = [guilds[EventId].channels.voice, guilds[EventId].channels.info, guilds[EventId].channels.manage, guilds[EventId].channels.category];
                            setInterval(async () => {
        
                                if (pick == channelsEvent.length) return;
                                let channelOfDelte = await guild.channels.fetch(channelsEvent[pick]).catch(() => {});
                                if (channelOfDelte) channelOfDelte.delete().catch(() => {});
                                pick++;
        
                            }, 1000);
        
                            if (guilds[EventId].message.log) {
    
                                const channelOfLog = await guild.channels.fetch(guilds[EventId].message.log.channelId);
                                const messageOfChannelLog = await channelOfLog.messages.fetch(guilds[EventId].message.log.id);
                                
                                const memberOfOwnerEvent = await guild.members.fetch(guilds[EventId].Owner).catch(() => {});

                                if (messageOfChannelLog) messageOfChannelLog.edit({  
                                    content: `<t:${Math.floor(Date.now()/1000)}:f>`,
                                    embeds: [
                                        {
                                            author: { name: 'Мероприятие завершено' },
                                            title: `${client.user.username + ' logs'}`,
                                            color: appearance.embed.color,
                                            description: `Создано: <t:${Math.floor(guilds[EventId].Created)}:f>\nЗавершено: <t:${Math.floor(Date.now()/1000)}:f>`,
                                            fields: [
                                                {
                                                    name: `${appearance.embed.dot || appearance.emoji.Dot}Создавал:`,
                                                    value: `・${memberOfOwnerEvent}\n・${memberOfOwnerEvent.id}`,  
                                                    inline: true
                                                },
                                                {
                                                    name: `${appearance.embed.dot || appearance.emoji.Dot}Завершил:`,
                                                    value: `・${member}\n・${member.id}`,  
                                                    inline: true
                                                },
                                                {
                                                    name: `${appearance.embed.dot || appearance.emoji.Dot}Мероприятие:`,
                                                    value: `\`\`\`${eventOfCategory.name}\`\`\``,
                                                    inline: false
                                                }
                                            ],
                                            footer: { text: memberOfOwnerEvent ? `・Ведущий: ${memberOfOwnerEvent.displayName}` : '・Ведущий: Отсутствует' },
                                            thumbnail: memberOfOwnerEvent ? { url: await getAvatar(memberOfOwnerEvent) } : {},
                                        }
                                    ],
                                    components: [

                                    ]
                                }).catch(() => {});
    
                            };
        
                            guilds[guild.id].Events.Active = guilds[guild.id].Events.Active.filter((n) => { return n != EventId });
                            users[guilds[EventId].Owner].ActiveEvent = false;
    
                        };
    
                        if (guilds[EventId].Event.type == 'close') {
    
                            if (guilds[EventId].started) {
                                                
                                guilds[EventId].deleted = true;
                                
                                let pick = 0;
                                let pick2 = 0;
                                let channelsEvent = [guilds[EventId].channels.voice, guilds[EventId].channels.record, guilds[EventId].channels.manage, guilds[EventId].channels.category];
                                let newChannelsEvent = guilds[EventId].newChannels;
                                setInterval(async () => {
    
                                    if (pick == channelsEvent.length) return;
                                    let channelOfDelte = await guild.channels.fetch(channelsEvent[pick]).catch(() => {});
                                    if (channelOfDelte) channelOfDelte.delete().catch(() => {});
                                    pick++;
    
                                }, 1000);
    
                                setInterval(async () => {
    
                                    if (pick2 == newChannelsEvent.length) return;
                                    newChannelsEvent[pick2].delete().catch(() => {});
                                    pick2++;
    
                                }, 1000);
        
                                if (guilds[EventId].message.log) {
        
                                    const channelOfLog = await guild.channels.fetch(guilds[EventId].message.log.channelId);
                                    const messageOfChannelLog = await channelOfLog.messages.fetch(guilds[EventId].message.log.id);
                                    
                                    const memberOfOwnerEvent = await guild.members.fetch(guilds[EventId].Owner).catch(() => {});
    
                                    if (messageOfChannelLog) messageOfChannelLog.edit({  
                                        content: `<t:${Math.floor(Date.now()/1000)}:f>`,
                                        embeds: [
                                            {
                                                author: { name: 'Мероприятие завершено' },
                                                title: `${client.user.username + ' logs'}`,
                                                color: appearance.embed.color,
                                                description: `Создано: <t:${Math.floor(guilds[EventId].Created)}:f>\nЗавершено: <t:${Math.floor(Date.now()/1000)}:f>`,
                                                fields: [
                                                    {
                                                        name: `${appearance.embed.dot || appearance.emoji.Dot}Создавал:`,
                                                        value: `・${memberOfOwnerEvent}\n・${memberOfOwnerEvent.id}`,  
                                                        inline: true
                                                    },
                                                    {
                                                        name: `${appearance.embed.dot || appearance.emoji.Dot}Завершил:`,
                                                        value: `・${member}\n・${member.id}`,  
                                                        inline: true
                                                    },
                                                    {
                                                        name: `${appearance.embed.dot || appearance.emoji.Dot}Мероприятие:`,
                                                        value: `\`\`\`${eventOfCategory.name}\`\`\``,
                                                        inline: false
                                                    }
                                                ],
                                                footer: { text: memberOfOwnerEvent ? `・Ведущий: ${memberOfOwnerEvent.displayName}` : '・Ведущий: Отсутствует' },
                                                thumbnail: memberOfOwnerEvent ? { url: await getAvatar(memberOfOwnerEvent) } : {},
                                            }
                                        ],
                                        components: [
                                            
                                        ]
                                    }).catch(() => {});
        
                                };
    
                                guilds[guild.id].Events.Active = guilds[guild.id].Events.Active.filter((n) => { return n != EventId });
                                users[guilds[EventId].Owner].ActiveEvent = false;
    
                            }
                           
                            else {
    
                                guilds[EventId].deleted = true;
    
                                
                                let pick = 0;
                                let channelsEvent = [guilds[EventId].channels.voice, guilds[EventId].channels.record, guilds[EventId].channels.manage, guilds[EventId].channels.category];
                                setInterval(async () => {
    
                                    if (pick == channelsEvent.length) return;
                                    let channelOfDelte = await guild.channels.fetch(channelsEvent[pick]).catch(() => {});
                                    if (channelOfDelte) channelOfDelte.delete().catch(() => {});
                                    pick++;
    
                                }, 1000);
        
                                if (guilds[EventId].message.log) {
        
                                    const channelOfLog = await guild.channels.fetch(guilds[EventId].message.log.channelId);
                                    const messageOfChannelLog = await channelOfLog.messages.fetch(guilds[EventId].message.log.id);
                                    
                                    const memberOfOwnerEvent = await guild.members.fetch(guilds[EventId].Owner).catch(() => {});
    
                                    if (messageOfChannelLog) messageOfChannelLog.edit({  
                                        content: `<t:${Math.floor(Date.now()/1000)}:f>`,
                                        embeds: [
                                            {
                                                author: { name: 'Мероприятие завершено' },
                                                title: `${client.user.username + ' logs'}`,
                                                color: appearance.embed.color,
                                                description: `Создано: <t:${Math.floor(guilds[EventId].Created)}:f>\nЗавершено: <t:${Math.floor(Date.now()/1000)}:f>`,
                                                fields: [
                                                    {
                                                        name: `${appearance.embed.dot || appearance.emoji.Dot}Создавал:`,
                                                        value: `・${memberOfOwnerEvent}\n・${memberOfOwnerEvent.id}`,  
                                                        inline: true
                                                    },
                                                    {
                                                        name: `${appearance.embed.dot || appearance.emoji.Dot}Завершил:`,
                                                        value: `・${member}\n・${member.id}`,  
                                                        inline: true
                                                    },
                                                    {
                                                        name: `${appearance.embed.dot || appearance.emoji.Dot}Мероприятие:`,
                                                        value: `\`\`\`${eventOfCategory.name}\`\`\``,
                                                        inline: false
                                                    }
                                                ],
                                                footer: { text: memberOfOwnerEvent ? `・Ведущий: ${memberOfOwnerEvent.displayName}` : '・Ведущий: Отсутствует' },
                                                thumbnail: memberOfOwnerEvent ? { url: await getAvatar(memberOfOwnerEvent) } : {},
                                            }
                                        ],
                                        components: [
                                            
                                        ]
                                    }).catch(() => {});
        
                                };
    
                                guilds[guild.id].Events.Active = guilds[guild.id].Events.Active.filter((n) => { return n != EventId });
                                users[guilds[EventId].Owner].ActiveEvent = false;
    
                            };
    
                        };
    
                        if (guilds[EventId].Event.type == 'mafia') {
    
                            if (guilds[EventId].started) {
                                                
                                guilds[EventId].deleted = true;
                                
                                let pick = 0;
                                let pick2 = 0;
                                let channelsEvent = [guilds[EventId].channels.voice, guilds[EventId].channels.record, guilds[EventId].channels.manage, guilds[EventId].channels.category];
                                setInterval(async () => {
    
                                    if (pick == channelsEvent.length) return;
                                    let channelOfDelte = await guild.channels.fetch(channelsEvent[pick]).catch(() => {});
                                    if (channelOfDelte) channelOfDelte.delete().catch(() => {});
                                    pick++;
    
                                }, 1000);

                                if (guilds[EventId].game && guilds[EventId].servers) {
                                    
                                    for (n=0; n < guilds[EventId].servers.length; n++) guilds[EventId].servers[n].guild.delete().catch(() => {});
                    
                                };
        
                                if (guilds[EventId].message.log) {
        
                                    const channelOfLog = await guild.channels.fetch(guilds[EventId].message.log.channelId);
                                    const messageOfChannelLog = await channelOfLog.messages.fetch(guilds[EventId].message.log.id);
                                    
                                    const memberOfOwnerEvent = await guild.members.fetch(guilds[EventId].Owner).catch(() => {});
    
                                    if (messageOfChannelLog) messageOfChannelLog.edit({  
                                        content: `<t:${Math.floor(Date.now()/1000)}:f>`,
                                        embeds: [
                                            {
                                                author: { name: 'Мероприятие завершено' },
                                                title: `${client.user.username + ' logs'}`,
                                                color: appearance.embed.color,
                                                description: `Создано: <t:${Math.floor(guilds[EventId].Created)}:f>\nЗавершено: <t:${Math.floor(Date.now()/1000)}:f>`,
                                                fields: [
                                                    {
                                                        name: `${appearance.embed.dot || appearance.emoji.Dot}Создавал:`,
                                                        value: `・${memberOfOwnerEvent}\n・${memberOfOwnerEvent.id}`,  
                                                        inline: true
                                                    },
                                                    {
                                                        name: `${appearance.embed.dot || appearance.emoji.Dot}Завершил:`,
                                                        value: `・${member}\n・${member.id}`,  
                                                        inline: true
                                                    },
                                                    {
                                                        name: `${appearance.embed.dot || appearance.emoji.Dot}Мероприятие:`,
                                                        value: `\`\`\`${eventOfCategory.name}\`\`\``,
                                                        inline: false
                                                    }
                                                ],
                                                footer: { text: memberOfOwnerEvent ? `・Ведущий: ${memberOfOwnerEvent.displayName}` : '・Ведущий: Отсутствует' },
                                                thumbnail: memberOfOwnerEvent ? { url: await getAvatar(memberOfOwnerEvent) } : {},
                                            }
                                        ],
                                        components: [
                                            
                                        ]
                                    }).catch(() => {});
        
                                };
    
                                guilds[guild.id].Events.Active = guilds[guild.id].Events.Active.filter((n) => { return n != EventId });
                                users[guilds[EventId].Owner].ActiveEvent = false;
    
                            }
                           
                            else {
    
                                guilds[EventId].deleted = true;
    
                                
                                let pick = 0;
                                let channelsEvent = [guilds[EventId].channels.voice, guilds[EventId].channels.record, guilds[EventId].channels.manage, guilds[EventId].channels.category];
                                setInterval(async () => {
    
                                    if (pick == channelsEvent.length) return;
                                    let channelOfDelte = await guild.channels.fetch(channelsEvent[pick]).catch(() => {});
                                    if (channelOfDelte) channelOfDelte.delete().catch(() => {});
                                    pick++;
    
                                }, 1000);
        
                                if (guilds[EventId].message.log) {
        
                                    const channelOfLog = await guild.channels.fetch(guilds[EventId].message.log.channelId);
                                    const messageOfChannelLog = await channelOfLog.messages.fetch(guilds[EventId].message.log.id);
                                    
                                    const memberOfOwnerEvent = await guild.members.fetch(guilds[EventId].Owner).catch(() => {});
    
                                    if (messageOfChannelLog) messageOfChannelLog.edit({  
                                        content: `<t:${Math.floor(Date.now()/1000)}:f>`,
                                        embeds: [
                                            {
                                                author: { name: 'Мероприятие завершено' },
                                                title: `${client.user.username + ' logs'}`,
                                                color: appearance.embed.color,
                                                description: `Создано: <t:${Math.floor(guilds[EventId].Created)}:f>\nЗавершено: <t:${Math.floor(Date.now()/1000)}:f>`,
                                                fields: [
                                                    {
                                                        name: `${appearance.embed.dot || appearance.emoji.Dot}Создавал:`,
                                                        value: `・${memberOfOwnerEvent}\n・${memberOfOwnerEvent.id}`,  
                                                        inline: true
                                                    },
                                                    {
                                                        name: `${appearance.embed.dot || appearance.emoji.Dot}Завершил:`,
                                                        value: `・${member}\n・${member.id}`,  
                                                        inline: true
                                                    },
                                                    {
                                                        name: `${appearance.embed.dot || appearance.emoji.Dot}Мероприятие:`,
                                                        value: `\`\`\`${eventOfCategory.name}\`\`\``,
                                                        inline: false
                                                    }
                                                ],
                                                footer: { text: memberOfOwnerEvent ? `・Ведущий: ${memberOfOwnerEvent.displayName}` : '・Ведущий: Отсутствует' },
                                                thumbnail: memberOfOwnerEvent ? { url: await getAvatar(memberOfOwnerEvent) } : {},
                                            }
                                        ],
                                        components: [
                                            
                                        ]
                                    }).catch(() => {});
        
                                };
    
                                guilds[guild.id].Events.Active = guilds[guild.id].Events.Active.filter((n) => { return n != EventId });
                                users[guilds[EventId].Owner].ActiveEvent = false;
    
                            };
    
                        };
    
                        i.update({
                            content: ' ',
                            embeds: [
                                {
                                    title: `${client.user.username} delete`,
                                    color: appearance.embed.color,
                                    description: `${member}, Вы **успешно** завершили мероприятие <@${guilds[EventId].Owner}> **${eventOfCategory.name}**, <t:${Math.floor(Date.now()/1000)}:f>`,
                                    thumbnail: { url: memberAvatar } 
                                }
                            ], 
                            components: [ 
                    
                            ]
                        }).catch(() => {});
    
                        break;
    
                    }
    
                };
        
            });

        }
        
        else {

            if (!users[member.id].ActiveEvent)
            return interaction.reply({
                ephemeral: true,
                embeds: [
                    {
                        title: `${client.user.username} error`,
                        color: appearance.embed.errorColor,
                        description: `${member}, у Вас нет **активных** мероприятий на **${guild.name}**`,
                        thumbnail: { url: memberAvatar } 
                    }
                ], 
                components: [ 
        
                ]
            }).catch(() => {});
    
    
            const EventId = users[member.id].ActiveEvent;
            const eventOfCategory = guilds[EventId].Event;
    
            interaction.reply({
                content: `${member}`,
                embeds: [
                    {
                        title: `${client.user.username} delete`,
                        color: appearance.embed.color,
                        description: `${member}, Вы **уверены**, что хотите завершить мероприятие **${guilds[users[member.id].ActiveEvent].Event.name}**, [__(перейти)__](${guilds[users[member.id].ActiveEvent].ManageLink})`,
                        thumbnail: { url: memberAvatar } 
                    }
                ], 
                components: [ 
                    {
                        type: 1,
                        components: [
                            {
                                type: 2, 
                                style: 3, 
                                customId: 'yesDeleteEvent', 
                                label: 'Завершить мероприятие', 
                                emoji: appearance.emoji.True
                            }
                        ]
                    }
                ]
            }).catch(() => {});
    
    
            let lastInt = Date.now() / 1000;
            const cheackLastInt = setInterval(async () => {
        
                if (lastInt + 100 - Date.now() / 1000 < 0) {
                  
                    await targetMessageEditComponents(interaction);
                    return clearInterval(cheackLastInt);
        
                };
        
            }, 2000); 
        
            const collectorConponents = await channel.createMessageComponentCollector();
            collectorConponents.on('collect', async i => {
        
                if (!i.message.interaction || i.message.interaction.id !== interaction.id) return;
        
                lastInt = Date.now() / 1000;
                if (actions[i.customId] && actions[i.customId].all == true) return await actions[i.customId].actions[0](i);
        
                if (!i.member|| i.member.id !== member.id) return;
        
                switch (i.customId) { 
    
                    case 'yesDeleteEvent': { 
    
                        if(guilds[EventId].Owner !== i.member.id) return i.update(await errorNoEventsOwnerMessage (i.member));
                        if (guilds[EventId].deleted)
                        return i.update({
                            content: ' ',
                            embeds: [
                                {
                                    title: `${client.user.username} error`,
                                    color: appearance.embed.errorColor,
                                    description: `${member}, данное мероприятие **уже** завершено`,
                                    thumbnail: { url: memberAvatar } 
                                }
                            ], 
                            components: [ 
                    
                            ]
                        }).catch(() => {});
        
                        if (guilds[EventId].Event.type == 'event') {
    
                            guilds[EventId].deleted = true;
                            
                            let pick = 0;
                            let channelsEvent = [guilds[EventId].channels.voice, guilds[EventId].channels.info, guilds[EventId].channels.manage, guilds[EventId].channels.category];
                            setInterval(async () => {
        
                                if (pick == channelsEvent.length) return;
                                let channelOfDelte = await guild.channels.fetch(channelsEvent[pick]).catch(() => {});
                                if (channelOfDelte) channelOfDelte.delete().catch(() => {});
                                pick++;
        
                            }, 1000);
        
                            if (guilds[EventId].message.log) {
    
                                const channelOfLog = await guild.channels.fetch(guilds[EventId].message.log.channelId);
                                const messageOfChannelLog = await channelOfLog.messages.fetch(guilds[EventId].message.log.id);
    
                                if (messageOfChannelLog) messageOfChannelLog.edit({  
                                    content: `<t:${Math.floor(Date.now()/1000)}:f>`,
                                    embeds: [
                                        {
                                            author: { name: 'Мероприятие завершено (командой)' },
                                            title: `${client.user.username + ' logs'}`,
                                            color: appearance.embed.color,
                                            description: `Создано: <t:${Math.floor(guilds[EventId].Created)}:f>\nЗавершено: <t:${Math.floor(Date.now()/1000)}:f>`,
                                            fields: [
                                                {
                                                    name: `${appearance.embed.dot || appearance.emoji.Dot}Завершил:`,
                                                    value: `・${member}\n・${member.id}`,  
                                                    inline: true
                                                },
                                                {
                                                    name: `${appearance.embed.dot || appearance.emoji.Dot}Мероприятие:`,
                                                    value: `\`\`\`${eventOfCategory.name}\`\`\``,
                                                    inline: true
                                                }
                                            ],
                                            footer: { text: `・Ведущий: ${member.displayName}` },
                                            thumbnail: { url: memberAvatar },
                                        }
                                    ],
                                    components: [

                                    ]
                                }).catch(() => {});
    
                            };
        
        
                            users[guilds[EventId].Owner].Events.unshift(
                                {
        
                                    EventId: EventId,
                                    Ended: Date.now () / 1000,
                                    Created: guilds[EventId].Created,
        
                                    message: {
        
                                        log: guilds[EventId].message.log,
                                        announcement: guilds[EventId].message.announcement
        
                                    }
                                    
                                }
                            );
        
                            guilds[guild.id].Events.Active = guilds[guild.id].Events.Active.filter((n) => { return n != EventId });
                            users[member.id].ActiveEvent = false;
        
                        };
    
                        if (guilds[EventId].Event.type == 'close') {
    
                            if (guilds[EventId].started) {
                                                
                                guilds[EventId].deleted = true;
                                
                                let pick = 0;
                                let pick2 = 0;
                                let channelsEvent = [guilds[EventId].channels.voice, guilds[EventId].channels.record, guilds[EventId].channels.manage, guilds[EventId].channels.category];
                                let newChannelsEvent = guilds[EventId].newChannels;
                                setInterval(async () => {
    
                                    if (pick == channelsEvent.length) return;
                                    let channelOfDelte = await guild.channels.fetch(channelsEvent[pick]).catch(() => {});
                                    if (channelOfDelte) channelOfDelte.delete().catch(() => {});
                                    pick++;
    
                                }, 1000);
    
                                setInterval(async () => {
    
                                    if (pick2 == newChannelsEvent.length) return;
                                    newChannelsEvent[pick2].delete().catch(() => {});
                                    pick2++;
    
                                }, 1000);
        
                                if (guilds[EventId].message.log) {
        
                                    const channelOfLog = await guild.channels.fetch(guilds[EventId].message.log.channelId);
                                    const messageOfChannelLog = await channelOfLog.messages.fetch(guilds[EventId].message.log.id);
        
                                    if (messageOfChannelLog) messageOfChannelLog.edit({  
                                        content: `<t:${Math.floor(Date.now()/1000)}:f>`,
                                        embeds: [
                                            {
                                                author: { name: 'Мероприятие завершено (командой)' },
                                                title: `${client.user.username + ' logs'}`,
                                                color: appearance.embed.color,
                                                description: `Создано: <t:${Math.floor(guilds[EventId].Created)}:f>\nЗавершено: <t:${Math.floor(Date.now()/1000)}:f>`,
                                                fields: [
                                                    {
                                                        name: `${appearance.embed.dot || appearance.emoji.Dot}Завершил:`,
                                                        value: `・${member}\n・${member.id}`,  
                                                        inline: true
                                                    },
                                                    {
                                                        name: `${appearance.embed.dot || appearance.emoji.Dot}Мероприятие:`,
                                                        value: `\`\`\`${eventOfCategory.name}\`\`\``,
                                                        inline: true
                                                    }
                                                ],
                                                footer: { text: `・Ведущий: ${member.displayName}` },
                                                thumbnail: { url: memberAvatar },
                                            }
                                        ],
                                        components: [
                                            
                                        ]
                                    }).catch(() => {});
        
                                };
    
    
                                users[guilds[EventId].Owner].Events.unshift(
                                    {
            
                                        EventId: EventId,
                                        Ended: Date.now () / 1000,
                                        Created: guilds[EventId].Created,
            
                                        message: {
    
                                            log: guilds[EventId].message.log,
                                            announcement: guilds[EventId].message.announcement
            
                                        }
                                        
                                    }
                                );
    
                                guilds[guild.id].Events.Active = guilds[guild.id].Events.Active.filter((n) => { return n != EventId });
                                users[member.id].ActiveEvent = false;
    
                            }
                           
                            else {
    
                                guilds[EventId].deleted = true;
    
                                
                                let pick = 0;
                                let channelsEvent = [guilds[EventId].channels.voice, guilds[EventId].channels.record, guilds[EventId].channels.manage, guilds[EventId].channels.category];
                                setInterval(async () => {
    
                                    if (pick == channelsEvent.length) return;
                                    let channelOfDelte = await guild.channels.fetch(channelsEvent[pick]).catch(() => {});
                                    if (channelOfDelte) channelOfDelte.delete().catch(() => {});
                                    pick++;
    
                                }, 1000);
    
    
                                if (guilds[EventId].message.log) {
    
                                    const channelOfLog = await guild.channels.fetch(guilds[EventId].message.log.channelId);
                                    const messageOfChannelLog = await channelOfLog.messages.fetch(guilds[EventId].message.log.id);
        
                                    if (messageOfChannelLog) messageOfChannelLog.edit({  
                                        content: `<t:${Math.floor(Date.now()/1000)}:f>`,
                                        embeds: [
                                            {
                                                author: { name: 'Мероприятие завершено (командой)' },
                                                title: `${client.user.username + ' logs'}`,
                                                color: appearance.embed.color,
                                                description: `Создано: <t:${Math.floor(guilds[EventId].Created)}:f>\nЗавершено: <t:${Math.floor(Date.now()/1000)}:f>`,
                                                fields: [
                                                    {
                                                        name: `${appearance.embed.dot || appearance.emoji.Dot}Завершил:`,
                                                        value: `・${member}\n・${member.id}`,  
                                                        inline: true
                                                    },
                                                    {
                                                        name: `${appearance.embed.dot || appearance.emoji.Dot}Мероприятие:`,
                                                        value: `\`\`\`${eventOfCategory.name}\`\`\``,
                                                        inline: true
                                                    }
                                                ],
                                                footer: { text: `・Ведущий: ${member.displayName}` },
                                                thumbnail: { url: memberAvatar },
                                            }
                                        ],
                                        components: [
                                            
                                        ]
                                    }).catch(() => {});
        
                                };
    
    
                                users[guilds[EventId].Owner].Events.unshift(
                                    {
            
                                        EventId: EventId,
                                        Ended: Date.now () / 1000,
                                        Created: guilds[EventId].Created,
            
                                        message: {
    
                                            log: guilds[EventId].message.log,
                                            announcement: guilds[EventId].message.announcement
            
                                        }
                                        
                                    }
                                );
    
                                guilds[guild.id].Events.Active = guilds[guild.id].Events.Active.filter((n) => { return n != EventId });
                                users[member.id].ActiveEvent = false;
    
                            };
    
                        };
    
                        if (guilds[EventId].Event.type == 'mafia') {
    
                            if (guilds[EventId].started) {
                                                
                                guilds[EventId].deleted = true;
                                
                                let pick = 0;
                                let pick2 = 0;
                                let channelsEvent = [guilds[EventId].channels.voice, guilds[EventId].channels.record, guilds[EventId].channels.manage, guilds[EventId].channels.category];
                                setInterval(async () => {
    
                                    if (pick == channelsEvent.length) return;
                                    let channelOfDelte = await guild.channels.fetch(channelsEvent[pick]).catch(() => {});
                                    if (channelOfDelte) channelOfDelte.delete().catch(() => {});
                                    pick++;
    
                                }, 1000);
    
                                if (guilds[EventId].game && guilds[EventId].servers) {
                                    
                                    for (n=0; n < guilds[EventId].servers.length; n++) guilds[EventId].servers[n].guild.delete().catch(() => {});
                    
                                };
        
    
                                if (guilds[EventId].message.log) {
        
                                    const channelOfLog = await guild.channels.fetch(guilds[EventId].message.log.channelId);
                                    const messageOfChannelLog = await channelOfLog.messages.fetch(guilds[EventId].message.log.id);
        
                                    if (messageOfChannelLog) messageOfChannelLog.edit({  
                                        content: `<t:${Math.floor(Date.now()/1000)}:f>`,
                                        embeds: [
                                            {
                                                author: { name: 'Мероприятие завершено (командой)' },
                                                title: `${client.user.username + ' logs'}`,
                                                color: appearance.embed.color,
                                                description: `Создано: <t:${Math.floor(guilds[EventId].Created)}:f>\nЗавершено: <t:${Math.floor(Date.now()/1000)}:f>`,
                                                fields: [
                                                    {
                                                        name: `${appearance.embed.dot || appearance.emoji.Dot}Завершил:`,
                                                        value: `・${member}\n・${member.id}`,  
                                                        inline: true
                                                    },
                                                    {
                                                        name: `${appearance.embed.dot || appearance.emoji.Dot}Мероприятие:`,
                                                        value: `\`\`\`${eventOfCategory.name}\`\`\``,
                                                        inline: true
                                                    }
                                                ],
                                                footer: { text: `・Ведущий: ${member.displayName}` },
                                                thumbnail: { url: memberAvatar },
                                            }
                                        ],
                                        components: [
                                            
                                        ]
                                    }).catch(() => {});
        
                                };
    
    
                                users[guilds[EventId].Owner].Events.unshift(
                                    {
            
                                        EventId: EventId,
                                        Ended: Date.now () / 1000,
                                        Created: guilds[EventId].Created,
            
                                        message: {
    
                                            log: guilds[EventId].message.log,
                                            announcement: guilds[EventId].message.announcement
            
                                        }
                                        
                                    }
                                );
    
                                guilds[guild.id].Events.Active = guilds[guild.id].Events.Active.filter((n) => { return n != EventId });
                                users[member.id].ActiveEvent = false;
    
                            }
                           
                            else {
    
                                guilds[EventId].deleted = true;
    
                                
                                let pick = 0;
                                let channelsEvent = [guilds[EventId].channels.voice, guilds[EventId].channels.record, guilds[EventId].channels.manage, guilds[EventId].channels.category];
                                setInterval(async () => {
    
                                    if (pick == channelsEvent.length) return;
                                    let channelOfDelte = await guild.channels.fetch(channelsEvent[pick]).catch(() => {});
                                    if (channelOfDelte) channelOfDelte.delete().catch(() => {});
                                    pick++;
    
                                }, 1000);
    
        
                                if (guilds[EventId].message.log) {
    
                                    const channelOfLog = await guild.channels.fetch(guilds[EventId].message.log.channelId);
                                    const messageOfChannelLog = await channelOfLog.messages.fetch(guilds[EventId].message.log.id);
    
                                    if (messageOfChannelLog) messageOfChannelLog.edit({  
                                        content: `<t:${Math.floor(Date.now()/1000)}:f>`,
                                        embeds: [
                                            {
                                                author: { name: 'Мероприятие завершено (командой)' },
                                                title: `${client.user.username + ' logs'}`,
                                                color: appearance.embed.color,
                                                description: `Создано: <t:${Math.floor(guilds[EventId].Created)}:f>\nЗавершено: <t:${Math.floor(Date.now()/1000)}:f>`,
                                                fields: [
                                                    {
                                                        name: `${appearance.embed.dot || appearance.emoji.Dot}Завершил:`,
                                                        value: `・${member}\n・${member.id}`,  
                                                        inline: true
                                                    },
                                                    {
                                                        name: `${appearance.embed.dot || appearance.emoji.Dot}Мероприятие:`,
                                                        value: `\`\`\`${eventOfCategory.name}\`\`\``,
                                                        inline: true
                                                    }
                                                ],
                                                footer: { text: `・Ведущий: ${member.displayName}` },
                                                thumbnail: { url: memberAvatar },
                                            }
                                        ],
                                        components: [
                                            
                                        ]
                                    }).catch(() => {});
    
                                };
    
    
                                users[guilds[EventId].Owner].Events.unshift(
                                    {
            
                                        EventId: EventId,
                                        Ended: Date.now () / 1000,
                                        Created: guilds[EventId].Created,
            
                                        message: {
    
                                            log: guilds[EventId].message.log,
                                            announcement: guilds[EventId].message.announcement
            
                                        }
                                        
                                    }
                                );
    
                                guilds[guild.id].Events.Active = guilds[guild.id].Events.Active.filter((n) => { return n != EventId });
                                users[member.id].ActiveEvent = false;
    
                            };
    
                        };
    
                        i.update({
                            content: ' ',
                            embeds: [
                                {
                                    title: `${client.user.username} delete`,
                                    color: appearance.embed.color,
                                    description: `${member}, Вы **успешно** завершили мероприятие **${eventOfCategory.name}**, мероприятие завершено <t:${Math.floor(Date.now()/1000)}:f>`,
                                    thumbnail: { url: memberAvatar } 
                                }
                            ], 
                            components: [ 
                    
                            ]
                        }).catch(() => {});
    
                        break;
    
                    }
    
                };
        
            });

        };

    };

    if (argsF.subcommand == 'transfer') {

        const pickMember = await guild.members.fetch(args.пользователь).catch(() => {});
            
        if (!pickMember) 
        return interaction.reply({
            ephemeral: true,  
            embeds: [
                {
                    title: `${client.user.username} error`,
                    color: appearance.embed.errorColor,
                    description: `${member}, пользователь \`${args.пользователь}\` не найден`,                          
                    thumbnail: { url: await getAvatar (pickMember) } 
                }
            ]
        }).catch(() => {});

        async function errorNoEventsOwnerMessage (One) {

            const memberAvater = await getAvatar(One);

            return {
                ephemeral: true,
                embeds: [
                    {
                        title: `${client.user.username} error`,
                        color: appearance.embed.errorColor,
                        description: `${One}, для того, чтобы **использовать** данную команду Вам **необходимо** быть ведущим** данного** мероприятия`,
                        thumbnail: { url: memberAvater }
                    }
                ], 
                components: [
                    
                ]
            };

        };

        if (await checkingForRoles (interaction, appearance.roles.Events.access) !== true) return;
        checkingForAvailability (db, pickMember);

        let rolesTxt = '';
        let memberIfRole = false;
        const memberRoles = pickMember._roles;
    
        for (let a = 0; a < memberRoles.length; a++) if(appearance.roles.Events.access.includes(memberRoles[a])) memberIfRole = true;
        for (let a = 0; a < appearance.roles.Events.access.length; a++) rolesTxt += ` <@&${appearance.roles.Events.access[a]}>`;
            
        if (!memberIfRole) 
        return interaction.reply({
            ephemeral: true,  
            embeds: [
                {
                    title: `${client.user.username} error`,
                    color: appearance.embed.errorColor,
                    description: `${member}, у ${pickMember} нет **ролей**:${rolesTxt}`,                          
                    thumbnail: { url: await getAvatar (pickMember) } 
                }
            ]
        }).catch(() => {});

        if (pickMember.user.bot) 
        return interaction.reply({
            ephemeral: true,  
            embeds: [
                {
                    title: `${client.user.username} error`,
                    color: appearance.embed.errorColor,
                    description: `${member}, Вы выбрали **недоступного** бота ${pickMember}, выберите **другого** пользователя`,                          
                    thumbnail: { url: await getAvatar (pickMember) } 
                }
            ]
        }).catch(() => {});

        if (args.мероприятие) {
                
            if (!guilds[args.мероприятие] || guilds[args.мероприятие].deleted)
            return interaction.reply({
                ephemeral: true,
                embeds: [
                    {
                        title: `${client.user.username} error`,
                        color: appearance.embed.errorColor,
                        description: `${member}, Вы выбрали **несуществуещее** мероприятие \`${args.мероприятие}\`, **повторите** попытку еще раз`,
                        thumbnail: { url: memberAvatar } 
                    }
                ], 
                components: [ 
        
                ]
            }).catch(() => {});

            const EventId = args.мероприятие;
            const eventOfCategory = guilds[EventId].Event;

            if (guilds[EventId].Owner !== member.id) await checkingForRoles (interaction, appearance.roles.Events.fullAccess);
            if (guilds[EventId].Owner == pickMember.id) 
            return interaction.reply({
                ephemeral: true,
                embeds: [
                    {
                        title: `${client.user.username} error`,
                        color: appearance.embed.errorColor,
                        description: `${member}, Вы **выбрали** пользователя, которому **нельзя** передать мероприятие **${guilds[EventId].Event.name}**`,
                        thumbnail: { url: memberAvatar } 
                    }
                ], 
                components: [ 
        
                ]
            }).catch(() => {});

            if (users[pickMember.id].ActiveEvent)
            return interaction.reply({
                content: ' ',
                embeds: [
                    {
                        title: `${client.user.username} error`,
                        color: appearance.embed.errorColor,
                        description: `${member}, у ${pickMember} уже есть **активное** мероприятие на **${guild.name}**`,
                        thumbnail: { url: memberAvatar } 
                    }
                ], 
                components: [ 
        
                ]
            }).catch(() => {});
    
    
            interaction.reply({
                content: `${member}`,
                embeds: [
                    {
                        title: `${client.user.username} transfer`,
                        color: appearance.embed.color,
                        description: `${member}, Вы **уверены**, что хотите передать мероприятие <@${guilds[EventId].Owner}> **${guilds[EventId].Event.name}** ведущему ${pickMember}`,
                        thumbnail: { url: memberAvatar } 
                    }
                ], 
                components: [ 
                    {
                        type: 1,
                        components: [
                            {
                                type: 2, 
                                style: 1, 
                                customId: 'yesTransferEvent', 
                                label: 'Передать мероприятие', 
                                emoji: appearance.emoji.Repeat
                            }
                        ]
                    }
                ]
            }).catch(() => {});
    
    
            let lastInt = Date.now() / 1000;
            const cheackLastInt = setInterval(async () => {
        
                if (lastInt + 100 - Date.now() / 1000 < 0) {
                  
                    await targetMessageEditComponents(interaction);
                    return clearInterval(cheackLastInt);
        
                };
        
            }, 2000); 
        
            const collectorConponents = await channel.createMessageComponentCollector();
            collectorConponents.on('collect', async i => {
        
                if (!i.message.interaction || i.message.interaction.id !== interaction.id) return;
        
                lastInt = Date.now() / 1000;
                if (actions[i.customId] && actions[i.customId].all == true) return await actions[i.customId].actions[0](i);
        
                if (!i.member|| i.member.id !== member.id) return;
        
                switch (i.customId) { 
    
                    case 'yesTransferEvent': { 
    
                        if (guilds[EventId].deleted)
                        return i.update({
                            content: ' ',
                            embeds: [
                                {
                                    title: `${client.user.username} error`,
                                    color: appearance.embed.errorColor,
                                    description: `${member}, данное мероприятие **уже** завершено`,
                                    thumbnail: { url: memberAvatar } 
                                }
                            ], 
                            components: [ 
                    
                            ]
                        }).catch(() => {});

                        if (users[pickMember.id].ActiveEvent)
                        return i.update({
                            content: ' ',
                            embeds: [
                                {
                                    title: `${client.user.username} error`,
                                    color: appearance.embed.errorColor,
                                    description: `${member}, у ${pickMember} уже есть **активное** мероприятие на **${guild.name}**`,
                                    thumbnail: { url: memberAvatar } 
                                }
                            ], 
                            components: [ 
                    
                            ]
                        }).catch(() => {});

                        const lOld = guilds[EventId].Owner;
                        if (guilds[EventId].Event.type == 'event') {

                            const eventVoiceChannel = await guild.channels.fetch(guilds[EventId].channels.voice).catch(() => {});
                            if (eventVoiceChannel) {
                                
                                eventVoiceChannel.permissionOverwrites.edit(guilds[EventId].Owner, { MuteMembers: false, MoveMembers: false }).catch(() => {});
                                eventVoiceChannel.permissionOverwrites.edit(pickMember.id, { MuteMembers: true, MoveMembers: true }).catch(() => {});

                            };

                            const eventManageChannel = await guild.channels.fetch(guilds[EventId].channels.manage).catch(() => {});
                            if (eventManageChannel) {

                                eventManageChannel.permissionOverwrites.edit(guilds[EventId].Owner, { ViewChannel: false, SendMessages: false }).catch(() => {});
                                eventManageChannel.permissionOverwrites.edit(pickMember.id, { ViewChannel: true, SendMessages: false }).catch(() => {});

                            };

                            const eventInfoChannel = await guild.channels.fetch(guilds[EventId].channels.info).catch(() => {});
                            if (eventInfoChannel) {

                                eventInfoChannel.permissionOverwrites.edit(guilds[EventId].Owner, { ManageMessages: false }).catch(() => {});
                                eventInfoChannel.permissionOverwrites.edit(pickMember.id, { ViewChannel: true, ManageMessages: true, SendMessages: true }).catch(() => {});

                            };

                            const eventCategory = await guild.channels.fetch(guilds[EventId].channels.category).catch(() => {});
                            if (eventCategory) eventCategory.setName(`${eventOfCategory.name}・${pickMember.displayName}`);
                            
                            users[guilds[EventId].Owner].ActiveEvent = false;
                            users[pickMember.id].ActiveEvent = EventId;
                            guilds[EventId].Owner = pickMember.id;
                            
                            if (guilds[EventId].message.log) {
    
                                const channelOfLog = await guild.channels.fetch(guilds[EventId].message.log.channelId);
                                const messageOfChannelLog = await channelOfLog.messages.fetch(guilds[EventId].message.log.id);

                                if (messageOfChannelLog) messageOfChannelLog.reply({
                                    content: `<t:${Math.floor(Date.now()/1000)}:f>`,
                                    embeds: [
                                        {
                                            author: { name: 'Мероприятие передано (командой)' },
                                            title: `${client.user.username + ' logs'}`,
                                            color: appearance.embed.color,
                                            fields: [
                                                {
                                                    name: `${appearance.embed.dot || appearance.emoji.Dot}Старый ведущий:`,
                                                    value: `・<@${lOld}>\n・${lOld}`,  
                                                    inline: true
                                                },
                                                {
                                                    name: `${appearance.embed.dot || appearance.emoji.Dot}Новый ведущий:`,
                                                    value: `・${pickMember}\n・${pickMember.id}`,  
                                                    inline: true
                                                },
                                                {
                                                    name: `${appearance.embed.dot || appearance.emoji.Dot}Передал:`,
                                                    value: `・${member}\n・${member.id}`,  
                                                    inline: false
                                                },
                                                {
                                                    name: `${appearance.embed.dot || appearance.emoji.Dot}Канал:`,
                                                    value: `・${eventVoiceChannel ? eventVoiceChannel : 'Отсутствует'}\n・${eventVoiceChannel ? eventVoiceChannel.id : 'Отсутствует'}`,  
                                                    inline: true
                                                },
                                                {
                                                    name: `${appearance.embed.dot || appearance.emoji.Dot}Мероприятие:`,
                                                    value: `\`\`\`${eventOfCategory.name}\`\`\``,
                                                    inline: true
                                                }
                                            ],
                                            thumbnail: pickMember ? { url: await getAvatar(pickMember) } : {},
                                        }
                                    ],
                                    components: [
                                        
                                    ]
                                }).catch(() => {});
    
                            };  

                        };

                        if (guilds[EventId].Event.type == 'close') {

                            if (guilds[EventId].started) {

                                const eventVoiceChannel = await guild.channels.fetch(guilds[EventId].channels.voice).catch(() => {});
                                if (eventVoiceChannel) {
                                    
                                    eventVoiceChannel.permissionOverwrites.edit(guilds[EventId].Owner, { MuteMembers: false, MoveMembers: false }).catch(() => {});
                                    eventVoiceChannel.permissionOverwrites.edit(pickMember.id, { MuteMembers: true, MoveMembers: true }).catch(() => {});
    
                                };
    
                                const eventManageChannel = await guild.channels.fetch(guilds[EventId].channels.manage).catch(() => {});
                                if (eventManageChannel) {
    
                                    eventManageChannel.permissionOverwrites.edit(guilds[EventId].Owner, { ViewChannel: false, SendMessages: false }).catch(() => {});
                                    eventManageChannel.permissionOverwrites.edit(pickMember.id, { ViewChannel: true, SendMessages: false }).catch(() => {});
    
                                };
    
                                const eventIRecordChannel = await guild.channels.fetch(guilds[EventId].channels.record).catch(() => {});
                                if (eventIRecordChannel) {
    
                                    eventIRecordChannel.permissionOverwrites.edit(guilds[EventId].Owner, { ManageMessages: false, SendMessages: false }).catch(() => {});
                                    eventIRecordChannel.permissionOverwrites.edit(pickMember.id, { ViewChannel: true, ManageMessages: true, SendMessages: true }).catch(() => {});
    
                                };

                                let pick = 0;
                                let newChannelsEvent = guilds[EventId].newChannels;
                                for (pick = 0; pick < newChannelsEvent.length; pick++) {
    
                                    newChannelsEvent[pick].permissionOverwrites.edit(pickMember.id, { ViewChannel: true, Connect: true, MuteMembers: true, MoveMembers: true }).catch(() => {});
                                    newChannelsEvent[pick].permissionOverwrites.edit(lOld, { MuteMembers: false, MoveMembers: false }).catch(() => {});
    
                                };
    
                                const eventCategory = await guild.channels.fetch(guilds[EventId].channels.category).catch(() => {});
                                if (eventCategory) eventCategory.setName(`${eventOfCategory.name}・${pickMember.displayName}`);
                                
                                users[guilds[EventId].Owner].ActiveEvent = false;
                                users[pickMember.id].ActiveEvent = EventId;
                                guilds[EventId].Owner = pickMember.id;
                                
                                if (guilds[EventId].message.log) {
        
                                    const channelOfLog = await guild.channels.fetch(guilds[EventId].message.log.channelId);
                                    const messageOfChannelLog = await channelOfLog.messages.fetch(guilds[EventId].message.log.id);
    
                                    if (messageOfChannelLog) messageOfChannelLog.reply({
                                        content: `<t:${Math.floor(Date.now()/1000)}:f>`,  
                                        embeds: [
                                            {
                                                author: { name: 'Мероприятие передано (командой)' },
                                                title: `${client.user.username + ' logs'}`,
                                                color: appearance.embed.color,
                                                fields: [
                                                    {
                                                        name: `${appearance.embed.dot || appearance.emoji.Dot}Старый ведущий:`,
                                                        value: `・<@${lOld}>\n・${lOld}`,  
                                                        inline: true
                                                    },
                                                    {
                                                        name: `${appearance.embed.dot || appearance.emoji.Dot}Новый ведущий:`,
                                                        value: `・${pickMember}\n・${pickMember.id}`,  
                                                        inline: true
                                                    },
                                                    {
                                                        name: `${appearance.embed.dot || appearance.emoji.Dot}Передал:`,
                                                        value: `・${member}\n・${member.id}`,  
                                                        inline: false
                                                    },
                                                    {
                                                        name: `${appearance.embed.dot || appearance.emoji.Dot}Канал:`,
                                                        value: `・${eventVoiceChannel ? eventVoiceChannel : 'Отсутствует'}\n・${eventVoiceChannel ? eventVoiceChannel.id : 'Отсутствует'}`,  
                                                        inline: true
                                                    },
                                                    {
                                                        name: `${appearance.embed.dot || appearance.emoji.Dot}Мероприятие:`,
                                                        value: `\`\`\`${eventOfCategory.name}\`\`\``,
                                                        inline: true
                                                    }
                                                ],
                                                thumbnail: pickMember ? { url: await getAvatar(pickMember) } : {},
                                            }
                                        ],
                                        components: [
                                            
                                        ]
                                    }).catch(() => {});
        
                                };        

                            }

                            else {

                                const eventVoiceChannel = await guild.channels.fetch(guilds[EventId].channels.voice).catch(() => {});
                                if (eventVoiceChannel) {
                                    
                                    eventVoiceChannel.permissionOverwrites.edit(guilds[EventId].Owner, { MuteMembers: false, MoveMembers: false }).catch(() => {});
                                    eventVoiceChannel.permissionOverwrites.edit(pickMember.id, { MuteMembers: true, MoveMembers: true }).catch(() => {});
    
                                };
    
                                const eventManageChannel = await guild.channels.fetch(guilds[EventId].channels.manage).catch(() => {});
                                if (eventManageChannel) {
    
                                    eventManageChannel.permissionOverwrites.edit(guilds[EventId].Owner, { ViewChannel: false, SendMessages: false }).catch(() => {});
                                    eventManageChannel.permissionOverwrites.edit(pickMember.id, { ViewChannel: true, SendMessages: false }).catch(() => {});
    
                                };
    
                                const eventIRecordChannel = await guild.channels.fetch(guilds[EventId].channels.record).catch(() => {});
                                if (eventIRecordChannel) {
    
                                    eventIRecordChannel.permissionOverwrites.edit(guilds[EventId].Owner, { ManageMessages: false, SendMessages: false }).catch(() => {});
                                    eventIRecordChannel.permissionOverwrites.edit(pickMember.id, { ViewChannel: true, ManageMessages: true, SendMessages: true }).catch(() => {});
    
                                };
    
                                const eventCategory = await guild.channels.fetch(guilds[EventId].channels.category).catch(() => {});
                                if (eventCategory) eventCategory.setName(`${eventOfCategory.name}・${pickMember.displayName}`);
                                
                                users[guilds[EventId].Owner].ActiveEvent = false;
                                users[pickMember.id].ActiveEvent = EventId;
                                guilds[EventId].Owner = pickMember.id;
                                
                                if (guilds[EventId].message.log) {
        
                                    const channelOfLog = await guild.channels.fetch(guilds[EventId].message.log.channelId);
                                    const messageOfChannelLog = await channelOfLog.messages.fetch(guilds[EventId].message.log.id);
    
                                    if (messageOfChannelLog) messageOfChannelLog.reply({  
                                        content: `<t:${Math.floor(Date.now()/1000)}:f>`,
                                        embeds: [
                                            {
                                                author: { name: 'Мероприятие передано (командой)' },
                                                title: `${client.user.username + ' logs'}`,
                                                color: appearance.embed.color,
                                                fields: [
                                                    {
                                                        name: `${appearance.embed.dot || appearance.emoji.Dot}Старый ведущий:`,
                                                        value: `・<@${lOld}>\n・${lOld}`,  
                                                        inline: true
                                                    },
                                                    {
                                                        name: `${appearance.embed.dot || appearance.emoji.Dot}Новый ведущий:`,
                                                        value: `・${pickMember}\n・${pickMember.id}`,  
                                                        inline: true
                                                    },
                                                    {
                                                        name: `${appearance.embed.dot || appearance.emoji.Dot}Передал:`,
                                                        value: `・${member}\n・${member.id}`,  
                                                        inline: false
                                                    },
                                                    {
                                                        name: `${appearance.embed.dot || appearance.emoji.Dot}Канал:`,
                                                        value: `・${eventVoiceChannel ? eventVoiceChannel : 'Отсутствует'}\n・${eventVoiceChannel ? eventVoiceChannel.id : 'Отсутствует'}`,  
                                                        inline: true
                                                    },
                                                    {
                                                        name: `${appearance.embed.dot || appearance.emoji.Dot}Мероприятие:`,
                                                        value: `\`\`\`${eventOfCategory.name}\`\`\``,
                                                        inline: true
                                                    }
                                                ],
                                                thumbnail: pickMember ? { url: await getAvatar(pickMember) } : {},
                                            }
                                        ],
                                        components: [
                                            
                                        ]
                                    }).catch(() => {});
        
                                };  

                            };

                        };

                        if (guilds[EventId].Event.type == 'mafia') {

                            if (guilds[EventId].started) {

                                game = guilds[EventId].game;

                                let contentOfMessageLeading = '';
                                let componetsOfMessageLeading = [];
                                for (const pickMember in game.members) {

                                    const pickMemberOfGameMembers = game.members[pickMember];
                                    const fetchPickMember = await guild.members.fetch(pickMemberOfGameMembers.id).catch(() => {});

                                    contentOfMessageLeading += `\`${pickMemberOfGameMembers.number}\` ${pickMemberOfGameMembers.role.emoji} ${fetchPickMember}\n`;
                                    
                                };

                                for (n=0; n < game.servers.length; n++) {

                                    let randomChannel = {};
                                    for (const channel of game.servers[n].guild.channels.cache) randomChannel = await game.servers[n].guild.channels.fetch(channel[0]);

                                    if (!componetsOfMessageLeading[0] || componetsOfMessageLeading[componetsOfMessageLeading.length-1].components.length == 5) 
                                    componetsOfMessageLeading.push(
                                        {
                                            type: 1,
                                            components: []
                                        }
                                    );

                                    const inviteOfRandomChannel = await randomChannel.createInvite();
                                    componetsOfMessageLeading[componetsOfMessageLeading.length-1].components.push(
                                        {
                                            type: 2, 
                                            label: `Перейти на сервер: ${game.servers[n].guild.name}`, 
                                            url: inviteOfRandomChannel.url,
                                            style: 5
                                        }
                                    );

                                };

                                pickMember.setNickname('! Ведущий').catch(() => {});
                                pickMember.send({  
                                    embeds: [
                                        {
                                            title: `Роли: ${eventOfCategory.name}`,
                                            color: appearance.embed.color,
                                            description: `${contentOfMessageLeading}`
                                        }
                                    ],
                                    components: componetsOfMessageLeading
                                }).catch(() => {});

                                game.message.roles.delete().catch(() => {});
                                for (n=0; n < game.servers.length; n++) {

                                    game.servers[n].guild.members.fetch().catch(() => {});
                                    const fetchPickMemberOfPickServer = await game.servers[n].guild.members.fetch(guilds[EventId].Owner).catch(() => {});
                                    if (fetchPickMemberOfPickServer) fetchPickMemberOfPickServer.kick().catch(() => {});

                                };

                                const memberOfEventOwner = await guild.members.fetch(guilds[EventId].Owner).catch(() => {});
                                if (memberOfEventOwner) memberOfEventOwner.setNickname('').catch(() => {});

                                const eventVoiceChannel = await guild.channels.fetch(guilds[EventId].channels.voice).catch(() => {});
                                if (eventVoiceChannel) {
                                    
                                    eventVoiceChannel.permissionOverwrites.edit(guilds[EventId].Owner, { MuteMembers: false, MoveMembers: false }).catch(() => {});
                                    eventVoiceChannel.permissionOverwrites.edit(pickMember.id, { MuteMembers: true, MoveMembers: true }).catch(() => {});
    
                                };
    
                                const eventManageChannel = await guild.channels.fetch(guilds[EventId].channels.manage).catch(() => {});
                                if (eventManageChannel) {
    
                                    eventManageChannel.permissionOverwrites.edit(guilds[EventId].Owner, { ViewChannel: false, SendMessages: false }).catch(() => {});
                                    eventManageChannel.permissionOverwrites.edit(pickMember.id, { ViewChannel: true, SendMessages: false }).catch(() => {});
    
                                };
    
                                const eventIRecordChannel = await guild.channels.fetch(guilds[EventId].channels.record).catch(() => {});
                                if (eventIRecordChannel) {
    
                                    eventIRecordChannel.permissionOverwrites.edit(guilds[EventId].Owner, { ManageMessages: false, SendMessages: false }).catch(() => {});
                                    eventIRecordChannel.permissionOverwrites.edit(pickMember.id, { ViewChannel: true, ManageMessages: true, SendMessages: true }).catch(() => {});
    
                                };
    
                                const eventCategory = await guild.channels.fetch(guilds[EventId].channels.category).catch(() => {});
                                if (eventCategory) eventCategory.setName(`${eventOfCategory.name}・${pickMember.displayName}`);
                                
                                users[guilds[EventId].Owner].ActiveEvent = false;
                                users[pickMember.id].ActiveEvent = EventId;
                                guilds[EventId].Owner = pickMember.id;
                                
                                if (guilds[EventId].message.log) {
        
                                    const channelOfLog = await guild.channels.fetch(guilds[EventId].message.log.channelId);
                                    const messageOfChannelLog = await channelOfLog.messages.fetch(guilds[EventId].message.log.id);
    
                                    if (messageOfChannelLog) messageOfChannelLog.reply({  
                                        content: `<t:${Math.floor(Date.now()/1000)}:f>`,
                                        embeds: [
                                            {
                                                author: { name: 'Мероприятие передано (командой)' },
                                                title: `${client.user.username + ' logs'}`,
                                                color: appearance.embed.color,
                                                fields: [
                                                    {
                                                        name: `${appearance.embed.dot || appearance.emoji.Dot}Старый ведущий:`,
                                                        value: `・<@${lOld}>\n・${lOld}`,  
                                                        inline: true
                                                    },
                                                    {
                                                        name: `${appearance.embed.dot || appearance.emoji.Dot}Новый ведущий:`,
                                                        value: `・${pickMember}\n・${pickMember.id}`,  
                                                        inline: true
                                                    },
                                                    {
                                                        name: `${appearance.embed.dot || appearance.emoji.Dot}Передал:`,
                                                        value: `・${member}\n・${member.id}`,  
                                                        inline: false
                                                    },
                                                    {
                                                        name: `${appearance.embed.dot || appearance.emoji.Dot}Канал:`,
                                                        value: `・${eventVoiceChannel ? eventVoiceChannel : 'Отсутствует'}\n・${eventVoiceChannel ? eventVoiceChannel.id : 'Отсутствует'}`,  
                                                        inline: true
                                                    },
                                                    {
                                                        name: `${appearance.embed.dot || appearance.emoji.Dot}Мероприятие:`,
                                                        value: `\`\`\`${eventOfCategory.name}\`\`\``,
                                                        inline: true
                                                    }
                                                ],
                                                thumbnail: pickMember ? { url: await getAvatar(pickMember) } : {},
                                            }
                                        ],
                                        components: [
                                            
                                        ]
                                    }).catch(() => {});
        
                                };
                                            
                            }

                            else {

                                const eventVoiceChannel = await guild.channels.fetch(guilds[EventId].channels.voice).catch(() => {});
                                if (eventVoiceChannel) {
                                    
                                    eventVoiceChannel.permissionOverwrites.edit(guilds[EventId].Owner, { MuteMembers: false, MoveMembers: false }).catch(() => {});
                                    eventVoiceChannel.permissionOverwrites.edit(pickMember.id, { MuteMembers: true, MoveMembers: true }).catch(() => {});
    
                                };
    
                                const eventManageChannel = await guild.channels.fetch(guilds[EventId].channels.manage).catch(() => {});
                                if (eventManageChannel) {
    
                                    eventManageChannel.permissionOverwrites.edit(guilds[EventId].Owner, { ViewChannel: false, SendMessages: false }).catch(() => {});
                                    eventManageChannel.permissionOverwrites.edit(pickMember.id, { ViewChannel: true, SendMessages: false }).catch(() => {});
    
                                };
    
                                const eventIRecordChannel = await guild.channels.fetch(guilds[EventId].channels.record).catch(() => {});
                                if (eventIRecordChannel) {
    
                                    eventIRecordChannel.permissionOverwrites.edit(guilds[EventId].Owner, { ManageMessages: false, SendMessages: false }).catch(() => {});
                                    eventIRecordChannel.permissionOverwrites.edit(pickMember.id, { ViewChannel: true, ManageMessages: true, SendMessages: true }).catch(() => {});
    
                                };
    
                                const eventCategory = await guild.channels.fetch(guilds[EventId].channels.category).catch(() => {});
                                if (eventCategory) eventCategory.setName(`${eventOfCategory.name}・${pickMember.displayName}`);
                                
                                users[guilds[EventId].Owner].ActiveEvent = false;
                                users[pickMember.id].ActiveEvent = EventId;
                                guilds[EventId].Owner = pickMember.id;
                                
                                if (guilds[EventId].message.log) {
        
                                    const channelOfLog = await guild.channels.fetch(guilds[EventId].message.log.channelId);
                                    const messageOfChannelLog = await channelOfLog.messages.fetch(guilds[EventId].message.log.id);
    
                                    if (messageOfChannelLog) messageOfChannelLog.reply({  
                                        content: `<t:${Math.floor(Date.now()/1000)}:f>`,
                                        embeds: [
                                            {
                                                author: { name: 'Мероприятие передано (командой)' },
                                                title: `${client.user.username + ' logs'}`,
                                                color: appearance.embed.color,
                                                fields: [
                                                    {
                                                        name: `${appearance.embed.dot || appearance.emoji.Dot}Старый ведущий:`,
                                                        value: `・<@${lOld}>\n・${lOld}`,  
                                                        inline: true
                                                    },
                                                    {
                                                        name: `${appearance.embed.dot || appearance.emoji.Dot}Новый ведущий:`,
                                                        value: `・${pickMember}\n・${pickMember.id}`,  
                                                        inline: true
                                                    },
                                                    {
                                                        name: `${appearance.embed.dot || appearance.emoji.Dot}Передал:`,
                                                        value: `・${member}\n・${member.id}`,  
                                                        inline: false
                                                    },
                                                    {
                                                        name: `${appearance.embed.dot || appearance.emoji.Dot}Канал:`,
                                                        value: `・${eventVoiceChannel ? eventVoiceChannel : 'Отсутствует'}\n・${eventVoiceChannel ? eventVoiceChannel.id : 'Отсутствует'}`,  
                                                        inline: true
                                                    },
                                                    {
                                                        name: `${appearance.embed.dot || appearance.emoji.Dot}Мероприятие:`,
                                                        value: `\`\`\`${eventOfCategory.name}\`\`\``,
                                                        inline: true
                                                    }
                                                ],
                                                thumbnail: pickMember ? { url: await getAvatar(pickMember) } : {},
                                            }
                                        ],
                                        components: [
                                            
                                        ]
                                    }).catch(() => {});
        
                                };  

                            };

                        };

                        i.update({
                            content: ' ',
                            embeds: [
                                {
                                    title: `${client.user.username} transfer`,
                                    color: appearance.embed.color,
                                    description: `${member}, Вы успешно **передали** мероприятие <@${lOld}> **${guilds[EventId].Event.name}** ведущему ${pickMember}`,
                                    thumbnail: { url: memberAvatar } 
                                }
                            ], 
                            components: [ 

                            ]
                        }).catch(() => {});
    
                        break;
    
                    }
    
                };
        
            });

        }
        
        else {

            if (!users[member.id].ActiveEvent)
            return interaction.reply({
                ephemeral: true,
                embeds: [
                    {
                        title: `${client.user.username} error`,
                        color: appearance.embed.errorColor,
                        description: `${member}, у Вас нет **активных** мероприятий на **${guild.name}**`,
                        thumbnail: { url: memberAvatar } 
                    }
                ], 
                components: [ 
        
                ]
            }).catch(() => {});
    
    
            const EventId = users[member.id].ActiveEvent;
            const eventOfCategory = guilds[EventId].Event;


            if (guilds[EventId].Owner == pickMember.id)
            return interaction.reply({
                ephemeral: true,
                embeds: [
                    {
                        title: `${client.user.username} error`,
                        color: appearance.embed.errorColor,
                        description: `${member}, Вы **выбрали** пользователя, которому **нельзя** передать мероприятие **${guilds[EventId].Event.name}**`,
                        thumbnail: { url: memberAvatar } 
                    }
                ], 
                components: [ 
        
                ]
            }).catch(() => {});

            if (users[pickMember.id].ActiveEvent)
            return interaction.reply({
                ephemeral: true,
                embeds: [
                    {
                        title: `${client.user.username} error`,
                        color: appearance.embed.errorColor,
                        description: `${member}, у ${pickMember} уже есть **активное** мероприятие на **${guild.name}**`,
                        thumbnail: { url: memberAvatar } 
                    }
                ], 
                components: [ 
        
                ]
            }).catch(() => {});


            interaction.reply({
                content: `${member}`,
                embeds: [
                    {
                        title: `${client.user.username} transfer`,
                        color: appearance.embed.color,
                        description: `${member}, Вы **уверены**, что хотите передать мероприятие <@${guilds[EventId].Owner}> **${guilds[EventId].Event.name}** ведущему ${pickMember}`,
                        thumbnail: { url: memberAvatar } 
                    }
                ], 
                components: [ 
                    {
                        type: 1,
                        components: [
                            {
                                type: 2, 
                                style: 1, 
                                customId: 'yesTransferEvent', 
                                label: 'Передать мероприятие', 
                                emoji: appearance.emoji.Repeat
                            }
                        ]
                    }
                ]
            }).catch(() => {});
    
    
            let lastInt = Date.now() / 1000;
            const cheackLastInt = setInterval(async () => {
        
                if (lastInt + 100 - Date.now() / 1000 < 0) {
                  
                    await targetMessageEditComponents(interaction);
                    return clearInterval(cheackLastInt);
        
                };
        
            }, 2000); 
        
            const collectorConponents = await channel.createMessageComponentCollector();
            collectorConponents.on('collect', async i => {
        
                if (!i.message.interaction || i.message.interaction.id !== interaction.id) return;
        
                lastInt = Date.now() / 1000;
                if (actions[i.customId] && actions[i.customId].all == true) return await actions[i.customId].actions[0](i);
        
                if (!i.member|| i.member.id !== member.id) return;
        
                switch (i.customId) { 
    
                    case 'yesTransferEvent': { 
    
                        if(guilds[EventId].Owner !== i.member.id) return i.update(await errorNoEventsOwnerMessage (i.member));
                        if (guilds[EventId].deleted)
                        return i.update({
                            embeds: [
                                {
                                    title: `${client.user.username} error`,
                                    color: appearance.embed.errorColor,
                                    description: `${member}, данное мероприятие **уже** завершено`,
                                    thumbnail: { url: memberAvatar } 
                                }
                            ], 
                            components: [ 
                    
                            ]
                        }).catch(() => {});

                        if (users[pickMember.id].ActiveEvent)
                        return i.update({
                            ephemeral: true,
                            embeds: [
                                {
                                    title: `${client.user.username} error`,
                                    color: appearance.embed.errorColor,
                                    description: `${member}, у ${pickMember} уже есть **активное** мероприятие на **${guild.name}**`,
                                    thumbnail: { url: memberAvatar } 
                                }
                            ], 
                            components: [ 
                    
                            ]
                        }).catch(() => {});

                        const lOld = guilds[EventId].Owner;
                        if (guilds[EventId].Event.type == 'event') {

                            const eventVoiceChannel = await guild.channels.fetch(guilds[EventId].channels.voice).catch(() => {});
                            if (eventVoiceChannel) {
                                
                                eventVoiceChannel.permissionOverwrites.edit(guilds[EventId].Owner, { MuteMembers: false, MoveMembers: false }).catch(() => {});
                                eventVoiceChannel.permissionOverwrites.edit(pickMember.id, { MuteMembers: true, MoveMembers: true }).catch(() => {});

                            };

                            const eventManageChannel = await guild.channels.fetch(guilds[EventId].channels.manage).catch(() => {});
                            if (eventManageChannel) {

                                eventManageChannel.permissionOverwrites.edit(guilds[EventId].Owner, { ViewChannel: false, SendMessages: false }).catch(() => {});
                                eventManageChannel.permissionOverwrites.edit(pickMember.id, { ViewChannel: true, SendMessages: false }).catch(() => {});

                            };

                            const eventInfoChannel = await guild.channels.fetch(guilds[EventId].channels.info).catch(() => {});
                            if (eventInfoChannel) {

                                eventInfoChannel.permissionOverwrites.edit(guilds[EventId].Owner, { ViewChannel: false, ManageMessages: false }).catch(() => {});
                                eventInfoChannel.permissionOverwrites.edit(pickMember.id, { ViewChannel: true, ManageMessages: true, SendMessages: true }).catch(() => {});

                            };

                            const eventCategory = await guild.channels.fetch(guilds[EventId].channels.category).catch(() => {});
                            if (eventCategory) eventCategory.setName(`${eventOfCategory.name}・${pickMember.displayName}`);
                            
                            users[guilds[EventId].Owner].ActiveEvent = false;
                            users[pickMember.id].ActiveEvent = EventId;
                            guilds[EventId].Owner = pickMember.id;
                            
                            if (guilds[EventId].message.log) {
    
                                const channelOfLog = await guild.channels.fetch(guilds[EventId].message.log.channelId);
                                const messageOfChannelLog = await channelOfLog.messages.fetch(guilds[EventId].message.log.id);

                                if (messageOfChannelLog) messageOfChannelLog.reply({  
                                    content: `<t:${Math.floor(Date.now()/1000)}:f>`,
                                    embeds: [
                                        {
                                            author: { name: 'Мероприятие передано (командой)' },
                                            title: `${client.user.username + ' logs'}`,
                                            color: appearance.embed.color,
                                            fields: [
                                                {
                                                    name: `${appearance.embed.dot || appearance.emoji.Dot}Старый ведущий:`,
                                                    value: `・<@${lOld}>\n・${lOld}`,  
                                                    inline: true
                                                },
                                                {
                                                    name: `${appearance.embed.dot || appearance.emoji.Dot}Новый ведущий:`,
                                                    value: `・${pickMember}\n・${pickMember.id}`,  
                                                    inline: true
                                                },
                                                {
                                                    name: `${appearance.embed.dot || appearance.emoji.Dot}Передал:`,
                                                    value: `・${member}\n・${member.id}`,  
                                                    inline: false
                                                },
                                                {
                                                    name: `${appearance.embed.dot || appearance.emoji.Dot}Канал:`,
                                                    value: `・${eventVoiceChannel ? eventVoiceChannel : 'Отсутствует'}\n・${eventVoiceChannel ? eventVoiceChannel.id : 'Отсутствует'}`,  
                                                    inline: true
                                                },
                                                {
                                                    name: `${appearance.embed.dot || appearance.emoji.Dot}Мероприятие:`,
                                                    value: `\`\`\`${eventOfCategory.name}\`\`\``,
                                                    inline: true
                                                }
                                            ],
                                            thumbnail: pickMember ? { url: await getAvatar(pickMember) } : {},
                                        }
                                    ],
                                    components: [
                                        
                                    ]
                                }).catch(() => {});
    
                            };  

                        };

                        if (guilds[EventId].Event.type == 'close') {

                            if (guilds[EventId].started) {

                                const eventVoiceChannel = await guild.channels.fetch(guilds[EventId].channels.voice).catch(() => {});
                                if (eventVoiceChannel) {
                                    
                                    eventVoiceChannel.permissionOverwrites.edit(guilds[EventId].Owner, { MuteMembers: false, MoveMembers: false }).catch(() => {});
                                    eventVoiceChannel.permissionOverwrites.edit(pickMember.id, { MuteMembers: true, MoveMembers: true }).catch(() => {});
    
                                };
    
                                const eventManageChannel = await guild.channels.fetch(guilds[EventId].channels.manage).catch(() => {});
                                if (eventManageChannel) {
    
                                    eventManageChannel.permissionOverwrites.edit(guilds[EventId].Owner, { ViewChannel: false, SendMessages: false }).catch(() => {});
                                    eventManageChannel.permissionOverwrites.edit(pickMember.id, { ViewChannel: true, SendMessages: false }).catch(() => {});
    
                                };
    
                                const eventIRecordChannel = await guild.channels.fetch(guilds[EventId].channels.record).catch(() => {});
                                if (eventIRecordChannel) {
    
                                    eventIRecordChannel.permissionOverwrites.edit(guilds[EventId].Owner, { ManageMessages: false, SendMessages: false }).catch(() => {});
                                    eventIRecordChannel.permissionOverwrites.edit(pickMember.id, { ViewChannel: true, ManageMessages: true, SendMessages: true }).catch(() => {});
    
                                };

                                let pick = 0;
                                let newChannelsEvent = guilds[EventId].newChannels;
                                for (pick = 0; pick < newChannelsEvent.length; pick++) {
    
                                    newChannelsEvent[pick].permissionOverwrites.edit(pickMember.id, { ViewChannel: true, Connect: true, MuteMembers: true, MoveMembers: true }).catch(() => {});
                                    newChannelsEvent[pick].permissionOverwrites.edit(lOld, { MuteMembers: false, MoveMembers: false }).catch(() => {});
    
                                };
    
                                const eventCategory = await guild.channels.fetch(guilds[EventId].channels.category).catch(() => {});
                                if (eventCategory) eventCategory.setName(`${eventOfCategory.name}・${pickMember.displayName}`);
                                
                                users[guilds[EventId].Owner].ActiveEvent = false;
                                users[pickMember.id].ActiveEvent = EventId;
                                guilds[EventId].Owner = pickMember.id;
                                
                                if (guilds[EventId].message.log) {
        
                                    const channelOfLog = await guild.channels.fetch(guilds[EventId].message.log.channelId);
                                    const messageOfChannelLog = await channelOfLog.messages.fetch(guilds[EventId].message.log.id);
    
                                    if (messageOfChannelLog) messageOfChannelLog.reply({  
                                        content: `<t:${Math.floor(Date.now()/1000)}:f>`,
                                        embeds: [
                                            {
                                                author: { name: 'Мероприятие передано (командой)' },
                                                title: `${client.user.username + ' logs'}`,
                                                color: appearance.embed.color,
                                                fields: [
                                                    {
                                                        name: `${appearance.embed.dot || appearance.emoji.Dot}Старый ведущий:`,
                                                        value: `・<@${lOld}>\n・${lOld}`,  
                                                        inline: true
                                                    },
                                                    {
                                                        name: `${appearance.embed.dot || appearance.emoji.Dot}Новый ведущий:`,
                                                        value: `・${pickMember}\n・${pickMember.id}`,  
                                                        inline: true
                                                    },
                                                    {
                                                        name: `${appearance.embed.dot || appearance.emoji.Dot}Передал:`,
                                                        value: `・${member}\n・${member.id}`,  
                                                        inline: false
                                                    },
                                                    {
                                                        name: `${appearance.embed.dot || appearance.emoji.Dot}Канал:`,
                                                        value: `・${eventVoiceChannel ? eventVoiceChannel : 'Отсутствует'}\n・${eventVoiceChannel ? eventVoiceChannel.id : 'Отсутствует'}`,  
                                                        inline: true
                                                    },
                                                    {
                                                        name: `${appearance.embed.dot || appearance.emoji.Dot}Мероприятие:`,
                                                        value: `\`\`\`${eventOfCategory.name}\`\`\``,
                                                        inline: true
                                                    }
                                                ],
                                                thumbnail: pickMember ? { url: await getAvatar(pickMember) } : {},
                                            }
                                        ],
                                        components: [
                                            
                                        ]
                                    }).catch(() => {});
        
                                };        

                            }

                            else {

                                const eventVoiceChannel = await guild.channels.fetch(guilds[EventId].channels.voice).catch(() => {});
                                if (eventVoiceChannel) {
                                    
                                    eventVoiceChannel.permissionOverwrites.edit(guilds[EventId].Owner, { MuteMembers: false, MoveMembers: false }).catch(() => {});
                                    eventVoiceChannel.permissionOverwrites.edit(pickMember.id, { MuteMembers: true, MoveMembers: true }).catch(() => {});
    
                                };
    
                                const eventManageChannel = await guild.channels.fetch(guilds[EventId].channels.manage).catch(() => {});
                                if (eventManageChannel) {
    
                                    eventManageChannel.permissionOverwrites.edit(guilds[EventId].Owner, { ViewChannel: false, SendMessages: false }).catch(() => {});
                                    eventManageChannel.permissionOverwrites.edit(pickMember.id, { ViewChannel: true, SendMessages: false }).catch(() => {});
    
                                };
    
                                const eventIRecordChannel = await guild.channels.fetch(guilds[EventId].channels.record).catch(() => {});
                                if (eventIRecordChannel) {
    
                                    eventIRecordChannel.permissionOverwrites.edit(guilds[EventId].Owner, { ManageMessages: false, SendMessages: false }).catch(() => {});
                                    eventIRecordChannel.permissionOverwrites.edit(pickMember.id, { ViewChannel: true, ManageMessages: true, SendMessages: true }).catch(() => {});
    
                                };
    
                                const eventCategory = await guild.channels.fetch(guilds[EventId].channels.category).catch(() => {});
                                if (eventCategory) eventCategory.setName(`${eventOfCategory.name}・${pickMember.displayName}`);
                                
                                users[guilds[EventId].Owner].ActiveEvent = false;
                                users[pickMember.id].ActiveEvent = EventId;
                                guilds[EventId].Owner = pickMember.id;
                                
                                if (guilds[EventId].message.log) {
        
                                    const channelOfLog = await guild.channels.fetch(guilds[EventId].message.log.channelId);
                                    const messageOfChannelLog = await channelOfLog.messages.fetch(guilds[EventId].message.log.id);
    
                                    if (messageOfChannelLog) messageOfChannelLog.reply({  
                                        content: `<t:${Math.floor(Date.now()/1000)}:f>`,
                                        embeds: [
                                            {
                                                author: { name: 'Мероприятие передано (командой)' },
                                                title: `${client.user.username + ' logs'}`,
                                                color: appearance.embed.color,
                                                fields: [
                                                    {
                                                        name: `${appearance.embed.dot || appearance.emoji.Dot}Старый ведущий:`,
                                                        value: `・<@${lOld}>\n・${lOld}`,  
                                                        inline: true
                                                    },
                                                    {
                                                        name: `${appearance.embed.dot || appearance.emoji.Dot}Новый ведущий:`,
                                                        value: `・${pickMember}\n・${pickMember.id}`,  
                                                        inline: true
                                                    },
                                                    {
                                                        name: `${appearance.embed.dot || appearance.emoji.Dot}Передал:`,
                                                        value: `・${member}\n・${member.id}`,  
                                                        inline: false
                                                    },
                                                    {
                                                        name: `${appearance.embed.dot || appearance.emoji.Dot}Канал:`,
                                                        value: `・${eventVoiceChannel ? eventVoiceChannel : 'Отсутствует'}\n・${eventVoiceChannel ? eventVoiceChannel.id : 'Отсутствует'}`,  
                                                        inline: true
                                                    },
                                                    {
                                                        name: `${appearance.embed.dot || appearance.emoji.Dot}Мероприятие:`,
                                                        value: `\`\`\`${eventOfCategory.name}\`\`\``,
                                                        inline: true
                                                    }
                                                ],
                                                thumbnail: pickMember ? { url: await getAvatar(pickMember) } : {},
                                            }
                                        ],
                                        components: [
                                            
                                        ]
                                    }).catch(() => {});
        
                                };  

                            };

                        };

                        if (guilds[EventId].Event.type == 'mafia') {

                            if (guilds[EventId].started) {

                                game = guilds[EventId].game;

                                function getNumber (number) {
                
                                    let numberOfConfig = appearance.emoji.NumbersOfMafia[number];
                                    if (numberOfConfig) return `${numberOfConfig}`;
                                    else `**\`${number}\`**`;
                
                                };

                                let contentOfMessageLeading = '';
                                let componetsOfMessageLeading = [];
                                for (const pickMember in game.members) {

                                    const pickMemberOfGameMembers = game.members[pickMember];
                                    const fetchPickMember = await guild.members.fetch(pickMemberOfGameMembers.id).catch(() => {});

                                    contentOfMessageLeading += `${getNumber (pickMemberOfGameMembers.number)} ${pickMemberOfGameMembers.role.emoji} ${fetchPickMember}\n`;
                                    
                                };

                                for (n=0; n < game.servers.length; n++) {

                                    let randomChannel = {};
                                    for (const channel of game.servers[n].guild.channels.cache) randomChannel = await game.servers[n].guild.channels.fetch(channel[0]);

                                    if (!componetsOfMessageLeading[0] || componetsOfMessageLeading[componetsOfMessageLeading.length-1].components.length == 5) 
                                    componetsOfMessageLeading.push(
                                        {
                                            type: 1,
                                            components: []
                                        }
                                    );

                                    const inviteOfRandomChannel = await randomChannel.createInvite();
                                    componetsOfMessageLeading[componetsOfMessageLeading.length-1].components.push(
                                        {
                                            type: 2, 
                                            label: `Перейти на сервер: ${game.servers[n].guild.name}`, 
                                            url: inviteOfRandomChannel.url,
                                            style: 5
                                        }
                                    );

                                };

                                pickMember.setNickname('! Ведущий').catch(() => {});
                                pickMember.send({  
                                    embeds: [
                                        {
                                            title: `Роли: ${eventOfCategory.name}`,
                                            color: appearance.embed.color,
                                            description: `${contentOfMessageLeading}`
                                        }
                                    ],
                                    components: componetsOfMessageLeading
                                }).catch(() => {});

                                game.message.roles.delete().catch(() => {});
                                for (n=0; n < game.servers.length; n++) {

                                    game.servers[n].guild.members.fetch().catch(() => {});
                                    const fetchPickMemberOfPickServer = await game.servers[n].guild.members.fetch(guilds[EventId].Owner).catch(() => {});
                                    if (fetchPickMemberOfPickServer) fetchPickMemberOfPickServer.kick().catch(() => {});

                                };

                                const memberOfEventOwner = await guild.members.fetch(guilds[EventId].Owner).catch(() => {});
                                if (memberOfEventOwner) memberOfEventOwner.setNickname('').catch(() => {});

                                const eventVoiceChannel = await guild.channels.fetch(guilds[EventId].channels.voice).catch(() => {});
                                if (eventVoiceChannel) {
                                    
                                    eventVoiceChannel.permissionOverwrites.edit(guilds[EventId].Owner, { MuteMembers: false, MoveMembers: false }).catch(() => {});
                                    eventVoiceChannel.permissionOverwrites.edit(pickMember.id, { MuteMembers: true, MoveMembers: true }).catch(() => {});
    
                                };
    
                                const eventManageChannel = await guild.channels.fetch(guilds[EventId].channels.manage).catch(() => {});
                                if (eventManageChannel) {
    
                                    eventManageChannel.permissionOverwrites.edit(guilds[EventId].Owner, { ViewChannel: false, SendMessages: false }).catch(() => {});
                                    eventManageChannel.permissionOverwrites.edit(pickMember.id, { ViewChannel: true, SendMessages: false }).catch(() => {});
    
                                };
    
                                const eventIRecordChannel = await guild.channels.fetch(guilds[EventId].channels.record).catch(() => {});
                                if (eventIRecordChannel) {
    
                                    eventIRecordChannel.permissionOverwrites.edit(guilds[EventId].Owner, { ManageMessages: false, SendMessages: false }).catch(() => {});
                                    eventIRecordChannel.permissionOverwrites.edit(pickMember.id, { ViewChannel: true, ManageMessages: true, SendMessages: true }).catch(() => {});
    
                                };
    
                                const eventCategory = await guild.channels.fetch(guilds[EventId].channels.category).catch(() => {});
                                if (eventCategory) eventCategory.setName(`${eventOfCategory.name}・${pickMember.displayName}`);
                                
                                users[guilds[EventId].Owner].ActiveEvent = false;
                                users[pickMember.id].ActiveEvent = EventId;
                                guilds[EventId].Owner = pickMember.id;
                                
                                if (guilds[EventId].message.log) {
        
                                    const channelOfLog = await guild.channels.fetch(guilds[EventId].message.log.channelId);
                                    const messageOfChannelLog = await channelOfLog.messages.fetch(guilds[EventId].message.log.id);
    
                                    if (messageOfChannelLog) messageOfChannelLog.reply({  
                                        content: `<t:${Math.floor(Date.now()/1000)}:f>`,
                                        embeds: [
                                            {
                                                author: { name: 'Мероприятие передано (командой)' },
                                                title: `${client.user.username + ' logs'}`,
                                                color: appearance.embed.color,
                                                fields: [
                                                    {
                                                        name: `${appearance.embed.dot || appearance.emoji.Dot}Старый ведущий:`,
                                                        value: `・<@${lOld}>\n・${lOld}`,  
                                                        inline: true
                                                    },
                                                    {
                                                        name: `${appearance.embed.dot || appearance.emoji.Dot}Новый ведущий:`,
                                                        value: `・${pickMember}\n・${pickMember.id}`,  
                                                        inline: true
                                                    },
                                                    {
                                                        name: `${appearance.embed.dot || appearance.emoji.Dot}Передал:`,
                                                        value: `・${member}\n・${member.id}`,  
                                                        inline: false
                                                    },
                                                    {
                                                        name: `${appearance.embed.dot || appearance.emoji.Dot}Канал:`,
                                                        value: `・${eventVoiceChannel ? eventVoiceChannel : 'Отсутствует'}\n・${eventVoiceChannel ? eventVoiceChannel.id : 'Отсутствует'}`,  
                                                        inline: true
                                                    },
                                                    {
                                                        name: `${appearance.embed.dot || appearance.emoji.Dot}Мероприятие:`,
                                                        value: `\`\`\`${eventOfCategory.name}\`\`\``,
                                                        inline: true
                                                    }
                                                ],
                                                thumbnail: pickMember ? { url: await getAvatar(pickMember) } : {},
                                            }
                                        ],
                                        components: [
                                            
                                        ]
                                    }).catch(() => {});
        
                                };
                                            
                            }

                            else {

                                const eventVoiceChannel = await guild.channels.fetch(guilds[EventId].channels.voice).catch(() => {});
                                if (eventVoiceChannel) {
                                    
                                    eventVoiceChannel.permissionOverwrites.edit(guilds[EventId].Owner, { MuteMembers: false, MoveMembers: false }).catch(() => {});
                                    eventVoiceChannel.permissionOverwrites.edit(pickMember.id, { MuteMembers: true, MoveMembers: true }).catch(() => {});
    
                                };
    
                                const eventManageChannel = await guild.channels.fetch(guilds[EventId].channels.manage).catch(() => {});
                                if (eventManageChannel) {
    
                                    eventManageChannel.permissionOverwrites.edit(guilds[EventId].Owner, { ViewChannel: false, SendMessages: false }).catch(() => {});
                                    eventManageChannel.permissionOverwrites.edit(pickMember.id, { ViewChannel: true, SendMessages: false }).catch(() => {});
    
                                };
    
                                const eventIRecordChannel = await guild.channels.fetch(guilds[EventId].channels.record).catch(() => {});
                                if (eventIRecordChannel) {
    
                                    eventIRecordChannel.permissionOverwrites.edit(guilds[EventId].Owner, { ManageMessages: false, SendMessages: false }).catch(() => {});
                                    eventIRecordChannel.permissionOverwrites.edit(pickMember.id, { ViewChannel: true, ManageMessages: true, SendMessages: true }).catch(() => {});
    
                                };
    
                                const eventCategory = await guild.channels.fetch(guilds[EventId].channels.category).catch(() => {});
                                if (eventCategory) eventCategory.setName(`${eventOfCategory.name}・${pickMember.displayName}`);
                                
                                users[guilds[EventId].Owner].ActiveEvent = false;
                                users[pickMember.id].ActiveEvent = EventId;
                                guilds[EventId].Owner = pickMember.id;
                                
                                if (guilds[EventId].message.log) {
        
                                    const channelOfLog = await guild.channels.fetch(guilds[EventId].message.log.channelId);
                                    const messageOfChannelLog = await channelOfLog.messages.fetch(guilds[EventId].message.log.id);
    
                                    if (messageOfChannelLog) messageOfChannelLog.reply({  
                                        content: `<t:${Math.floor(Date.now()/1000)}:f>`,
                                        embeds: [
                                            {
                                                author: { name: 'Мероприятие передано (командой)' },
                                                title: `${client.user.username + ' logs'}`,
                                                color: appearance.embed.color,
                                                fields: [
                                                    {
                                                        name: `${appearance.embed.dot || appearance.emoji.Dot}Старый ведущий:`,
                                                        value: `・<@${lOld}>\n・${lOld}`,  
                                                        inline: true
                                                    },
                                                    {
                                                        name: `${appearance.embed.dot || appearance.emoji.Dot}Новый ведущий:`,
                                                        value: `・${pickMember}\n・${pickMember.id}`,  
                                                        inline: true
                                                    },
                                                    {
                                                        name: `${appearance.embed.dot || appearance.emoji.Dot}Передал:`,
                                                        value: `・${member}\n・${member.id}`,  
                                                        inline: false
                                                    },
                                                    {
                                                        name: `${appearance.embed.dot || appearance.emoji.Dot}Канал:`,
                                                        value: `・${eventVoiceChannel ? eventVoiceChannel : 'Отсутствует'}\n・${eventVoiceChannel ? eventVoiceChannel.id : 'Отсутствует'}`,  
                                                        inline: true
                                                    },
                                                    {
                                                        name: `${appearance.embed.dot || appearance.emoji.Dot}Мероприятие:`,
                                                        value: `\`\`\`${eventOfCategory.name}\`\`\``,
                                                        inline: true
                                                    }
                                                ],
                                                thumbnail: pickMember ? { url: await getAvatar(pickMember) } : {},
                                            }
                                        ],
                                        components: [
                                            
                                        ]
                                    }).catch(() => {});
        
                                };  

                            };

                        };
    
                        i.update({
                            content: ' ',
                            embeds: [
                                {
                                    title: `${client.user.username} delete`,
                                    color: appearance.embed.color,
                                    description: `${member}, Вы успешно **передали** мероприятие своё **${guilds[EventId].Event.name}** ведущему ${pickMember}`,
                                    thumbnail: { url: memberAvatar } 
                                }
                            ], 
                            components: [ 
                    
                            ]
                        }).catch(() => {});
    
                        break;
    
                    }
    
                };
        
            });

        };

    };
    
    if (argsF.subcommand == 'reward') {

        async function errorNoEventsOwnerMessage (One) {

            const memberAvater = await getAvatar(One);

            return {
                ephemeral: true,
                embeds: [
                    {
                        title: `${client.user.username} error`,
                        color: appearance.embed.errorColor,
                        description: `${One}, для того, чтобы **использовать** данную команду Вам **необходимо** быть ведущим** данного** мероприятия`,
                        thumbnail: { url: memberAvater }
                    }
                ], 
                components: [
                    
                ]
            };

        };

        if (await checkingForRoles (interaction, appearance.roles.Events.access) !== true) return;

        if (!users[member.id].ActiveEvent && !users[member.id].Events[0])
        return interaction.reply({
            ephemeral: true,
            embeds: [
                {
                    title: `${client.user.username} error`,
                    color: appearance.embed.errorColor,
                    description: `${member}, у Вас нет **активных** мероприятий или **ранее** созданных на **${guild.name}**`,
                    thumbnail: { url: memberAvatar } 
                }
            ], 
            components: [ 
    
            ]
        }).catch(() => {});
        

        let actions = {};
        let options = [];
        let eventsOfReward = [];
        for (const pickEvent in users[member.id].Events) if (guilds[users[member.id].Events[pickEvent].EventId] && guilds[users[member.id].Events[pickEvent].EventId].Event.type == 'event') eventsOfReward.push(guilds[users[member.id].Events[pickEvent].EventId]);
        if (users[member.id].ActiveEvent && guilds[users[member.id].ActiveEvent].Event.type == 'event') eventsOfReward.unshift(guilds[users[member.id].ActiveEvent]);

        for (const pickEvent in eventsOfReward) {

            if (pickEvent == 25) break;

            options.push(
                {
                    label: `${eventsOfReward[pickEvent].Event.name} — ${getCurrentDateTime (eventsOfReward[pickEvent].Created)}`, 
                    value: `${pickEvent}`, 
                    description: `Последний запрос выдачи: ${eventsOfReward[pickEvent].rewardLast ? getCurrentDateTime (eventsOfReward[pickEvent].rewardLast) : 'Отсутствует'}`,  
                    emoji: eventsOfReward[pickEvent].reward ? appearance.emoji.Online : appearance.emoji.Offline
                }
            );

        };

        interaction.reply({
            embeds: [
                {
                    title: `${client.user.username} reward`,
                    color: appearance.embed.color,
                    description: `${member}, выберите **необходимо** мероприятия\nДоступно мероприятий: **${options.length}**`,
                    thumbnail: { url: memberAvatar } 
                }
            ], 
            components: [ 
                {
                    type: 1,
                    components: [
                        {
                            type: 3,
                            customId: 'eventSelect', 
                            placeholder: 'Выберите необходимое мероприятие', 
                            minValues: 1, 
                            maxValues: 1, 
                            options: options
                        }
                    ]
                }
            ]
        }).catch(() => {});
        

        let lastInt = Date.now() / 1000;
        const cheackLastInt = setInterval(async () => {
    
            if (lastInt + 100 - Date.now() / 1000 < 0) {
              
                await targetMessageEditComponents(interaction);
                return clearInterval(cheackLastInt);
    
            };
    
        }, 2000); 
    
        const collectorConponents = await channel.createMessageComponentCollector();
        collectorConponents.on('collect', async i => {
    
            if (!i.message.interaction || i.message.interaction.id !== interaction.id) return;
            if (!i.member|| i.member.id !== member.id) return;

            lastInt = Date.now() / 1000;
    
            switch (i.customId) { 

                case 'back': {

                    if (!users[member.id].ActiveEvent && !users[member.id].Events[0])
                    return interaction.reply({
                        ephemeral: true,
                        embeds: [
                            {
                                title: `${client.user.username} error`,
                                color: appearance.embed.errorColor,
                                description: `${member}, у Вас нет **активных** мероприятий или **ранее** созданных на **${guild.name}**`,
                                thumbnail: { url: memberAvatar } 
                            }
                        ], 
                        components: [ 
                
                        ]
                    }).catch(() => {});
                    
            
                    actions = {};
                    options = [];
                    eventsOfReward = [];

                    for (const pickEvent in users[member.id].Events) if (guilds[users[member.id].Events[pickEvent].EventId].Event.type == 'event') eventsOfReward.push(guilds[users[member.id].Events[pickEvent].EventId]);
                    if (users[member.id].ActiveEvent && guilds[users[member.id].ActiveEvent].Event.type == 'event') eventsOfReward.unshift(guilds[users[member.id].ActiveEvent]);
            
                    for (const pickEvent in eventsOfReward) {
            
                        if (pickEvent == 25) break;
            
                        options.push(
                            {
                                label: `${eventsOfReward[pickEvent].Event.name} — ${getCurrentDateTime (eventsOfReward[pickEvent].Created)}`, 
                                value: `${pickEvent}`, 
                                description: `Последний запрос выдачи: ${eventsOfReward[pickEvent].rewardLast ? getCurrentDateTime (eventsOfReward[pickEvent].rewardLast) : 'Отсутствует'}`,  
                                emoji: eventsOfReward[pickEvent].reward ? appearance.emoji.Online : appearance.emoji.Offline
                            }
                        );
            
                    };
            
                    i.update({
                        embeds: [
                            {
                                title: `${client.user.username} reward`,
                                color: appearance.embed.color,
                                description: `${member}, выберите **необходимо** мероприятия\nДоступно мероприятий: **${options.length}**`,
                                thumbnail: { url: memberAvatar } 
                            }
                        ], 
                        components: [ 
                            {
                                type: 1,
                                components: [
                                    {
                                        type: 3,
                                        customId: 'eventSelect', 
                                        placeholder: 'Выберите необходимое мероприятие', 
                                        minValues: 1, 
                                        maxValues: 1, 
                                        options: options
                                    }
                                ]
                            }
                        ]
                    }).catch(() => {});

                    break;

                }

                case 'eventSelect': {

                    let Event = i.values[0];
                    let pickReward = false;
                    let EventId = eventsOfReward[Event].EventId;

                    let reward = {};
                    let rewardFields = [];
                    let rewardOption = [];
                    let membersAllReward = [];
                    const eventOfCategory = eventsOfReward[Event].Event;
                    for (const pickRewardOfEvent in eventOfCategory.rewards) {

                        if (!reward[pickRewardOfEvent]) reward[pickRewardOfEvent] = {members: []};
                        rewardOption.push(
                            {
                                label: `${pickRewardOfEvent}`, 
                                value: `${pickRewardOfEvent}`, 
                                description: `Награда: ${eventOfCategory.rewards[pickRewardOfEvent].reward}`,
                                default: pickRewardOfEvent == pickReward
                            }
                        );

                        
                        let membersText = '';
                        for (let pickMember in reward[pickRewardOfEvent].member) {
                            
                            if (membersText == '') membersText += `<@${reward[pickRewardOfEvent].member[pickMember]}>`;
                            else membersText += `\n<@${reward[pickRewardOfEvent].member[pickMember]}>`;

                        };

                        if (membersText !== '') {

                            rewardFields.push(
                                {
                                    name: `${pickRewardOfEvent}・${eventOfCategory.rewards[pickRewardOfEvent].reward} ${appearance.emoji.Coin}`,
                                    value: `${membersText}`,
                                    inline: false
                                }
                            );

                        };

                    };

                    let optionsMembers = [];
                    let voiceOnline = guilds[guilds[EventId].channels.voice].online;
                    let sortedVoice = Object.fromEntries(Object.entries(voiceOnline).sort(([k1], [k2]) => k2 - k1));
 
                    for (let pickMember in sortedVoice) {

                        let pickMemberFetch = await guild.members.fetch(pickMember).catch(() => {});

                        if (pickMemberFetch) {

                            optionsMembers.push(
                                {
                                    label: `@${pickMemberFetch.displayName} — ${pickMemberFetch.user.username} `, 
                                    value: `${pickMemberFetch.id}`, 
                                    description: `Онлайн: ${hourTranslator (sortedVoice[pickMember])}`,
                                    default: reward[pickReward] && reward[pickReward].members.includes(pickMemberFetch.id)
                                }
                            );

                        };

                    };

                    if (!optionsMembers[0])
                    return i.update({
                        embeds: [
                            {
                                title: `${client.user.username} error`,
                                color: appearance.embed.errorColor,
                                description: `${member}, на выбронном Вами мероприятие **${eventOfCategory.name}** **отсутствует** список участников`,
                                thumbnail: { url: memberAvatar } 
                            }
                        ]
                    }).catch(() => {});

                    i.update({
                        embeds: [
                            {
                                title: `${client.user.username} reward`,
                                color: appearance.embed.color,
                                description: `Мероприятие: **${eventOfCategory.name}**\nСоздано: <t:${Math.floor(eventsOfReward[Event].Created)}:f>`,
                                thumbnail: { url: memberAvatar },
                                fields: rewardFields
                            }
                        ], 
                        components: [ 
                            {
                                type: 1,
                                components: [
                                    {
                                        type: 3,
                                        customId: 'rewardSelect', 
                                        placeholder: `Выберите тип награды`, 
                                        minValues: 1, 
                                        maxValues: 1, 
                                        options: rewardOption
                                    }
                                ]
                            },
                            {
                                type: 1,
                                components: [
                                    {
                                        type: 3,
                                        customId: 'userEventSelect', 
                                        placeholder: `Выберите пользователей`, 
                                        minValues: 1, 
                                        maxValues: optionsMembers.length, 
                                        options: optionsMembers,
                                        disabled: !pickReward
                                    }
                                ]
                            },
                            {
                                type: 1,
                                components: [
                                    {
                                        type: 2, 
                                        style: 3,
                                        label: 'Отправить', 
                                        customId: 'send',
                                        disabled: !membersAllReward[0]
                                    },
                                    {
                                        type: 2, 
                                        style: 2,
                                        label: 'Очистить', 
                                        customId: 'clear'
                                    },
                                    {
                                        type: 2, 
                                        style: appearance.buttons_menu.Default.style,
                                        label: 'Назад', 
                                        customId: 'back'
                                    }
                                ]
                            }
                        ]
                    }).catch(() => {});

                        
                    const rewardSelect = (async (newI) => {

                        pickReward = newI.values[0];

                        rewardFields = [];
                        rewardOption = [];
    
                        optionsMembers = [];
                        let voiceOnline = guilds[guilds[EventId].channels.voice].online;
                        let sortedVoice = Object.fromEntries(Object.entries(voiceOnline).sort(([k1], [k2]) => k2 - k1));

                        for (const pickRewardOfEvent in eventOfCategory.rewards) {
    
                            rewardOption.push(
                                {
                                    label: `${pickRewardOfEvent}`, 
                                    value: `${pickRewardOfEvent}`, 
                                    description: `Награда: ${eventOfCategory.rewards[pickRewardOfEvent].reward}`,
                                    default: pickRewardOfEvent == pickReward
                                }
                            );
    
                            
                            let membersText = '';
                            for (let pickMember in reward[pickRewardOfEvent].members) {
                                
                                if (membersText == '') membersText += `<@${reward[pickRewardOfEvent].members[pickMember]}> — ${hourTranslatorBold (sortedVoice[reward[pickRewardOfEvent].members[pickMember]])}`;
                                else membersText += `\n<@${reward[pickRewardOfEvent].members[pickMember]}> — ${hourTranslatorBold (sortedVoice[reward[pickRewardOfEvent].members[pickMember]])}`;
    
                            };  
    
                            if (reward[pickRewardOfEvent].members[0]) {
    
                                rewardFields.push(
                                    {
                                        name: `${pickRewardOfEvent}・${eventOfCategory.rewards[pickRewardOfEvent].reward} ${appearance.emoji.Coin}`,
                                        value: `${membersText}`,
                                        inline: false
                                    }
                                );
    
                            };
    
                        };

                        for (let pickMember in sortedVoice) {
    
                            let pickMemberFetch = await guild.members.fetch(pickMember).catch(() => {});
    
                            if (pickMemberFetch) {
    
                                optionsMembers.push(
                                    {
                                        label: `@${pickMemberFetch.displayName} — ${pickMemberFetch.user.username} `, 
                                        value: `${pickMemberFetch.id}`, 
                                        description: `Онлайн: ${hourTranslator (sortedVoice[pickMember])}`,
                                        default: reward[pickReward] && reward[pickReward].members.includes(pickMemberFetch.id)
                                    }
                                );
    
                            };
    
                        };

                        newI.update({
                            embeds: [
                                {
                                    title: `${client.user.username} reward`,
                                    color: appearance.embed.color,
                                    description: `Мероприятие: **${eventOfCategory.name}**\nСоздано: <t:${Math.floor(eventsOfReward[Event].Created)}:f>`,
                                    thumbnail: { url: memberAvatar },
                                    fields: rewardFields
                                }
                            ], 
                            components: [ 
                                {
                                    type: 1,
                                    components: [
                                        {
                                            type: 3,
                                            customId: 'rewardSelect', 
                                            placeholder: `Выберите тип награды`, 
                                            minValues: 1, 
                                            maxValues: 1, 
                                            options: rewardOption
                                        }
                                    ]
                                },
                                {
                                    type: 1,
                                    components: [
                                        {
                                            type: 3,
                                            customId: 'userEventSelect', 
                                            placeholder: `Выберите пользователей`, 
                                            minValues: 1, 
                                            maxValues: optionsMembers.length, 
                                            options: optionsMembers,
                                            disabled: !pickReward
                                        }
                                    ]
                                },
                                {
                                    type: 1,
                                    components: [
                                        {
                                            type: 2, 
                                            style: 3,
                                            label: 'Отправить', 
                                            customId: 'send',
                                            disabled: !membersAllReward[0]
                                        },
                                        {
                                            type: 2, 
                                            style: 2,
                                            label: 'Очистить', 
                                            customId: 'clear'
                                        },
                                        {
                                            type: 2, 
                                            style: appearance.buttons_menu.Default.style,
                                            label: 'Назад', 
                                            customId: 'back'
                                        }
                                    ]
                                }
    
                            ]
                        }).catch(() => {});


                    });

                    actions['rewardSelect'] = {
                        actions: [rewardSelect],
                        all: false
                    };

                    const userEventSelect = (async (newI) => {

                        const pickMembers = newI.values;
                        
                        for (let pickMember in pickMembers) for (let pickRewardOfReward in reward) reward[pickRewardOfReward].members = reward[pickRewardOfReward].members.filter((n) => { return n != pickMembers[pickMember] });
                        reward[pickReward].members = pickMembers;

                        membersAllReward = [];
                        for (const pickRewardOfEvent in eventOfCategory.rewards) for (let pickMember in reward[pickRewardOfEvent].members) membersAllReward.push(reward[pickRewardOfEvent].members[pickMember]);

                        rewardFields = [];
                        rewardOption = [];
    
                        optionsMembers = [];
                        let voiceOnline = guilds[guilds[EventId].channels.voice].online;
                        let sortedVoice = Object.fromEntries(Object.entries(voiceOnline).sort(([k1], [k2]) => k2 - k1));

                        for (const pickRewardOfEvent in eventOfCategory.rewards) {
    
                            rewardOption.push(
                                {
                                    label: `${pickRewardOfEvent}`, 
                                    value: `${pickRewardOfEvent}`, 
                                    description: `Награда: ${eventOfCategory.rewards[pickRewardOfEvent].reward}`,
                                    default: pickRewardOfEvent == pickReward
                                }
                            );
    
                            
                            let membersText = '';
                            for (let pickMember in reward[pickRewardOfEvent].members) {
                                
                                if (membersText == '') membersText += `<@${reward[pickRewardOfEvent].members[pickMember]}> — ${hourTranslatorBold (sortedVoice[reward[pickRewardOfEvent].members[pickMember]])}`;
                                else membersText += `\n<@${reward[pickRewardOfEvent].members[pickMember]}> — ${hourTranslatorBold (sortedVoice[reward[pickRewardOfEvent].members[pickMember]])}`;
    
                            };  
    
                            if (reward[pickRewardOfEvent].members[0]) {
    
                                rewardFields.push(
                                    {
                                        name: `${pickRewardOfEvent}・${eventOfCategory.rewards[pickRewardOfEvent].reward} ${appearance.emoji.Coin}`,
                                        value: `${membersText}`,
                                        inline: false
                                    }
                                );
    
                            };
    
                        };

                        for (let pickMember in sortedVoice) {
    
                            let pickMemberFetch = await guild.members.fetch(pickMember).catch(() => {});
    
                            if (pickMemberFetch) {
    
                                optionsMembers.push(
                                    {
                                        label: `@${pickMemberFetch.displayName} — ${pickMemberFetch.user.username} `, 
                                        value: `${pickMemberFetch.id}`, 
                                        description: `Онлайн: ${hourTranslator (sortedVoice[pickMember])}`,
                                        default: reward[pickReward] && reward[pickReward].members.includes(pickMemberFetch.id)
                                    }
                                );
    
                            };
    
                        };

                        newI.update({
                            embeds: [
                                {
                                    title: `${client.user.username} reward`,
                                    color: appearance.embed.color,
                                    description: `Мероприятие: **${eventOfCategory.name}**\nСоздано: <t:${Math.floor(eventsOfReward[Event].Created)}:f>`,
                                    thumbnail: { url: memberAvatar },
                                    fields: rewardFields
                                }
                            ], 
                            components: [ 
                                {
                                    type: 1,
                                    components: [
                                        {
                                            type: 3,
                                            customId: 'rewardSelect', 
                                            placeholder: `Выберите тип награды`, 
                                            minValues: 1, 
                                            maxValues: 1, 
                                            options: rewardOption
                                        }
                                    ]
                                },
                                {
                                    type: 1,
                                    components: [
                                        {
                                            type: 3,
                                            customId: 'userEventSelect', 
                                            placeholder: `Выберите пользователей`, 
                                            minValues: 1, 
                                            maxValues: optionsMembers.length, 
                                            options: optionsMembers,
                                            disabled: !pickReward
                                        }
                                    ]
                                },
                                {
                                    type: 1,
                                    components: [
                                        {
                                            type: 2, 
                                            style: 3,
                                            label: 'Отправить', 
                                            customId: 'send',
                                            disabled: !membersAllReward[0]
                                        },
                                        {
                                            type: 2, 
                                            style: 2,
                                            label: 'Очистить', 
                                            customId: 'clear'
                                        },
                                        {
                                            type: 2, 
                                            style: appearance.buttons_menu.Default.style,
                                            label: 'Назад', 
                                            customId: 'back'
                                        }
                                    ]
                                }
    
                            ]
                        }).catch(() => {});


                    });

                    actions['userEventSelect'] = {
                        actions: [userEventSelect],
                        all: false
                    };

                    const clear = (async (newI) => {

                        reward = {};
                        rewardOption = [];
                        rewardFields = [];
                        membersAllReward = [];
    
                        pickReward = false;
                        optionsMembers = [];
                        let voiceOnline = guilds[guilds[EventId].channels.voice].online;
                        let sortedVoice = Object.fromEntries(Object.entries(voiceOnline).sort(([k1], [k2]) => k2 - k1));

                        for (const pickRewardOfEvent in eventOfCategory.rewards) {

                            if (!reward[pickRewardOfEvent]) reward[pickRewardOfEvent] = {members: []};
    
                            rewardOption.push(
                                {
                                    label: `${pickRewardOfEvent}`, 
                                    value: `${pickRewardOfEvent}`, 
                                    description: `Награда: ${eventOfCategory.rewards[pickRewardOfEvent].reward}`,
                                    default: pickRewardOfEvent == pickReward
                                }
                            );
    
                            
                            let membersText = '';
                            for (let pickMember in reward[pickRewardOfEvent].members) {
                                
                                if (membersText == '') membersText += `<@${reward[pickRewardOfEvent].members[pickMember]}> — ${hourTranslatorBold (sortedVoice[reward[pickRewardOfEvent].members[pickMember]])}`;
                                else membersText += `\n<@${reward[pickRewardOfEvent].members[pickMember]}> — ${hourTranslatorBold (sortedVoice[reward[pickRewardOfEvent].members[pickMember]])}`;
    
                            };  
    
                            if (reward[pickRewardOfEvent].members[0]) {
    
                                rewardFields.push(
                                    {
                                        name: `${pickRewardOfEvent}・${eventOfCategory.rewards[pickRewardOfEvent].reward} ${appearance.emoji.Coin}`,
                                        value: `${membersText}`,
                                        inline: false
                                    }
                                );
    
                            };
    
                        };
                        
                        newI.update({
                            embeds: [
                                {
                                    title: `${client.user.username} reward`,
                                    color: appearance.embed.color,
                                    description: `Мероприятие: **${eventOfCategory.name}**\nСоздано: <t:${Math.floor(eventsOfReward[Event].Created)}:f>`,
                                    thumbnail: { url: memberAvatar },
                                    fields: rewardFields
                                }
                            ], 
                            components: [ 
                                {
                                    type: 1,
                                    components: [
                                        {
                                            type: 3,
                                            customId: 'rewardSelect', 
                                            placeholder: `Выберите тип награды`, 
                                            minValues: 1, 
                                            maxValues: 1, 
                                            options: rewardOption
                                        }
                                    ]
                                },
                                {
                                    type: 1,
                                    components: [
                                        {
                                            type: 3,
                                            customId: 'userEventSelect', 
                                            placeholder: `Выберите пользователей`, 
                                            minValues: 1, 
                                            maxValues: 1, 
                                            options: [
                                                {
                                                    label: 'sdgfsdfgd', 
                                                    value: 'asdfasdfasdf'
                                                }
                                            ],
                                            disabled: !pickReward
                                        }
                                    ]
                                },
                                {
                                    type: 1,
                                    components: [
                                        {
                                            type: 2, 
                                            style: 3,
                                            label: 'Отправить', 
                                            customId: 'send',
                                            disabled: !membersAllReward[0]
                                        },
                                        {
                                            type: 2, 
                                            style: 2,
                                            label: 'Очистить', 
                                            customId: 'clear'
                                        },
                                        {
                                            type: 2, 
                                            style: appearance.buttons_menu.Default.style,
                                            label: 'Назад', 
                                            customId: 'back'
                                        }
                                    ]
                                }
                            ]
                        }).catch(() => {});

                    });

                    actions['clear'] = {
                        actions: [clear],
                        all: false
                    };

                    const send = (async (newI) => {
                        
                        newI.update({
                            content: `<t:${Math.floor(Date.now()/1000)}:f>`,
                            embeds: [
                                {
                                    title: `${client.user.username} reward`,
                                    color: appearance.embed.color,
                                    description: `Мероприятие: **${eventOfCategory.name}**\nСоздано: <t:${Math.floor(eventsOfReward[Event].Created)}:f>`,
                                    thumbnail: { url: memberAvatar },
                                    fields: rewardFields
                                }
                            ], 
                            components: [
                                
                            ]
                        }).catch(() => {});
                        
                        const logReward = await guild.channels.fetch(appearance.channels.Events.reward).catch(() => {});
                        const msgReward = await logReward.send({
                            embeds: [
                                {
                                    title: `${client.user.username} logs`,
                                    color: appearance.embed.color,
                                    description: `Мероприятие: **${eventOfCategory.name}**\nСоздано: <t:${Math.floor(eventsOfReward[Event].Created)}:f>`,
                                    thumbnail: { url: memberAvatar },
                                    fields: rewardFields
                                }
                            ], 
                            components: [
                                {
                                    type: 1,
                                    components: [
                                        {
                                            type: 2, 
                                            style: 3,
                                            label: 'Подтвердить', 
                                            customId: 'yes'
                                        },
                                        {
                                            type: 2, 
                                            style: 4,
                                            label: 'Отменить', 
                                            customId: 'no'
                                        }
                                    ]
                                }
                            ]
                        }).catch(() => {});
    
                        guilds[EventId].reward = true;

                        const collectorConponentsMsgReward = await msgReward.createMessageComponentCollector();
                        collectorConponentsMsgReward.on('collect', async i => {
                    
                            switch (i.customId) { 
                
                                case 'yes': {

                                    if (!i.member._roles.find(roleId => appearance.roles.Events.fullAccess.includes(roleId))) return await checkingForRoles (i, appearance.roles.Events.fullAccess);

                                    i.update({
                                        content: `<t:${Math.floor(Date.now()/1000)}:f>`,
                                        embeds: [
                                            {
                                                title: `${client.user.username} logs`,
                                                color: appearance.embed.color,
                                                description: `Мероприятие: **${eventOfCategory.name}**\nСоздано: <t:${Math.floor(eventsOfReward[Event].Created)}:f>\nПодтвердил: ${i.member}`,
                                                thumbnail: { url: memberAvatar },
                                                fields: rewardFields
                                            }
                                        ], 
                                        components: [
                                            
                                        ]
                                    }).catch(() => {});

                                    for (const pickRewardOfEvent in eventOfCategory.rewards) for (let pickMember in reward[pickRewardOfEvent].members) channel.send(`!award ${eventOfCategory.rewards[pickRewardOfEvent].reward} ${reward[pickRewardOfEvent].members[pickMember]}`);
                                    break;

                                }
                
                                case 'no': {

                                    if (!i.member._roles.find(roleId => appearance.roles.Events.fullAccess.includes(roleId))) return await checkingForRoles (i, appearance.roles.Events.fullAccess);

                                    i.update({
                                        content: `<t:${Math.floor(Date.now()/1000)}:f>`,
                                        content: `<t:${Math.floor(Date.now()/1000)}:f>`,
                                        embeds: [
                                            {
                                                title: `${client.user.username} logs`,
                                                color: appearance.embed.color,
                                                description: `Мероприятие: **${eventOfCategory.name}**\nСоздано: <t:${Math.floor(eventsOfReward[Event].Created)}:f>\nОтменил: ${i.member}`,
                                                thumbnail: { url: memberAvatar },
                                                fields: rewardFields
                                            }
                                        ], 
                                        components: [
                                            {
                                                type: 1,
                                                components: [
                                                    {
                                                        type: 2, 
                                                        style: 4,
                                                        label: 'Отменить', 
                                                        customId: 'delete',
                                                        disabled: true
                                                    }
                                                ]
                                            }
                                        ]
                                    }).catch(() => {});

                                    break;

                                }

                            };

                        });

                    });

                    actions['send'] = {
                        actions: [send],
                        all: false
                    };

                }

                default: {
    
                    if (actions[i.customId] && actions[i.customId].all == false) await actions[i.customId].actions[0](i);
    
                    break;
    
                }

            };

        });

    };

    if (argsF.subcommand == 'ban') {

        const pickMember = await guild.members.fetch(args.пользователь).catch(() => {});
        if (await checkingForRoles (interaction, appearance.roles.Events.access) !== true) return;
        checkingForAvailability (db, pickMember);
            
        if (!pickMember) 
        return interaction.reply({
            ephemeral: true,  
            embeds: [
                {
                    title: `${client.user.username} error`,
                    color: appearance.embed.errorColor,
                    description: `${member}, пользователь \`${args.пользователь}\` не найден`,                          
                    thumbnail: { url: await getAvatar (pickMember) } 
                }
            ]
        }).catch(() => {});
            
        if (!appearance.custom.Events.punishment[args.наказание]) 
        return interaction.reply({
            ephemeral: true,  
            embeds: [
                {
                    title: `${client.user.username} error`,
                    color: appearance.embed.errorColor,
                    description: `${member}, наказание \`${args.наказание}\` не найдено`,                          
                    thumbnail: { url: await getAvatar (pickMember) } 
                }
            ]
        }).catch(() => {});

        if (pickMember.user.bot) 
        return interaction.reply({
            ephemeral: true,  
            embeds: [
                {
                    title: `${client.user.username} error`,
                    color: appearance.embed.errorColor,
                    description: `${member}, Вы уверены **недоступного** бота ${pickMember}, выберите **другого** пользователя`,                          
                    thumbnail: { url: await getAvatar (pickMember) } 
                }
            ]
        }).catch(() => {});

        if (Number (args.единица) * args.длительность > appearance.custom.Events.punishment[args.наказание].maxTime) 
        return interaction.reply({
            ephemeral: true,  
            embeds: [
                {
                    title: `${client.user.username} error`,
                    color: appearance.embed.errorColor,
                    description: `${member}, Вы **ввели** длительность **больше** максимальной`,                          
                    thumbnail: { url: await getAvatar (pickMember) } 
                }
            ]
        }).catch(() => {});
            
        if (pickMember._roles.includes(args.наказание)) 
        return interaction.reply({
            ephemeral: true,  
            embeds: [
                {
                    title: `${client.user.username} error`,
                    color: appearance.embed.errorColor,
                    description: `${member}, пользователь ${pickMember} **уже имеет** выбранное Вами наказание <@&${args.наказание}>, повторите попытку **позже**`,                          
                    thumbnail: { url: await getAvatar (pickMember) } 
                }
            ]
        }).catch(() => {});


        interaction.reply({
            content: `${member}`,
            embeds: [
                {
                    title: `${client.user.username} ban`,
                    color: appearance.embed.color,
                    description: `${member}, Вы **уверены**, что хотите **выдать** **__${appearance.custom.Events.punishment[args.наказание].name}__** (<@&${args.наказание}>) пользователю ${pickMember} по причине **${args.причина}**\n-# Наказание выдастся до <t:${Math.floor(Date.now()/1000 + Number (args.единица) * args.длительность)}:f>`,
                    thumbnail: { url: memberAvatar } 
                }
            ], 
            components: [ 
                {
                    type: 1,
                    components: [
                        {
                            type: 2, 
                            style: 4, 
                            customId: 'yesPunishment', 
                            label: `Выдать наказание @${appearance.custom.Events.punishment[args.наказание].name}`
                        }
                    ]
                }
            ]
        }).catch(() => {});
        

        let lastInt = Date.now() / 1000;
        const cheackLastInt = setInterval(async () => {
    
            if (lastInt + 100 - Date.now() / 1000 < 0) {
              
                await targetMessageEditComponents(interaction);
                return clearInterval(cheackLastInt);
    
            };
    
        }, 2000); 
    
        const collectorConponents = await channel.createMessageComponentCollector();
        collectorConponents.on('collect', async i => {
    
            if (!i.message.interaction || i.message.interaction.id !== interaction.id) return;
            if (!i.member|| i.member.id !== member.id) return;

            lastInt = Date.now() / 1000;
    
            switch (i.customId) { 

                case 'yesPunishment': {

                    const pickMember = await guild.members.fetch(args.пользователь).catch(() => {});
            
                    if (!pickMember) 
                    return i.update({
                        embeds: [
                            {
                                title: `${client.user.username} error`,
                                color: appearance.embed.errorColor,
                                description: `${member}, пользователь \`${args.пользователь}\` не найден`,                          
                                thumbnail: { url: await getAvatar (pickMember) } 
                            }
                        ], 
                        components: [
                            
                        ]
                    }).catch(() => {});
            
                    if (pickMember._roles.includes(args.наказание)) 
                    return i.update({
                        embeds: [
                            {
                                title: `${client.user.username} error`,
                                color: appearance.embed.errorColor,
                                description: `${member}, пользователь ${pickMember} **уже имеет** выбранное Вами наказание <@&${args.наказание}>, повторите попытку **позже**`,                          
                                thumbnail: { url: await getAvatar (pickMember) } 
                            }
                        ],
                        components: [
                            
                        ]
                    }).catch(() => {});
            

                    i.update({
                        content: `<t:${Math.floor(Date.now()/1000)}:f>`,
                        embeds: [
                            {
                                title: `${client.user.username} ban`,
                                color: appearance.embed.color,
                                description: `${member}, Вы **успешно** выдали **__${appearance.custom.Events.punishment[args.наказание].name}__** (<@&${args.наказание}>) пользователю ${pickMember} по причине **${args.причина}**\n-# Наказание выдано до <t:${Math.floor(Date.now()/1000 + Number (args.единица) * args.длительность)}:f>`,
                                thumbnail: { url: memberAvatar } 
                            }
                        ], 
                        components: [
                            
                        ]
                    }).catch(() => {});


                    pickMember.roles.add(args.наказание).catch(() => {});

                    const msgDmMember = await pickMember.send({
                        content: `<t:${Math.floor(Date.now()/1000)}:f>`,
                        embeds: [
                            {
                                author: { name: 'Выдача наказания' },
                                title: `${client.user.username} logs`,
                                color: appearance.embed.color,
                                thumbnail: { url: memberAvatar },
                                fields: [
                                    {
                                        name: `${appearance.embed.dot || appearance.emoji.Dot}Отстранение:`,
                                        value: `・**${appearance.custom.Events.punishment[args.наказание].name}**\n・ID: ${args.наказание}`,  
                                        inline: true
                                    },
                                    {
                                        name: `${appearance.embed.dot || appearance.emoji.Dot}Модератор:`,
                                        value: `・${member}\n・${member.id}`,  
                                        inline: true
                                    },
                                    {
                                        name: `${appearance.embed.dot || appearance.emoji.Dot}Причина:`,
                                        value: `\`\`\`${args.причина}\`\`\``,  
                                        inline: false
                                    },
                                    {
                                        name: `${appearance.embed.dot || appearance.emoji.Dot}Длительность:`,
                                        value: `\`\`\`${hourTranslator(Number (args.единица) * args.длительность)}\`\`\`<t:${Math.floor(Date.now()/1000 + Number (args.единица) * args.длительность)}:F>`,  
                                        inline: true
                                    },
                                    {
                                        name: `${appearance.embed.dot || appearance.emoji.Dot}Истекает:`,
                                        value: `・<t:${Math.floor(Date.now()/1000 + Number (args.единица) * args.длительность)}:F>`,  
                                        inline: true
                                    }
                                ]
                            }
                        ], 
                        components: [
                            
                        ]
                    }).catch(() => {});

                    const logPunishmentsEvents = await guild.channels.fetch(appearance.channels.Events.punishments);
                    const msgLog = await logPunishmentsEvents.send({
                        content: `<t:${Math.floor(Date.now()/1000)}:f>`,
                        embeds: [
                            {
                                author: { name: 'Выдача наказания' },
                                title: `${client.user.username} logs`,
                                color: appearance.embed.color,
                                thumbnail: { url: await getAvatar(pickMember) },
                                fields: [
                                    {
                                        name: `${appearance.embed.dot || appearance.emoji.Dot}Отстранение:`,
                                        value: `・<@&${args.наказание}>\n・**${appearance.custom.Events.punishment[args.наказание].name}**`,  
                                        inline: false
                                    },
                                    {
                                        name: `${appearance.embed.dot || appearance.emoji.Dot}Пользователь:`,
                                        value: `・${pickMember}\n・${pickMember.id}`,  
                                        inline: true
                                    },
                                    {
                                        name: `${appearance.embed.dot || appearance.emoji.Dot}Модератор:`,
                                        value: `・${member}\n・${member.id}`,  
                                        inline: true
                                    },
                                    {
                                        name: `${appearance.embed.dot || appearance.emoji.Dot}Причина:`,
                                        value: `\`\`\`${args.причина}\`\`\``,  
                                        inline: false
                                    },
                                    {
                                        name: `${appearance.embed.dot || appearance.emoji.Dot}Длительность:`,
                                        value: `\`\`\`${hourTranslator(Number (args.единица) * args.длительность)}\`\`\``,  
                                        inline: true
                                    },
                                    {
                                        name: `${appearance.embed.dot || appearance.emoji.Dot}Истекает:`,
                                        value: `・<t:${Math.floor(Date.now()/1000 + Number (args.единица) * args.длительность)}:F>`,  
                                        inline: true
                                    }
                                ]
                            }
                        ], 
                        components: [
                            
                        ]
                    }).catch(() => {});


                    const punishmentsId = makeid(10);
                    if (!guilds[guild.id].Punishments) guilds[guild.id].Punishments = [];
                    
                    guilds[guild.id].Punishments.push(
                        {
                            punishmentsId: punishmentsId,
                            id: pickMember.id,
                            moderator: member.id,
                            dateRemove: Math.floor(Date.now()/1000 + Number (args.единица) * args.длительность),
                            duration: Math.floor(Number (args.единица) * args.длительность),
                            date: Math.floor(Date.now()/1000),
                            reson: args.причина,
                            punishment: args.наказание,
                            logsMessage: {
                                channel: msgLog ? msgLog.channel.id : false,
                                message: msgLog ? msgLog.id : false
                            }
                        }
                    );

                    stats[pickMember.id].Punishments.push(
                        {
                            punishmentsId: punishmentsId,
                            moderator: member.id,
                            dateRemove: Math.floor(Date.now()/1000 + Number (args.единица) * args.длительность),
                            duration: Math.floor(Number (args.единица) * args.длительность),
                            date: Math.floor(Date.now()/1000),
                            reson: args.причина,
                            punishment: args.наказание
                        }
                    );

                }

            };

        });

    };

    if (argsF.subcommand == 'unban') {

        const pickMember = await guild.members.fetch(args.пользователь).catch(() => {});
        if (await checkingForRoles (interaction, appearance.roles.Events.access) !== true) return;
        checkingForAvailability (db, pickMember);
            
        if (!pickMember) 
        return interaction.reply({
            ephemeral: true,  
            embeds: [
                {
                    title: `${client.user.username} error`,
                    color: appearance.embed.errorColor,
                    description: `${member}, пользователь \`${args.пользователь}\` не найден`,                          
                    thumbnail: { url: await getAvatar (pickMember) } 
                }
            ]
        }).catch(() => {});
            
        if (!appearance.custom.Events.punishment[args.наказание]) 
        return interaction.reply({
            ephemeral: true,  
            embeds: [
                {
                    title: `${client.user.username} error`,
                    color: appearance.embed.errorColor,
                    description: `${member}, наказание \`${args.наказание}\` не найдено`,                          
                    thumbnail: { url: await getAvatar (pickMember) } 
                }
            ]
        }).catch(() => {});

        if (pickMember.user.bot) 
        return interaction.reply({
            ephemeral: true,  
            embeds: [
                {
                    title: `${client.user.username} error`,
                    color: appearance.embed.errorColor,
                    description: `${member}, Вы уверены **недоступного** бота ${pickMember}, выберите **другого** пользователя`,                          
                    thumbnail: { url: await getAvatar (pickMember) } 
                }
            ]
        }).catch(() => {});
            
        if (!pickMember._roles.includes(args.наказание)) 
        return interaction.reply({
            ephemeral: true,  
            embeds: [
                {
                    title: `${client.user.username} error`,
                    color: appearance.embed.errorColor,
                    description: `${member}, пользователь ${pickMember} **не имеет** выбранное Вами наказание <@&${args.наказание}>, повторите попытку **позже**`,                          
                    thumbnail: { url: await getAvatar (pickMember) } 
                }
            ]
        }).catch(() => {});


        interaction.reply({
            content: `${member}`,
            embeds: [
                {
                    title: `${client.user.username} unban`,
                    color: appearance.embed.color,
                    description: `${member}, Вы **уверены**, что хотите **снять** **__${appearance.custom.Events.punishment[args.наказание].name}__** (<@&${args.наказание}>) пользователю ${pickMember} по причине **${args.причина}**`,
                    thumbnail: { url: memberAvatar } 
                }
            ], 
            components: [ 
                {
                    type: 1,
                    components: [
                        {
                            type: 2, 
                            style: 4, 
                            customId: 'yesUnPunishment', 
                            label: `Снять наказание @${appearance.custom.Events.punishment[args.наказание].name}`
                        }
                    ]
                }
            ]
        }).catch(() => {});
        

        let lastInt = Date.now() / 1000;
        const cheackLastInt = setInterval(async () => {
    
            if (lastInt + 100 - Date.now() / 1000 < 0) {
              
                await targetMessageEditComponents(interaction);
                return clearInterval(cheackLastInt);
    
            };
    
        }, 2000); 
    
        const collectorConponents = await channel.createMessageComponentCollector();
        collectorConponents.on('collect', async i => {
    
            if (!i.message.interaction || i.message.interaction.id !== interaction.id) return;
            if (!i.member|| i.member.id !== member.id) return;

            lastInt = Date.now() / 1000;
    
            switch (i.customId) { 

                case 'yesUnPunishment': {

                    const pickMember = await guild.members.fetch(args.пользователь).catch(() => {});
            
                    if (!pickMember) 
                    return i.update({
                        embeds: [
                            {
                                title: `${client.user.username} error`,
                                color: appearance.embed.errorColor,
                                description: `${member}, пользователь \`${args.пользователь}\` не найден`,                          
                                thumbnail: { url: await getAvatar (pickMember) } 
                            }
                        ], 
                        components: [
                            
                        ]
                    }).catch(() => {});
            
                    if (!pickMember._roles.includes(args.наказание)) 
                    return i.update({
                        embeds: [
                            {
                                title: `${client.user.username} error`,
                                color: appearance.embed.errorColor,
                                description: `${member}, пользователь ${pickMember} **не имеет** выбранное Вами наказание <@&${args.наказание}>, повторите попытку **позже**`,                          
                                thumbnail: { url: await getAvatar (pickMember) } 
                            }
                        ],
                        components: [
                            
                        ]
                    }).catch(() => {});
            

                    i.update({
                        content: `<t:${Math.floor(Date.now()/1000)}:f>`,
                        embeds: [
                            {
                                title: `${client.user.username} unban`,
                                color: appearance.embed.color,
                                description: `${member}, Вы **успешно** сняли наказание **__${appearance.custom.Events.punishment[args.наказание].name}__** (<@&${args.наказание}>) пользователю ${pickMember} по причине **${args.причина}**`,
                                thumbnail: { url: memberAvatar } 
                            }
                        ], 
                        components: [
                            
                        ]
                    }).catch(() => {});

                    pickMember.roles.remove(args.наказание).catch(() => {});

                    await pickMember.send({
                        content: `<t:${Math.floor(Date.now()/1000)}:f>`,
                        embeds: [
                            {
                                author: { name: 'Снятие наказания' },
                                title: `${client.user.username} logs`,
                                color: appearance.embed.color,
                                thumbnail: { url: memberAvatar },
                                fields: [
                                    {
                                        name: `${appearance.embed.dot || appearance.emoji.Dot}Отстранение:`,
                                        value: `・**${appearance.custom.Events.punishment[args.наказание].name}**\n・ID: ${args.наказание}`,  
                                        inline: true
                                    },
                                    {
                                        name: `${appearance.embed.dot || appearance.emoji.Dot}Модератор:`,
                                        value: `・${member}\n・${member.id}`,  
                                        inline: true
                                    },
                                    {
                                        name: `${appearance.embed.dot || appearance.emoji.Dot}Причина:`,
                                        value: `\`\`\`${args.причина}\`\`\``,  
                                        inline: false
                                    }
                                ]
                            }
                        ], 
                        components: [
                            
                        ]
                    }).catch(() => {});

                    const logPunishmentsEvents = await guild.channels.fetch(appearance.channels.Events.punishments);
                    logPunishmentsEvents.send({
                        content: `<t:${Math.floor(Date.now()/1000)}:f>`,
                        embeds: [
                            {
                                author: { name: 'Снятие наказания' },
                                title: `${client.user.username} logs`,
                                color: appearance.embed.color,
                                thumbnail: { url: await getAvatar(pickMember) },
                                fields: [
                                    {
                                        name: `${appearance.embed.dot || appearance.emoji.Dot}Отстранение:`,
                                        value: `・<@&${args.наказание}>\n・**${appearance.custom.Events.punishment[args.наказание].name}**`,  
                                        inline: false
                                    },
                                    {
                                        name: `${appearance.embed.dot || appearance.emoji.Dot}Пользователь:`,
                                        value: `・${pickMember}\n・${pickMember.id}`,  
                                        inline: true
                                    },
                                    {
                                        name: `${appearance.embed.dot || appearance.emoji.Dot}Модератор:`,
                                        value: `・${member}\n・${member.id}`,  
                                        inline: true
                                    },
                                    {
                                        name: `${appearance.embed.dot || appearance.emoji.Dot}Причина:`,
                                        value: `\`\`\`${args.причина}\`\`\``,  
                                        inline: false
                                    }
                                ]
                            }
                        ], 
                        components: [
                            
                        ]
                    }).catch(() => {});

                    if (!guilds[guild.id].Punishments) guilds[guild.id].Punishments = [];

                    for (let pickPunishment in guilds[guild.id].Punishments) {
            
                        const fetchPickPunishment = guilds[guild.id].Punishments[pickPunishment];
                        if (fetchPickPunishment && fetchPickPunishment.id == pickMember.id && fetchPickPunishment.punishment == args.наказание) guilds[guild.id].Punishments = guilds[guild.id].Punishments.filter((n) => { return n != guilds[guild.id].Punishments[pickPunishment] });

                    };

                }

            };

        });

    };

    if (argsF.subcommand == 'stats') {

        const pickMember = await guild.members.fetch(args.пользователь || member.id).catch(() => {});
        checkingForAvailability (db, pickMember);

        if (args.категория == 'Mafia') {

            let pickMafia = 'Классическая';
            async function generationMafiaStats (user) {
        
                let pickMemberAvatarPNG = user.displayAvatarURL({ format: 'png', size: 1024 });
                const imageProfile = await canvas.loadImage(pickMafia == 'Городская' ? `./assets/images/mafia_stats_g.png` : pickMafia == 'Классическая' ? `./assets/images/mafia_stats_c.png` : null);
        
                const Profile = canvas.createCanvas(1920, 945);
                const context = Profile.getContext('2d');
        
        
                if (pickMemberAvatarPNG) {
        
                    pickMemberAvatarPNG = pickMemberAvatarPNG.replace('.gif', '');
                    pickMemberAvatarPNG = pickMemberAvatarPNG.replace('.webp', '');
                    pickMemberAvatarPNG = pickMemberAvatarPNG + '.png';
                    const imageAvatar = await canvas.loadImage(pickMemberAvatarPNG).catch(() => {});
                    if (imageAvatar) context.drawImage(imageAvatar, 70, 70, 185, 185);
                    else {
                        
                        const imageNullAvatar = await canvas.loadImage(bots.null.avatar).catch(() => {});
                        context.drawImage(imageNullAvatar, 70, 70, 185, 185);
        
                    };
        
                };
        
        
                context.drawImage(imageProfile, 0, 0, 1920, 945);
        
                const userNickName = user.displayName;
                if(userNickName.length > 8) {
        
                    const userNickNameSubstr = userNickName.substr(0, 8) + '…';
                    context.font = '25pt MediumMonts';
                    context.textAlign = 'right';
                    context.fillStyle = '#ffffff';
                    context.fillText(userNickNameSubstr, 582, 195);
        
                };
        
                if(userNickName.length < 9) {
        
                    context.font = '25pt MediumMonts';
                    context.textAlign = 'right';
                    context.fillStyle = '#ffffff';
                    context.fillText(userNickName, 582, 195);
        
                };

                context.font = '55pt MediumMonts';
                context.textAlign = 'center';
                context.fillStyle = '#ffffff';
                context.fillText(stats[user.id][args.категория][pickMafia].rating, 1558, 209);


                if (pickMafia == 'Городская') {

                    context.font = '28pt MediumMonts';
                    context.textAlign = 'center';
                    context.fillStyle = '#ffffff';
                    context.fillText(stats[user.id][args.категория][pickMafia].roles['Мирный житель'].all, 152, 663);

                    context.font = '28pt MediumMonts';
                    context.textAlign = 'center';
                    context.fillStyle = '#FFDD63';
                    context.fillText(stats[user.id][args.категория][pickMafia].roles['Мирный житель'].win, 152, 775);

                    context.font = '24pt MediumMonts';
                    context.textAlign = 'center';
                    context.fillStyle = '#89888A';
                    context.fillText(stats[user.id][args.категория][pickMafia].roles['Мирный житель'].win == 0 ? 0 + '%' : Math.floor(stats[user.id][args.категория][pickMafia].roles['Мирный житель'].win/stats[user.id][args.категория][pickMafia].roles['Мирный житель'].all*100) + '%', 152, 852);


                    context.font = '28pt MediumMonts';
                    context.textAlign = 'center';
                    context.fillStyle = '#ffffff';
                    context.fillText(stats[user.id][args.категория][pickMafia].roles['Шериф'].all, 347, 663);

                    context.font = '28pt MediumMonts';
                    context.textAlign = 'center';
                    context.fillStyle = '#FFDD63';
                    context.fillText(stats[user.id][args.категория][pickMafia].roles['Шериф'].win, 347, 775);

                    context.font = '24pt MediumMonts';
                    context.textAlign = 'center';
                    context.fillStyle = '#89888A';
                    context.fillText(stats[user.id][args.категория][pickMafia].roles['Шериф'].win == 0 ? 0 + '%' : Math.floor(stats[user.id][args.категория][pickMafia].roles['Шериф'].win/stats[user.id][args.категория][pickMafia].roles['Шериф'].all*100) + '%', 347, 852);


                    context.font = '28pt MediumMonts';
                    context.textAlign = 'center';
                    context.fillStyle = '#ffffff';
                    context.fillText(stats[user.id][args.категория][pickMafia].roles['Доктор'].all, 537, 663);

                    context.font = '28pt MediumMonts';
                    context.textAlign = 'center';
                    context.fillStyle = '#FFDD63';
                    context.fillText(stats[user.id][args.категория][pickMafia].roles['Доктор'].win, 537, 775);

                    context.font = '24pt MediumMonts';
                    context.textAlign = 'center';
                    context.fillStyle = '#89888A';
                    context.fillText(stats[user.id][args.категория][pickMafia].roles['Доктор'].win == 0 ? 0 + '%' : Math.floor(stats[user.id][args.категория][pickMafia].roles['Доктор'].win/stats[user.id][args.категория][pickMafia].roles['Доктор'].all*100) + '%', 537, 852);


                    context.font = '28pt MediumMonts';
                    context.textAlign = 'center';
                    context.fillStyle = '#ffffff';
                    context.fillText(stats[user.id][args.категория][pickMafia].roles['Дон'].all, 728, 663);

                    context.font = '28pt MediumMonts';
                    context.textAlign = 'center';
                    context.fillStyle = '#FFDD63';
                    context.fillText(stats[user.id][args.категория][pickMafia].roles['Дон'].win, 728, 775);

                    context.font = '24pt MediumMonts';
                    context.textAlign = 'center';
                    context.fillStyle = '#89888A';
                    context.fillText(stats[user.id][args.категория][pickMafia].roles['Дон'].win == 0 ? 0 + '%' : Math.floor(stats[user.id][args.категория][pickMafia].roles['Дон'].win/stats[user.id][args.категория][pickMafia].roles['Дон'].all*100) + '%', 728, 852);


                    context.font = '28pt MediumMonts';
                    context.textAlign = 'center';
                    context.fillStyle = '#ffffff';
                    context.fillText(stats[user.id][args.категория][pickMafia].roles['Мафия'].all, 920, 663);

                    context.font = '28pt MediumMonts';
                    context.textAlign = 'center';
                    context.fillStyle = '#FFDD63';
                    context.fillText(stats[user.id][args.категория][pickMafia].roles['Мафия'].win, 920, 775);

                    context.font = '24pt MediumMonts';
                    context.textAlign = 'center';
                    context.fillStyle = '#89888A';
                    context.fillText(stats[user.id][args.категория][pickMafia].roles['Мафия'].win == 0 ? 0 + '%' : Math.floor(stats[user.id][args.категория][pickMafia].roles['Мафия'].win/stats[user.id][args.категория][pickMafia].roles['Мафия'].all*100) + '%', 920, 852);


                    context.font = '18pt MediumMonts';
                    context.textAlign = 'left';
                    context.fillStyle = '#ffffff';
                    context.fillText('Игр: ' + stats[user.id][args.категория][pickMafia].all, 1037, 659);

                    context.font = '18pt MediumMonts';
                    context.textAlign = 'left';
                    context.fillStyle = '#FFDD63';
                    context.fillText('Побед: ' + stats[user.id][args.категория][pickMafia].win, 1037, 771);

                    context.font = '17pt MediumMonts';
                    context.textAlign = 'left';
                    context.fillStyle = '#89888A';
                    const allWinrait = stats[user.id][args.категория][pickMafia].win == 0 ? 0 : Math.floor(stats[user.id][args.категория][pickMafia].win/stats[user.id][args.категория][pickMafia].all*100);
                    context.fillText('Винрейт: ' + allWinrait + '%', 1037, 848);

                };

                if (pickMafia == 'Классическая') {

                    context.font = '28pt MediumMonts';
                    context.textAlign = 'center';
                    context.fillStyle = '#ffffff';
                    context.fillText(stats[user.id][args.категория][pickMafia].roles['Мирный житель'].all, 152, 663);

                    context.font = '28pt MediumMonts';
                    context.textAlign = 'center';
                    context.fillStyle = '#FFDD63';
                    context.fillText(stats[user.id][args.категория][pickMafia].roles['Мирный житель'].win, 152, 775);

                    context.font = '24pt MediumMonts';
                    context.textAlign = 'center';
                    context.fillStyle = '#89888A';
                    context.fillText(stats[user.id][args.категория][pickMafia].roles['Мирный житель'].win == 0 ? 0 + '%' : Math.floor(stats[user.id][args.категория][pickMafia].roles['Мирный житель'].win/stats[user.id][args.категория][pickMafia].roles['Мирный житель'].all*100) + '%', 152, 852);


                    context.font = '28pt MediumMonts';
                    context.textAlign = 'center';
                    context.fillStyle = '#ffffff';
                    context.fillText(stats[user.id][args.категория][pickMafia].roles['Шериф'].all, 347, 663);

                    context.font = '28pt MediumMonts';
                    context.textAlign = 'center';
                    context.fillStyle = '#FFDD63';
                    context.fillText(stats[user.id][args.категория][pickMafia].roles['Шериф'].win, 347, 775);

                    context.font = '24pt MediumMonts';
                    context.textAlign = 'center';
                    context.fillStyle = '#89888A';
                    context.fillText(stats[user.id][args.категория][pickMafia].roles['Шериф'].win == 0 ? 0 + '%' : Math.floor(stats[user.id][args.категория][pickMafia].roles['Шериф'].win/stats[user.id][args.категория][pickMafia].roles['Шериф'].all*100) + '%', 347, 852);


                    context.font = '28pt MediumMonts';
                    context.textAlign = 'center';
                    context.fillStyle = '#ffffff';
                    context.fillText(stats[user.id][args.категория][pickMafia].roles['Дон'].all, 537, 663);

                    context.font = '28pt MediumMonts';
                    context.textAlign = 'center';
                    context.fillStyle = '#FFDD63';
                    context.fillText(stats[user.id][args.категория][pickMafia].roles['Дон'].win, 537, 775);

                    context.font = '24pt MediumMonts';
                    context.textAlign = 'center';
                    context.fillStyle = '#89888A';
                    context.fillText(stats[user.id][args.категория][pickMafia].roles['Дон'].win == 0 ? 0 + '%' : Math.floor(stats[user.id][args.категория][pickMafia].roles['Дон'].win/stats[user.id][args.категория][pickMafia].roles['Дон'].all*100) + '%', 537, 852);


                    context.font = '28pt MediumMonts';
                    context.textAlign = 'center';
                    context.fillStyle = '#ffffff';
                    context.fillText(stats[user.id][args.категория][pickMafia].roles['Мафия'].all, 728, 663);

                    context.font = '28pt MediumMonts';
                    context.textAlign = 'center';
                    context.fillStyle = '#FFDD63';
                    context.fillText(stats[user.id][args.категория][pickMafia].roles['Мафия'].win, 728, 775);

                    context.font = '24pt MediumMonts';
                    context.textAlign = 'center';
                    context.fillStyle = '#89888A';
                    context.fillText(stats[user.id][args.категория][pickMafia].roles['Мафия'].win == 0 ? 0 + '%' : Math.floor(stats[user.id][args.категория][pickMafia].roles['Мафия'].win/stats[user.id][args.категория][pickMafia].roles['Мафия'].all*100) + '%', 728, 852);


                    context.font = '18pt MediumMonts';
                    context.textAlign = 'left';
                    context.fillStyle = '#ffffff';
                    context.fillText('Игр: ' + stats[user.id][args.категория][pickMafia].all, 1037, 659);

                    context.font = '18pt MediumMonts';
                    context.textAlign = 'left';
                    context.fillStyle = '#FFDD63';
                    context.fillText('Побед: ' + stats[user.id][args.категория][pickMafia].win, 1037, 771);

                    context.font = '17pt MediumMonts';
                    context.textAlign = 'left';
                    context.fillStyle = '#89888A';
                    const allWinrait = stats[user.id][args.категория][pickMafia].win == 0 ? 0 : Math.floor(stats[user.id][args.категория][pickMafia].win/stats[user.id][args.категория][pickMafia].all*100);
                    context.fillText('Винрейт: ' + allWinrait + '%', 1037, 848);

                };

                const sixeOfGames = {
                    0: {
                        result: [1349, 454],
                        roleOfText: [1382, 444],
                        date: [1382, 465],
                        raiting: [1783, 454]
                    },
                    1: {
                        result: [1349, 570],
                        roleOfText: [1382, 560],
                        date: [1382, 581],
                        raiting: [1783, 570]
                    },
                    2: {
                        result: [1349, 686],
                        roleOfText: [1382, 676],
                        date: [1382, 697],
                        raiting: [1783, 686]
                    },
                    3: {
                        result: [1349, 802],
                        roleOfText: [1382, 792],
                        date: [1382, 813],
                        raiting: [1783, 802]
                    }
                };

                for (const pickGame in stats[user.id][args.категория][pickMafia].games) {

                    if (!sixeOfGames[pickGame]) break;
                    const fetchPickGame = stats[user.id][args.категория][pickMafia].games[pickGame];

                    context.font = '18pt MediumMonts';
                    context.textAlign = 'center';
                    context.fillStyle = fetchPickGame.win ? '#71FF4E' : '#FF4848';
                    context.fillText(fetchPickGame.win ? 'W' : 'L', sixeOfGames[pickGame].result[0], sixeOfGames[pickGame].result[1]);
                    
                    context.font = '18pt MediumMonts';
                    context.textAlign = 'left';
                    context.fillStyle = '#ffffff';
                    context.fillText(fetchPickGame.roleOfText, sixeOfGames[pickGame].roleOfText[0], sixeOfGames[pickGame].roleOfText[1]);

                    context.font = '12pt MediumMonts';
                    context.textAlign = 'left';
                    context.fillStyle = '#555555';
                    context.fillText(getCurrentDateTime(fetchPickGame.date), sixeOfGames[pickGame].date[0], sixeOfGames[pickGame].date[1]);

                    context.font = '18pt MediumMonts';
                    context.textAlign = 'right';
                    context.fillStyle = fetchPickGame.win ? '#71FF4E' : '#FF4848';
                    context.fillText(fetchPickGame.raiting, sixeOfGames[pickGame].raiting[0], sixeOfGames[pickGame].raiting[1]);

                };
                
                const imageUserProfile = Profile.toBuffer('image/png');
                writeFileSync(`./assets/files/m_stats_g-${user.id}.png`, imageUserProfile);
        
                return [`./assets/files/m_stats_g-${user.id}.png`, `m_stats_g-${user.id}.png`];
        
            };
        
            interaction.deferReply().catch(() => {});
            const infoProfile = await generationMafiaStats (pickMember);

            let components = [];

            components.push(
                {
                    type: 1,
                    components: [
                        {
                            type: 3,
                            customId: 'mafiaSelect', 
                            placeholder: `Выберите необходимый доступный тип мафии`, 
                            minValues: 1, 
                            maxValues: 1, 
                            options: []
                        }
                    ]
                }
            );


            for (const pickMafiaSec in stats[pickMember.id][args.категория]) {
                
                components[0].components[0].options.push(
                    {
                        label: `${pickMafiaSec}`, 
                        value: `${pickMafiaSec}`, 
                        emoji: appearance.emoji.Type, 
                        default: pickMafia == pickMafiaSec
                    }
                );
            
            };

            setTimeout(() => {
                
                interaction.editReply({
                    content: ' ',
                    files: [
                        {
                            attachment: infoProfile[0], 
                            name: infoProfile[1]
                        }
                    ], 
                    components: components
                }).catch(() => {});

            }, 2000);


            let lastInt = Date.now() / 1000;
            const cheackLastInt = setInterval(async () => {
        
                if (lastInt + 100 - Date.now() / 1000 < 0) {
                  
                    await targetMessageEditComponents(interaction);
                    return clearInterval(cheackLastInt);
        
                };
        
            }, 2000); 
    
            const collectorConponents = await channel.createMessageComponentCollector();
            collectorConponents.on('collect', async i => {
        
                if (!i.message.interaction || i.message.interaction.id !== interaction.id) return;
        
                lastInt = Date.now() / 1000;
                if (actions[i.customId] && actions[i.customId].all == true) return await actions[i.customId].actions[0](i);
        
                if (!i.member || i.member.id !== member.id) return;
        
                switch (i.customId) { 

                    case 'mafiaSelect': {

                        pickMafia = i.values[0];

                        i.update({
                            content: 'Загрузка...',
                            files: [],
                            embeds: [],
                            components: []
                        }).catch(() => {});

                        const infoProfile = await generationMafiaStats (pickMember);
            
                        components = [];
                        components.push(
                            {
                                type: 1,
                                components: [
                                    {
                                        type: 3,
                                        customId: 'mafiaSelect', 
                                        placeholder: `Выберите необходимый доступный тип мафии`, 
                                        minValues: 1, 
                                        maxValues: 1, 
                                        options: []
                                    }
                                ]
                            }
                        );
            
                        for (const pickMafiaSec in stats[pickMember.id][args.категория]) {
                            
                            components[0].components[0].options.push(
                                {
                                    label: `${pickMafiaSec}`, 
                                    value: `${pickMafiaSec}`, 
                                    emoji: appearance.emoji.Type, 
                                    default: pickMafia == pickMafiaSec
                                }
                            );
                        
                        };
            
                        setTimeout(() => {
                            
                            interaction.editReply({
                                content: ' ',
                                files: [
                                    {
                                        attachment: infoProfile[0], 
                                        name: infoProfile[1]
                                    }
                                ], 
                                components: components
                            }).catch(() => {});
            
                        }, 2000);

                    }

                }

            });

        };
        
    };

    // if (argsF.subcommand == 'punishments') {

    //     const pickMember = await guild.members.fetch(args.пользователь || member.id).catch(() => {});
            
    //     if (!pickMember) 
    //     return interaction.reply({
    //         ephemeral: true,  
    //         embeds: [
    //             {
    //                 title: `${client.user.username} error`,
    //                 color: appearance.embed.errorColor,
    //                 description: `${member}, пользователь \`${args.пользователь}\` не найден`,                          
    //                 thumbnail: { url: await getAvatar (pickMember) } 
    //             }
    //         ]
    //     }).catch(() => {});

    //     checkingForAvailability (db, pickMember);

    //     if (pickMember.user.bot) 
    //     return interaction.reply({
    //         ephemeral: true,  
    //         embeds: [
    //             {
    //                 title: `${client.user.username} error`,
    //                 color: appearance.embed.errorColor,
    //                 description: `${member}, Вы выбрали **недоступного** бота ${pickMember}, выберите **другого** пользователя`,                          
    //                 thumbnail: { url: await getAvatar (pickMember) } 
    //             }
    //         ]
    //     }).catch(() => {});


    //     let tempPage = 1;
    //     let punishmentsOfGo = [];


    //     for (const pickEvent in users[pickMember.id].Events) eventsOfGo.push(guilds[users[pickMember.id].Events[pickEvent].EventId]);


    //     if (!eventsOfGo[0]) 
    //     return interaction.reply({
    //         ephemeral: true,  
    //         embeds: [
    //             {
    //                 title: `${client.user.username} error`,
    //                 color: appearance.embed.errorColor,
    //                 description: pickMember.id == member.id ? `${member}, Вы **не проводили** какие-либо мероприятия\nСервер: **${guild.name}**` : `${member}, ${pickMember} **не проводил** какие-либо мероприятия\nСервер: **${guild.name}**`,                          
    //                 thumbnail: { url: await getAvatar (pickMember) } 
    //             }
    //         ]
    //     }).catch(() => {});


    //     async function getMessage (page) {

    //         let fields = [];

    //         for (let id = ( page - 1 ) * 10; id < eventsOfGo.length; id++) {
    
    //             if (id == ( ( page - 1 ) * 10 ) + 10 ) break;
    
    //             let eventsOfFetch = eventsOfGo[id];
                
    //             if (!eventsOfFetch) {

    //                 fields.push(
    //                     {
    //                         name: `${id+1}) Неизвестный`,
    //                         value: `-# Пусто`,
    //                         inline: false
    //                     }
    //                 );

    //             }

    //             else {

    //                 let eventOfMember = users[pickMember.id].Events.find(pickEvent => pickEvent.EventId == eventsOfFetch.EventId); 
    
    //                 if (eventOfMember) {
    
    //                     if (eventsOfFetch.type == 'event') {
                            
    //                         fields.push(
    //                             {
    //                                 name: `${id+1}) __${eventsOfFetch.Event.emoji}・${eventsOfFetch.Event.name}__ [<t:${Math.floor(eventOfMember.Created)}:f>]`,
    //                                 value: `・Продлилось: ${hourTranslatorBold(Math.floor(eventOfMember.Ended - eventOfMember.Created))} (https://discord.com/channels/${eventOfMember.message.log.guildId}/${eventOfMember.message.log.channelId}/${eventOfMember.message.log.id})\n-# ・Участников: ${eventsOfFetch.Online.length}`,
    //                                 inline: false
    //                             }
    //                         );
            
    //                     };
                        
    //                     if (eventsOfFetch.type == 'close') {
                            
    //                         fields.push(
    //                             {
    //                                 name: `${id+1}) __${eventsOfFetch.Event.emoji}・${eventsOfFetch.Event.name}__ [<t:${Math.floor(eventOfMember.Created)}:f>]`,
    //                                 value: `・Продлилось: ${hourTranslatorBold(Math.floor(eventOfMember.Ended - eventOfMember.Created))} (https://discord.com/channels/${eventOfMember.message.log.guildId}/${eventOfMember.message.log.channelId}/${eventOfMember.message.log.id})\n-# ・Было запущено: ${eventsOfFetch.started ? '**Да**' : '**Нет**'}`,
    //                                 inline: false
    //                             }
    //                         );
            
    //                     };
                        
    //                     if (eventsOfFetch.type == 'mafia') {
                            
    //                         fields.push(
    //                             {
    //                                 name: `${id+1}) __${eventsOfFetch.Event.emoji}・${eventsOfFetch.Event.name}__ [<t:${Math.floor(eventOfMember.Created)}:f>]`,
    //                                 value: `・Продлилось: ${hourTranslatorBold(Math.floor(eventOfMember.Ended - eventOfMember.Created))} (https://discord.com/channels/${eventOfMember.message.log.guildId}/${eventOfMember.message.log.channelId}/${eventOfMember.message.log.id})\n-# ・Было запущено: ${eventsOfFetch.started ? '**Да**' : '**Нет**'}`,
    //                                 inline: false
    //                             }
    //                         );
            
    //                     };
    
    //                 }
                    
    //                 else {

    //                     fields.push(
    //                         {
    //                             name: `${id+1}) Неизвестный`,
    //                             value: `-# Пусто`,
    //                             inline: false
    //                         }
    //                     );
                        
    //                 };

    //             };
    
    //         };

    //         if (!eventsOfGo[0]) 
    //         return {
    //             embeds: [
    //                 {
    //                     title: `${client.user.username} error`,
    //                     color: appearance.embed.errorColor,
    //                     description: pickMember.id == member.id ? `${member}, Вы **не проводили** какие-либо мероприятия${time == 'all' ? '' : time == 'day' ? ' **сегодня**' : time == 'week' ? ' **на** этой **недели**' : ''}. Сервер: **${guild.name}**` : `${member}, ${pickMember} **не проводил** какие-либо мероприятия ${time == 'all' ? '' : time == 'day' ? ' **сегодня**' : time == 'week' ? ' **на** этой **недели**' : ''}. Сервер: **${guild.name}**`,                          
    //                     thumbnail: { url: await getAvatar (pickMember) } 
    //                 }
    //             ], 
    //             components: [
    //                 {
    //                     type: 1,
    //                     components: [
    //                         {
    //                             type: 3,
    //                             customId: 'timeSelect', 
    //                             placeholder: 'Выберите необходимую категорию', 
    //                             minValues: 1, 
    //                             maxValues: 1, 
    //                             options: [
    //                                 {
    //                                     label: 'Все время',                       
    //                                     emoji: appearance.emoji.TimeType,     
    //                                     description: `Список проведенных мероприятий за все время`,
    //                                     value: 'all',
    //                                     default: time == 'all' 
    //                                 },
    //                                 {
    //                                     label: 'Неделя',  
    //                                     emoji: appearance.emoji.TimeType,
    //                                     description: `Список проведенных мероприятий за эту неделю`,
    //                                     value: 'week',
    //                                     default: time == 'week' 
    //                                 },
    //                                 {
    //                                     label: 'День', 
    //                                     emoji: appearance.emoji.TimeType,
    //                                     description: `Список проведенных мероприятий за этот день`,
    //                                     value: 'day',
    //                                     default: time == 'day' 
    //                                 }
    //                             ]
    //                         }
    //                     ]
    //                 }
    //             ]
    //         };

    //         else return {
    //             embeds: [
    //                 {
    //                     title: `${client.user.username} leads`,
    //                     color: appearance.embed.color,
    //                     description: `Всего **проведено**: **${eventsOfGo.length}**\nВедущий: ${pickMember}`,
    //                     footer: { text: `・Страница: ${page} из ${Math.ceil(eventsOfGo.length / 10)}` },
    //                     thumbnail: { url: await getAvatar (pickMember) },
    //                     fields: fields
    //                 }
    //             ], 
    //             components: [
    //                 {
    //                     type: 1,
    //                     components: [
    //                         {
    //                             type: 3,
    //                             customId: 'timeSelect', 
    //                             placeholder: 'Выберите необходимую категорию', 
    //                             minValues: 1, 
    //                             maxValues: 1, 
    //                             options: [
    //                                 {
    //                                     label: 'Все время',                       
    //                                     emoji: appearance.emoji.TimeType,     
    //                                     description: `Список проведенных мероприятий за все время`,
    //                                     value: 'all',
    //                                     default: time == 'all' 
    //                                 },
    //                                 {
    //                                     label: 'Неделя',  
    //                                     emoji: appearance.emoji.TimeType,
    //                                     description: `Список проведенных мероприятий за эту неделю`,
    //                                     value: 'week',
    //                                     default: time == 'week' 
    //                                 },
    //                                 {
    //                                     label: 'День', 
    //                                     emoji: appearance.emoji.TimeType,
    //                                     description: `Список проведенных мероприятий за этот день`,
    //                                     value: 'day',
    //                                     default: time == 'day' 
    //                                 }
    //                             ]
    //                         }
    //                     ]
    //                 },
    //                 pageChange(page !== 1, false, page !== Math.ceil(eventsOfGo.length / 10), 'stats')
    //             ]
    //         };

    //     };
        
    //     interaction.reply(await getMessage (tempPage)).catch(() => {});
        
    //     let lastInt = Date.now() / 1000;
    //     const cheackLastInt = setInterval(async () => {
    
    //         if (lastInt + 100 - Date.now() / 1000 < 0) {
              
    //             await targetMessageEditComponents(interaction);
    //             return clearInterval(cheackLastInt);
    
    //         };
    
    //     }, 2000); 
    
    //     const collectorConponents = await channel.createMessageComponentCollector();
    //     collectorConponents.on('collect', async i => {
    
    //         if (!i.message.interaction || i.message.interaction.id !== interaction.id) return;
    
    //         lastInt = Date.now() / 1000;
    //         if (actions[i.customId] && actions[i.customId].all == true) return await actions[i.customId].actions[0](i);
    
    //         if (!i.member || i.member.id !== member.id) return;
    
    //         switch (i.customId) { 
    
    //             case 'timeSelect': { 
    
    //                 tempPage = 1;
    //                 time = i.values[0];
                    
    //                 eventsOfGo = [];
    //                 if (time == 'all') for (const pickEvent in users[pickMember.id].Events) eventsOfGo.push(guilds[users[pickMember.id].Events[pickEvent].EventId]);
    //                 if (time == 'week') for (const pickEvent in users[pickMember.id].Events) if (users[member.id].Events[pickEvent].Created > getCurrentWeekMondayUnixMSK ()) eventsOfGo.push(guilds[users[pickMember.id].Events[pickEvent].EventId]);
    //                 if (time == 'day') for (const pickEvent in users[pickMember.id].Events) if (users[member.id].Events[pickEvent].Created > getTodayStartUnixMSK()) eventsOfGo.push(guilds[users[pickMember.id].Events[pickEvent].EventId]);


    //                 i.update(await getMessage (tempPage)).catch(() => {});
                    
    //                 break;
    
    //             }
    
    //             case 'statsLeft': { 
    
    //                 tempPage -= 1;
    //                 if (tempPage <= 0) tempPage = 1;
                    
    //                 i.update(await getMessage (tempPage))//.catch(() => {});
                    
    //                 break;
    
    //             }
    
    //             case 'statsRight': { 

    //                 tempPage++;
    //                 if (tempPage == 1) tempPage++;
    //                 if (tempPage > Math.ceil(eventsOfGo.length / 10)) tempPage = Math.ceil(eventsOfGo.length / 10);
                    
    //                 i.update(await getMessage (tempPage))//.catch(() => {});
                    
    //                 break;
    
    //             }
    
    //         };
    
    //     });

    // };

};

module.exports.names = ['event'];
module.exports.interaction = {

    name: 'event',
    description: 'Управление, создание, информация о мероприятиях',
    options: [

        {

            name: 'create',
            description: 'Создать мероприятия на данном сервере',
            options: [
                {

                    name: 'название',
                    description: 'То мероприятие, которое вы хотите запустить',
                    autocomplete: true,
                    required: false,
                    type: 3

                }
            ],

            type: 1
            
        },
        {

            name: 'reward',
            description: 'Выдать награды за проведенное мероприятие',
            type: 1

        },
        // {

        //     name: 'punishments',
        //     description: 'История выдачи наказаний выбранного пользователя',
        //     type: 1,
        //     options: [
        //         {

        //             name: 'пользователь',
        //             description: 'Тот, чью историю вы хотите посмотреть',
        //             required: false,
        //             type: 6

        //         }
        //     ]
        // },
        {

            name: 'stats',
            description: 'Статистика по мероприятиям',
            type: 1,
            options: [
                {

                    name: 'категория',
                    description: 'Выберите необходимую категорию мероприятий',
                    required: true,
                    choices: [
                        {
                            name: "Мафия",
                            value: "Mafia",
                        }
                    ],
                    type: 3

                },
                {

                    name: 'пользователь',
                    description: 'Тот, статистику кого вы хотите посмотреть',
                    required: false,
                    type: 6

                }
            ]

        },
        {
            
            name: 'top',
            description: 'Список лучших игроков в определенной категории',
            type: 1,
            options: [
                {

                    name: 'категория',
                    description: 'Выберите необходимую категорию мероприятий',
                    required: true,
                    choices: [
                        {
                            name: "Мафия",
                            value: "Mafia",
                        }
                    ],
                    type: 3

                }
            ]

        },
        {

            name: 'delete',
            description: 'Досрочно завершить необходимое мероприятие',
            options: [
                {

                    name: 'мероприятие',
                    description: 'То мероприятие, которое вы хотите завершить',
                    autocomplete: true,
                    required: false,
                    type: 3

                }
            ],

            type: 1

        },
        {

            name: 'transfer',
            description: 'Передать выбранное мероприятие другому ведущему',
            options: [
                {

                    name: 'пользователь',
                    description: 'Тот, кому вы хотите передать мероприятие',
                    required: true,
                    type: 6

                },
                {

                    name: 'мероприятие',
                    description: 'То мероприятие, которое вы хотите передать',
                    autocomplete: true,
                    required: false,
                    type: 3

                },
            ],

            type: 1

        },
        {
            
            name: 'ban',
            description: 'Выдать наказание необходимому пользователю',
            options: [
                {

                    name: 'пользователь',
                    description: 'Тот, с кем вы хотите взаимодействовать',
                    required: true,
                    type: 6

                },
                {

                    name: 'наказание',
                    description: 'То наказание, которое вы хотите выдать',
                    autocomplete: true,
                    required: true,
                    type: 3

                },
                {

                    name: 'единица',
                    description: 'Необходимая единица измерения времяни',
                    required: true,
                    choices: [
                        {
                            name: "секунды",
                            value: "1",
                        },
                        {
                            name: "минуты",
                            value: "60",
                        },
                        {
                            name: "часы",
                            value: "3600",
                        },
                        {
                            name: "дни",
                            value: "86400",
                        },
                        {
                            name: "недели",
                            value: "604800",
                        },
                        {
                            name: "месяца",
                            value: "18144000",
                        }
                    ],
                    type: 3

                },
                {

                    name: 'длительность',
                    description: 'Напишите необходимую длительность выдачи наказания',
                    required: true,
                    min_value: 1,
                    type: 10

                },
                {

                    name: 'причина',
                    description: 'Напишите причину, по которой вы выдаете наказание',
                    required: true,
                    type: 3

                }
            ],

            type: 1

        },
        {
            
            name: 'unban',
            description: 'Снять наказание необходимому пользователю',
            options: [
                {

                    name: 'пользователь',
                    description: 'Тот, с кем вы хотите взаимодействовать',
                    required: true,
                    type: 6

                },
                {

                    name: 'наказание',
                    description: 'То наказание, которое вы хотите снять',
                    autocomplete: true,
                    required: true,
                    type: 3

                },
                {

                    name: 'причина',
                    description: 'Напишите причину, по которой вы снять наказание',
                    required: true,
                    type: 3

                }
            ],

            type: 1

        }

    ],

    defaultPermission: true

};
